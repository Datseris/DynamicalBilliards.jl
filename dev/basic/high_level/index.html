<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>High Level API · DynamicalBilliards.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/logo.ico" rel="icon" type="image/x-icon"/><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DynamicalBilliards.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">DynamicalBilliards.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li class="is-active"><a class="tocitem" href>High Level API</a><ul class="internal"><li><a class="tocitem" href="#Billiard-1"><span>Billiard</span></a></li><li><a class="tocitem" href="#Particles-1"><span>Particles</span></a></li><li><a class="tocitem" href="#Random-initial-conditions-1"><span>Random initial conditions</span></a></li><li><a class="tocitem" href="#evolve-and-timeseries-1"><span><code>evolve</code> &amp; <code>timeseries</code></span></a></li><li><a class="tocitem" href="#Poincaré-Sections-1"><span>Poincaré Sections</span></a></li><li><a class="tocitem" href="#Escape-Times-1"><span>Escape Times</span></a></li><li><a class="tocitem" href="#Mean-Collision-Times-1"><span>Mean Collision Times</span></a></li><li><a class="tocitem" href="#Parallelization-1"><span>Parallelization</span></a></li><li><a class="tocitem" href="#It&#39;s-all-about-bounce!-1"><span>It&#39;s all about bounce!</span></a></li><li><a class="tocitem" href="#Standard-Billiards-Library-1"><span>Standard Billiards Library</span></a></li><li><a class="tocitem" href="#Particle-types-1"><span>Particle types</span></a></li></ul></li><li><a class="tocitem" href="../../visualizing/">Visualizing &amp; Animating</a></li><li><a class="tocitem" href="../phasespaces/">Phase Spaces</a></li><li><a class="tocitem" href="../../ray-splitting/">Ray-Splitting</a></li><li><a class="tocitem" href="../../lyapunovs/">Lyapunov Exponents</a></li><li><a class="tocitem" href="../../mushroomtools/">MushroomTools</a></li><li><a class="tocitem" href="../../physics/">Physics</a></li><li><a class="tocitem" href="../low_level/">Internals</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/billiard_table/">Defining a Billiard</a></li><li><a class="tocitem" href="../../tutorials/own_obstacle/">Defining your own Obstacles</a></li><li><a class="tocitem" href="../../tutorials/examples/">Examples</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>High Level API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>High Level API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/master/docs/src/basic/high_level.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="High-Level-API-1"><a class="docs-heading-anchor" href="#High-Level-API-1">High Level API</a><a class="docs-heading-anchor-permalink" href="#High-Level-API-1" title="Permalink"></a></h1><p><code>DynamicalBilliards</code> was created with ease-of-use as its main cornerstone. With 3 simple steps, the user can get the output of the propagation of a particle in a billiard.</p><p>In general, the workflow of <code>DynamicalBilliards</code> follows these simple steps:</p><ol><li>Create a billiard.</li><li>Create particles inside that billiard.</li><li>Get the output you want by using one of the high level functions.</li></ol><p>Adding more complexity in your billiard does not add complexity in your code. For example, to implement a ray-splitting billiard you only need to define one additional variable, a <a href="../../ray-splitting/#DynamicalBilliards.RaySplitter"><code>RaySplitter</code></a> and pass it to the high level functions.</p><p>After reading through this page, you will be able to use almost all aspects of <code>DynamicalBilliards</code> with minimal effort.</p><div class="admonition is-success"><header class="admonition-header">Visualizations</header><div class="admonition-body"><p>Visualizing the billiards, particles, and their motion is one of the most important parts of the <code>DynamicalBilliards</code>. It is not discussed in this page however, but rather in the <a href="../../visualizing/#Visualizing-and-Animating-1">Visualizing &amp; Animating</a> page.</p></div></div><h2 id="Billiard-1"><a class="docs-heading-anchor" href="#Billiard-1">Billiard</a><a class="docs-heading-anchor-permalink" href="#Billiard-1" title="Permalink"></a></h2><p>A <a href="../../tutorials/billiard_table/#DynamicalBilliards.Billiard"><code>Billiard</code></a> is simply a collection of <a href="../../tutorials/billiard_table/#DynamicalBilliards.Obstacle"><code>Obstacle</code></a> subtypes. Particles are propagating inside a <code>Billiard</code>, bouncing from obstacle to obstacle while having constant velocity in-between.</p><p>There is a tutorial on how to create your own billiard. In addition, there are many pre-defined billiards that can be found in the <a href="#Standard-Billiards-Library-1">Standard Billiards Library</a> section. That is why knowing how to construct a <a href="../../tutorials/billiard_table/#DynamicalBilliards.Billiard"><code>Billiard</code></a> is not important at this point.</p><p>In this page we will be using the Bunimovich billiard as an example:</p><pre><code class="language-julia">using DynamicalBilliards
bd = billiard_bunimovich()</code></pre><pre><code class="language-none">Billiard{Float64} with 4 obstacles:
  Bottom wall
  Right semicircle
  Top wall
  Left semicircle</code></pre><h2 id="Particles-1"><a class="docs-heading-anchor" href="#Particles-1">Particles</a><a class="docs-heading-anchor-permalink" href="#Particles-1" title="Permalink"></a></h2><p>A &quot;particle&quot; is that thingy that moves around in the billiard. It always moves with velocity of measure 1, by convention.</p><p>Currently there are two types of particles:</p><ul><li><a href="#DynamicalBilliards.Particle"><code>Particle</code></a>, which propagates as a straight line.</li><li><a href="#DynamicalBilliards.MagneticParticle"><code>MagneticParticle</code></a>, which propagates as a circle instead of a line (similar to electrons in a perpendicular magnetic field).</li></ul><p>There are two ways to create a particle. The first one is to provide the constructor with some initial conditions:</p><pre><code class="language-julia">x0 = rand(); y0 = rand();
φ0 = 2π*rand()
p = Particle(x0, y0, φ0)</code></pre><pre><code class="language-none">Particle{Float64}
position: [0.32311678007042244, 0.3814945759186277]
velocity: [0.950250855731758, 0.31148565164556397]</code></pre><p>To create a <code>MagneticParticle</code> simply provide the constructor with one more number, the angular velocity:</p><pre><code class="language-julia">ω = 0.5
mp = MagneticParticle(x0, y0, φ0, ω)</code></pre><pre><code class="language-none">MagneticParticle{Float64}
position: [0.32311678007042244, 0.3814945759186277]
velocity: [0.950250855731758, 0.31148565164556397]
ang. velocity: 0.5</code></pre><p>When creating a billiard or a particle, the object is printed with <code>{Float64}</code> at the end. This shows what type of numbers are used for <em>all</em> numerical operations. If you are curious you can learn more about it in the <a href="../low_level/#Numerical-Precision-1">Numerical Precision</a>.</p><div class="admonition is-danger"><header class="admonition-header">Particles must be inside the Billiard!</header><div class="admonition-body"><p>Keep in mind that the particle must be initialized <strong>inside a billiard</strong> for any functionality to work properly and make sense. If you are not sure what we mean by that, then you should check out the <a href="../low_level/#Internals-1">Internals</a> page.</p></div></div><h2 id="Random-initial-conditions-1"><a class="docs-heading-anchor" href="#Random-initial-conditions-1">Random initial conditions</a><a class="docs-heading-anchor-permalink" href="#Random-initial-conditions-1" title="Permalink"></a></h2><p>If you have a <code>Billiard</code> which is not a rectangle, creating many random initial conditions inside it can be a pain. Fortunately, the second way to create a particle is to use the following function:</p><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.randominside" href="#DynamicalBilliards.randominside"><code>DynamicalBilliards.randominside</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">randominside(bd::Billiard [, ω])</code></pre><p>Return a particle with random allowed initial conditions inside the given billiard. If supplied with a second argument the type of the returned particle is <code>MagneticParticle</code>, with angular velocity <code>ω</code>.</p><p><strong>WARNING</strong> : <code>randominside</code> works for any <strong>convex</strong> billiard but it does not work for non-convex billiards. (this is because it uses <code>distance</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/d756c1d6f686dfabe749e6c77a04932414e79b0b/src/billiards/billiardtable.jl#L124-L132">source</a></section></article><hr/><p>For example:</p><pre><code class="language-julia">p = randominside(bd)</code></pre><pre><code class="language-none">Particle{Float64}
position: [0.3960889741667031, 0.30063136764108345]
velocity: [-0.8098117101898932, -0.5866898618855799]</code></pre><p>and</p><pre><code class="language-julia">mp = randominside(bd, ω)</code></pre><pre><code class="language-none">MagneticParticle{Float64}
position: [1.2684200921519406, 0.42665156342329436]
velocity: [0.27272038631818285, -0.9620933379285302]
ang. velocity: 0.5</code></pre><p><code>randominside</code> always creates particles with same number type as the billiard.</p><h2 id="evolve-and-timeseries-1"><a class="docs-heading-anchor" href="#evolve-and-timeseries-1"><code>evolve</code> &amp; <code>timeseries</code></a><a class="docs-heading-anchor-permalink" href="#evolve-and-timeseries-1" title="Permalink"></a></h2><p>Now that we have created a billiard and a particle inside, we want to evolve it! There is a simple function for that, called <code>evolve!</code> (or <code>evolve</code> if you don&#39;t want to mutate the particle), which returns the time, position and velocities at the collision points:</p><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.evolve!" href="#DynamicalBilliards.evolve!"><code>DynamicalBilliards.evolve!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">evolve!([p::AbstractParticle,] bd::Billiard, t)</code></pre><p>Evolve the given particle <code>p</code> inside the billiard <code>bd</code>. If <code>t</code> is of type <code>AbstractFloat</code>, evolve for as much time as <code>t</code>. If however <code>t</code> is of type <code>Int</code>, evolve for as many collisions as <code>t</code>. Return the states of the particle between collisions.</p><p>This function mutates the particle, use <code>evolve</code> otherwise. If a particle is not given, a random one is picked through <a href="#DynamicalBilliards.randominside"><code>randominside</code></a>.</p><p><strong>Return</strong></p><ul><li><code>ct::Vector{T}</code> : Collision times.</li><li><code>poss::Vector{SVector{2,T}}</code> : Positions at the collisions.</li><li><code>vels::Vector{SVector{2,T}})</code> : Velocities exactly after the collisions.</li><li><code>ω</code>, either <code>T</code> or <code>Vector{T}</code> : Angular velocity/ies (returned only for magnetic particles).</li></ul><p>The time <code>ct[i+1]</code> is the time necessary to reach state <code>poss[i+1], vels[i+1]</code> starting from the state <code>poss[i], vels[i]</code>. That is why <code>ct[1]</code> is always 0 since <code>poss[1], vels[1]</code> are the initial conditions. The angular velocity <code>ω[i]</code> is the one the particle has while propagating from state <code>poss[i], vels[i]</code> to <code>i+1</code>.</p><p>Notice that at any point, the velocity vector <code>vels[i]</code> is the one obdained <em>after</em> the specular reflection of the <code>i-1</code>th collision.</p><p><strong>Ray-splitting billiards</strong></p><pre><code class="language-none">evolve!(p, bd, t, raysplitters)</code></pre><p>To implement ray-splitting, the <code>evolve!</code> function is supplemented with a fourth argument, <code>raysplitters</code> which is a tuple of <a href="../../ray-splitting/#DynamicalBilliards.RaySplitter"><code>RaySplitter</code></a> instances. Notice that <code>evolve</code> <strong>always mutates the billiard</strong> if ray-splitting is used! For more information and instructions on using ray-splitting please visit the official documentation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/d756c1d6f686dfabe749e6c77a04932414e79b0b/src/timeevolution/timeseries.jl#L5-L39">source</a></section></article><hr/><p>Forget the ray-splitting part for now (see <a href="../../ray-splitting/#Ray-Splitting-1">Ray-Splitting</a>).</p><p>Let&#39;s see an example:</p><pre><code class="language-julia">ct, poss, vels = evolve(p, bd, 100)
for i in 1:5
  println(round(ct[i], digits=3), &quot;  &quot;, poss[i], &quot;  &quot;, vels[i])
end</code></pre><pre><code class="language-none">0.0  [0.3960889741667031, 0.30063136764108345]  [-0.809811710189893, -0.5866898618855798]
0.512  [-0.01840658574571291, 0.00033891726372597963]  [-0.7644502316184767, 0.6446827463012001]
0.616  [-0.4893873705519369, 0.39753048480518094]  [0.44160367914462517, 0.8972102265165791]
0.616  [-0.21731361247810305, 0.9503052229673967]  [0.9771547537375047, -0.21252902683679942]
1.751  [1.493858120300629, 0.5781291047761952]  [-0.8638341676579113, -0.5037762705673665]</code></pre><p>Similarly, for magnetic propagation</p><pre><code class="language-julia">ct, poss, vels, ω = evolve(mp, bd, 100)
for i in 1:10
  println(round(ct[i], digits=3), &quot;  &quot;, poss[i], &quot;  &quot;, vels[i])
end</code></pre><pre><code class="language-none">0.0  [1.2684200921519406, 0.42665156342329436]  [0.27272038631818285, -0.9620933379285302]
0.285  [1.3654527910740357, 0.15876070347013488]  [-0.9392691162066001, 0.3431814787258669]
1.65  [-0.23542298639748585, 0.05889228359085664]  [-0.11513377728890384, 0.993349995382891]
0.712  [-0.440287306305407, 0.7369537674448936]  [0.9937439235086583, 0.11168265079956785]
0.838  [0.34941260140380526, 1.0]  [0.8622208072311051, -0.5065326046541739]
1.146  [1.4459162601370987, 0.7261828661621905]  [-0.6238781299205152, -0.7815216433387372]
0.813  [1.079914469136325, 0.006427636893375277]  [-0.554866300382598, 0.8319395342810247]
1.706  [-0.3251101270540919, 0.8798728804309044]  [-0.025253694532978876, -0.9996810745995119]
0.878  [-0.15699240965575934, 0.025285998404851944]  [0.8686733062947365, 0.4953853923269961]
1.323  [0.7011260670166206, 1.0]  [0.38131630549716233, -0.9244446306631863]</code></pre><p>The above return types are helpful in some applications. In other applications however one prefers to have the time series of the individual variables. For this, the <code>timeseries</code> function is used:</p><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.timeseries!" href="#DynamicalBilliards.timeseries!"><code>DynamicalBilliards.timeseries!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">timeseries!([p::AbstractParticle,] bd::Billiard, t; dt, warning)</code></pre><p>Evolve the given particle <code>p</code> inside the billiard <code>bd</code> for the condition <code>t</code> and return the x, y, vx, vy timeseries and the time vector. If <code>t</code> is of type <code>AbstractFloat</code>, then evolve for as much time as <code>t</code>. If however <code>t</code> is of type <code>Int</code>, evolve for as many collisions as <code>t</code>. Otherwise, <code>t</code> can be any function, that takes as an input <code>t(n, τ, i, p)</code> and returns <code>true</code> when the evolution should terminate. Here <code>n</code> is the amount of obstacles collided with so far, <code>τ</code> the amount time evolved so far, <code>i</code> the obstacle just collided with and <code>p</code> the particle (so you can access e.g. <code>p.pos</code>).</p><p>This function mutates the particle, use <code>timeseries</code> otherwise. If a particle is not given, a random one is picked through <a href="#DynamicalBilliards.randominside"><code>randominside</code></a>.</p><p>The keyword argument <code>dt</code> is the time step used for interpolating the time series in between collisions. <code>dt</code> is capped by the collision time, as the interpolation <em>always</em> stops at collisions. For straight propagation <code>dt = Inf</code>, while for magnetic <code>dt = 0.01</code>.</p><p>For pinned magnetic particles, <code>timeseries!</code> issues a warning and returns the trajectory of the particle. If <code>t</code> is integer, the trajectory is evolved for one full circle only.</p><p>Internally uses <a href="../low_level/#DynamicalBilliards.extrapolate"><code>DynamicalBilliards.extrapolate</code></a>.</p><p><strong>Ray-splitting billiards</strong></p><pre><code class="language-none">timeseries!(p, bd, t, raysplitters; ...)</code></pre><p>To implement ray-splitting, the <code>timeseries!</code> function is supplemented with a fourth argument, <code>raysplitters</code> which is a tuple of <a href="../../ray-splitting/#DynamicalBilliards.RaySplitter"><code>RaySplitter</code></a> instances. Notice that <code>timeseries</code> <strong>always mutates the billiard</strong> if ray-splitting is used! For more information and instructions on using ray-splitting please visit the official documentation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/d756c1d6f686dfabe749e6c77a04932414e79b0b/src/timeevolution/timeseries.jl#L107-L141">source</a></section></article><hr/><p>For example:</p><pre><code class="language-julia">xt, yt, vxt, vyt, t = timeseries(p, bd, 100)

# print as a matrix:
hcat(xt, yt, vxt, vyt, t)[1:5, :]</code></pre><pre><code class="language-none">5×5 Array{Float64,2}:
  0.396089   0.300631     -0.809812  -0.58669   0.0     
 -0.0184066  0.000338917  -0.76445    0.644683  0.511842
 -0.489387   0.39753       0.441604   0.89721   1.12795 
 -0.217314   0.950305      0.977155  -0.212529  1.74405 
  1.49386    0.578129     -0.863834  -0.503776  3.49523 </code></pre><p>Same story for magnetic particles:</p><pre><code class="language-julia"># evolve the magnetic particle instead:
xt, yt, vxt, vyt, t = timeseries(mp, bd, 100)

# print as a matrix:
hcat(xt, yt, vxt, vyt, t)[1:5, :]</code></pre><pre><code class="language-none">5×5 Array{Float64,2}:
 1.26842  0.426652  0.27272   -0.962093  0.0 
 1.27117  0.417037  0.277527  -0.960718  0.01
 1.27397  0.407437  0.282328  -0.959318  0.02
 1.27682  0.397851  0.287121  -0.957894  0.03
 1.27971  0.388279  0.291906  -0.956447  0.04</code></pre><p>Sometimes we may need information about which obstacles a particle visited, in which sequence, and when. For this we have the following function:</p><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.visited_obstacles!" href="#DynamicalBilliards.visited_obstacles!"><code>DynamicalBilliards.visited_obstacles!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">visited_obstacles!([p::AbstractParticle,] bd::Billiard, t)</code></pre><p>Evolve the given particle <code>p</code> inside the billiard <code>bd</code> exactly like <a href="#DynamicalBilliards.evolve!"><code>evolve!</code></a>. However return only:</p><ul><li><code>ts::Vector{T}</code> : Vector of time points of when each collision occured.</li><li><code>obst::Vector{Int}</code> : Vector of obstacle indices in <code>bd</code> that the particle collided with at the time points in <code>ts</code>.</li></ul><p>The first entries are <code>0.0</code> and <code>0</code>. Similarly with <a href="#DynamicalBilliards.evolve!"><code>evolve!</code></a> the function does not record collisions with periodic walls.</p><p>Currently does not support raysplitting. Returns empty arrays for pinned particles.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/d756c1d6f686dfabe749e6c77a04932414e79b0b/src/timeevolution/highleveltimes.jl#L122-L137">source</a></section></article><div class="admonition is-info"><header class="admonition-header">Type of `t`</header><div class="admonition-body"><p>Remember that the behavior of time evolution depends on the type of the <code>t</code> argument, which represents &quot;total amount&quot;. If it is <code>AbstractFloat</code>, it represents total amount of time, but if it is <code>Int</code> it represents total number of collisions.</p></div></div><h2 id="Poincaré-Sections-1"><a class="docs-heading-anchor" href="#Poincaré-Sections-1">Poincaré Sections</a><a class="docs-heading-anchor-permalink" href="#Poincaré-Sections-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.psos" href="#DynamicalBilliards.psos"><code>DynamicalBilliards.psos</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">psos(bd::Billiard, plane::InfiniteWall, t, particles)</code></pre><p>Compute the Poincaré section of the <code>particles</code> with the given <code>plane</code>, by evolving each one for time <code>t</code> (either integer or float) inside <code>bd</code>.</p><p>The <code>plane</code> can be an <a href="../../tutorials/billiard_table/#DynamicalBilliards.InfiniteWall"><code>InfiniteWall</code></a> of <em>any</em> orientation, however only crossings of the <code>plane</code> such that <code>dot(velocity, normal) &lt; 0</code> are allowed, with <code>normal</code> the normal unit vector of the <code>plane</code>.</p><p><code>particles</code> can be:</p><ul><li>A single particle.</li><li>A <code>Vector</code> of particles.</li><li>An integer <code>n</code> optionally followed by an angular velocity <code>ω</code>.</li></ul><p>Return the positions <code>poss</code> and velocities <code>vels</code> at the instances of crossing the <code>plane</code>. If given more than one particle, the result is a vector of vectors of vectors.</p><p><em>Notice</em> - This function can handle pinned particles. If a pinned particle can intersect with the <code>plane</code>, then an intersection is returned. If however it can&#39;t then empty vectors are returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/d756c1d6f686dfabe749e6c77a04932414e79b0b/src/poincare.jl#L3-L24">source</a></section></article><hr/><p>For example, the surface of section in the periodic Sinai billiard with magnetic field reveals the mixed nature of the phase-space:</p><pre><code class="language-julia">using DynamicalBilliards, PyPlot
t = 100; r = 0.15
bd = billiard_sinai(r, setting = &quot;periodic&quot;)

# the direction of the normal vector is IMPORTANT!!!
# (always keep in mind that ω &gt; 0  means counter-clockwise rotation!)
plane = InfiniteWall([0.5, 0.0], [0.5, 1.0], [-1.0, 0.0])

posvector, velvector = psos(bd, plane, t, 1000, 2.0)
c(a) = length(a) == 1 ? &quot;C1&quot; : &quot;C0&quot;

figure()
for i in 1:length(posvector)
    poss = posvector[i] # vector of positions
    vels = velvector[i] # vector of velocities at the section
    L = length(poss)
    if L &gt; 0
        #plot y vs vy
        y = [a[2] for a in poss]
        vy = [a[2] for a in vels]

        plot(y, vy, ls = &quot;None&quot;, color = c(y), ms = 2.0, alpha = 0.75, marker = &quot;o&quot;)
    end
end
xlabel(&quot;\$y\$&quot;); ylabel(&quot;\$v_y\$&quot;)</code></pre><p><img src="../psos.png" alt/></p><div class="admonition is-info"><header class="admonition-header">`psos` operates on the unit cell</header><div class="admonition-body"><p>The <code>psos</code> function always calculates the crossings <em>within</em> the unit cell of a periodic billiard. This means that no information about the &quot;actual&quot; position of the particle is stored, everything is modulo the unit cell.</p><p>This can be seen very well in the above example, where there aren&#39;t any entries in the region <code>0.5 - r ≤ y ≤ 0.5 + r</code>.</p></div></div><p>Of course it is very easy to &quot;re-normalize&quot; the result such that it is coherent. The only change we have to do is simply replace the line <code>y = [a[2] for a in poss]</code> with</p><pre><code class="language-julia">y = [a[2] &lt; 0.5 ? a[2] + 1 : a[2]  for a in poss]</code></pre><h2 id="Escape-Times-1"><a class="docs-heading-anchor" href="#Escape-Times-1">Escape Times</a><a class="docs-heading-anchor-permalink" href="#Escape-Times-1" title="Permalink"></a></h2><p>It is very easy to create your own function that calculates an &quot;escape time&quot;: the time until the particle leaves the billiard by meeting a specified condition. There is also a high-level function for this though:</p><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.escapetime" href="#DynamicalBilliards.escapetime"><code>DynamicalBilliards.escapetime</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">escapetime([p,] bd, t; warning = false)</code></pre><p>Calculate the escape time of a particle <code>p</code> in the billiard <code>bd</code>, which is the time until colliding with any &quot;door&quot; in <code>bd</code>. As a &quot;door&quot; is considered any <a href="../../tutorials/billiard_table/#DynamicalBilliards.FiniteWall"><code>FiniteWall</code></a> with field <code>isdoor = true</code>.</p><p>If the particle evolves for more than <code>t</code> (integer or float) without colliding with the <code>Door</code> (i.e. escaping) the returned result is <code>Inf</code>.</p><p>A warning can be thrown if the result is <code>Inf</code>. Enable this using the keyword <code>warning = true</code>.</p><p>If a particle is not given, a random one is picked through <a href="#DynamicalBilliards.randominside"><code>randominside</code></a>. See <a href="#DynamicalBilliards.parallelize"><code>parallelize</code></a> for a parallelized version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/d756c1d6f686dfabe749e6c77a04932414e79b0b/src/timeevolution/highleveltimes.jl#L5-L20">source</a></section></article><p>To create a &quot;door&quot; simply use <a href="../../tutorials/billiard_table/#DynamicalBilliards.FiniteWall"><code>FiniteWall</code></a>.</p><p>For example, the default implementation of the mushroom billiard has a &quot;door&quot; at the bottom of the stem. Thus,</p><pre><code class="language-julia">using Statistics
bd = billiard_mushroom()
et = zeros(100)
for i ∈ 1:100
    particle = randominside(bd)
    et[i] = escapetime(particle, bd, 10000)
end
println(&quot;Out of 100 particles, $(count(x-&gt; x != Inf, et)) escaped&quot;)
println(&quot;Mean escape time was $(mean(et[et .!= Inf]))&quot;)</code></pre><pre><code class="language-none">Out of 100 particles, 22 escaped
Mean escape time was 5.649397172448355</code></pre><p>Of course, <code>escapetime</code> works with <code>MagneticParticle</code> as well</p><pre><code class="language-julia">escapetime(randominside(bd, 1.0), bd, 10000)</code></pre><pre><code class="language-none">36.43510694774968</code></pre><h2 id="Mean-Collision-Times-1"><a class="docs-heading-anchor" href="#Mean-Collision-Times-1">Mean Collision Times</a><a class="docs-heading-anchor-permalink" href="#Mean-Collision-Times-1" title="Permalink"></a></h2><p>Because the computation of a mean collision time (average time between collisions in a billiard) is often a useful quantity, the following function computes it</p><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.meancollisiontime" href="#DynamicalBilliards.meancollisiontime"><code>DynamicalBilliards.meancollisiontime</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">meancollisiontime([p,] bd, t) → κ</code></pre><p>Compute the mean collision time <code>κ</code> of the particle <code>p</code> in the billiard <code>bd</code> by evolving for total amount <code>t</code> (either float for time or integer for collision number).</p><p>Collision times are counted only between obstacles that are <em>not</em> <a href="../../tutorials/billiard_table/#DynamicalBilliards.PeriodicWall"><code>PeriodicWall</code></a>.</p><p>If a particle is not given, a random one is picked through <a href="#DynamicalBilliards.randominside"><code>randominside</code></a>. See <a href="#DynamicalBilliards.parallelize"><code>parallelize</code></a> for a parallelized version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/d756c1d6f686dfabe749e6c77a04932414e79b0b/src/timeevolution/highleveltimes.jl#L70-L80">source</a></section></article><p>For example,</p><pre><code class="language-julia">bd = billiard_sinai()
meancollisiontime(randominside(bd), bd, 10000.0)</code></pre><pre><code class="language-none">0.4491462636042151</code></pre><h2 id="Parallelization-1"><a class="docs-heading-anchor" href="#Parallelization-1">Parallelization</a><a class="docs-heading-anchor-permalink" href="#Parallelization-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.parallelize" href="#DynamicalBilliards.parallelize"><code>DynamicalBilliards.parallelize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">parallelize(f, bd::Billiard, t, particles; partype = :threads)</code></pre><p>Parallelize function <code>f</code> across the available particles. The parallelization type can be <code>:threads</code> or <code>:pmap</code>, which use threads or a worker pool initialized with <code>addprocs</code> <em>before</em> <code>using DynamicalBilliards</code>.</p><p><code>particles</code> can be:</p><ul><li>A <code>Vector</code> of particles.</li><li>An integer <code>n</code> optionally followed by an angular velocity <code>ω</code>. This uses <a href="#DynamicalBilliards.randominside"><code>randominside</code></a>.</li></ul><p>The functions usable here are:</p><ul><li><a href="#DynamicalBilliards.meancollisiontime"><code>meancollisiontime</code></a></li><li><a href="#DynamicalBilliards.escapetime"><code>escapetime</code></a></li><li><a href="../../lyapunovs/#DynamicalBilliards.lyapunovspectrum"><code>lyapunovspectrum</code></a> (returns only the maximal exponents)</li><li><a href="../phasespaces/#DynamicalBilliards.boundarymap"><code>boundarymap</code></a> (returns vector of vectors of 2-vectors <em>and</em> <code>arcintervals</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/d756c1d6f686dfabe749e6c77a04932414e79b0b/src/parallel.jl#L9-L25">source</a></section></article><hr/><p>Here are some examples</p><pre><code class="language-julia">bd = billiard_stadium()
particles = [randominside(bd) for i in 1:1000]
parallelize(meancollisiontime, bd, 1000, particles)</code></pre><pre><code class="language-none">1000-element Array{Float64,1}:
 1.0910760874795706
 1.0935708182287753
 1.0808323688949426
 1.0790344372255767
 1.1042879697693753
 1.0761736926000571
 1.1246546892644502
 1.0893654747666892
 1.101031850677592 
 1.1356339668381432
 ⋮                 
 1.0638250107674634
 1.070676295266197 
 1.1021478592386187
 1.0699349537337028
 1.0948912880405983
 1.0935170733341744
 1.063915626471636 
 1.0932765984305985
 1.0848581940228919</code></pre><pre><code class="language-julia">parallelize(lyapunovspectrum, bd, 1000, particles)</code></pre><pre><code class="language-none">1000-element Array{Float64,1}:
 0.8858456827431305
 0.8440588739475285
 0.8862175933132432
 0.8737002962135684
 0.8450432022763991
 0.8813130084266383
 0.8622467228875882
 0.8497135649348468
 0.9168739810921809
 0.8952556541312953
 ⋮                 
 0.8991119174319414
 0.8240263775932387
 0.8596740827859989
 0.8684320766925795
 0.9051873743678407
 0.8696121804248323
 0.6892485190656535
 0.8706117630367359
 0.8660131668099659</code></pre><h2 id="It&#39;s-all-about-bounce!-1"><a class="docs-heading-anchor" href="#It&#39;s-all-about-bounce!-1">It&#39;s all about bounce!</a><a class="docs-heading-anchor-permalink" href="#It&#39;s-all-about-bounce!-1" title="Permalink"></a></h2><p>The main propagation algorithm used by <code>DynamicalBilliards</code> is bundled in the following well-behaving function:</p><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.bounce!" href="#DynamicalBilliards.bounce!"><code>DynamicalBilliards.bounce!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bounce!(p::AbstractParticle, bd::Billiard) → i, t, pos, vel</code></pre><p>&quot;Bounce&quot; the particle (advance for one collision) in the billiard. Takes care of finite-precision issues.</p><p>Return:</p><ul><li>index of the obstacle that the particle just collided with</li><li>the time from the previous collision until the current collision <code>t</code></li><li>position and velocity of the particle at the current collision (<em>after</em> the collision has been resolved!). The position is given in the unit cell of periodic billiards. Do <code>pos += p.current_cell</code> for the position in real space.</li></ul><pre><code class="language-julia">bounce!(p, bd, raysplit) → i, t, pos, vel</code></pre><p>Ray-splitting version of <code>bounce!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/d756c1d6f686dfabe749e6c77a04932414e79b0b/src/timeevolution/propagation.jl#L9-L25">source</a></section></article><hr/><p><code>bounce!</code> is the function used internally by all high-level functions, like <a href="#DynamicalBilliards.evolve!"><code>evolve!</code></a>, <a href="../phasespaces/#DynamicalBilliards.boundarymap"><code>boundarymap</code></a>, <a href="#DynamicalBilliards.escapetime"><code>escapetime</code></a>, etc.</p><p>This is the function a user should use if they want to calculate other things besides what is already available in the high level API.</p><h2 id="Standard-Billiards-Library-1"><a class="docs-heading-anchor" href="#Standard-Billiards-Library-1">Standard Billiards Library</a><a class="docs-heading-anchor-permalink" href="#Standard-Billiards-Library-1" title="Permalink"></a></h2><div class="admonition is-success"><header class="admonition-header">You can also use keywords!</header><div class="admonition-body"><p>All standard billiards have a function version that accepts keyword arguments instead of positional arguments, for ease of use.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.billiard_rectangle" href="#DynamicalBilliards.billiard_rectangle"><code>DynamicalBilliards.billiard_rectangle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">billiard_rectangle(x=1.0, y=1.0; setting = &quot;standard&quot;)</code></pre><p>Return a vector of obstacles that defines a rectangle billiard of size (<code>x</code>, <code>y</code>).</p><p><strong>Settings</strong></p><ul><li>&quot;standard&quot; : Specular reflection occurs during collision.</li><li>&quot;periodic&quot; : The walls are <code>PeriodicWall</code> type, enforcing periodicity at the boundaries</li><li>&quot;random&quot; : The velocity is randomized upon collision.</li><li>&quot;ray-splitting&quot; : All obstacles in the billiard allow for ray-splitting.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/d756c1d6f686dfabe749e6c77a04932414e79b0b/src/billiards/standard_billiards.jl#L11-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.billiard_sinai" href="#DynamicalBilliards.billiard_sinai"><code>DynamicalBilliards.billiard_sinai</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">billiard_sinai(r=0.25, x=1.0, y=1.0; setting = &quot;standard&quot;)</code></pre><p>Return a vector of obstacles that defines a Sinai billiard of size (<code>x</code>, <code>y</code>) with a disk in its center, of radius <code>r</code>.</p><p>In the periodic case, the system is also known as &quot;Lorentz Gas&quot;.</p><p><strong>Settings</strong></p><ul><li>&quot;standard&quot; : Specular reflection occurs during collision.</li><li>&quot;periodic&quot; : The walls are <code>PeriodicWall</code> type, enforcing periodicity at the boundaries</li><li>&quot;random&quot; : The velocity is randomized upon collision.</li><li>&quot;ray-splitting&quot; : All obstacles in the billiard allow for ray-splitting.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/d756c1d6f686dfabe749e6c77a04932414e79b0b/src/billiards/standard_billiards.jl#L70-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.billiard_bunimovich" href="#DynamicalBilliards.billiard_bunimovich"><code>DynamicalBilliards.billiard_bunimovich</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">billiard_bunimovich(l=1.0, w=1.0)</code></pre><p>Return a vector of <code>Obstacle</code>s that define a Buminovich billiard, also called a stadium. The length is considered <em>without</em> the attached semicircles, meaning that the full length of the billiard is <code>l + w</code>. The left and right edges of the stadium are <a href="../../tutorials/billiard_table/#DynamicalBilliards.Semicircle"><code>Semicircle</code></a>s.</p><p><code>billiard_stadium</code> is an alias of <code>billiard_bunimovich</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/d756c1d6f686dfabe749e6c77a04932414e79b0b/src/billiards/standard_billiards.jl#L271-L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.billiard_mushroom" href="#DynamicalBilliards.billiard_mushroom"><code>DynamicalBilliards.billiard_mushroom</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">billiard_mushroom(sl = 1.0, sw = 0.2, cr = 1.0, sloc = 0.0; door = true)</code></pre><p>Create a mushroom billiard with stem length <code>sl</code>, stem width <code>sw</code> and cap radius <code>cr</code>. The center of the cap (which is Semicircle) is always at <code>[0, sl]</code>. The center of the stem is located at <code>sloc</code>.</p><p>Optionally, the bottom-most <code>Wall</code> is a <code>Door</code> (see <a href="#DynamicalBilliards.escapetime"><code>escapetime</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/d756c1d6f686dfabe749e6c77a04932414e79b0b/src/billiards/standard_billiards.jl#L234-L241">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.billiard_polygon" href="#DynamicalBilliards.billiard_polygon"><code>DynamicalBilliards.billiard_polygon</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">billiard_polygon(n::Int, R, center = [0,0]; setting = &quot;standard&quot;)</code></pre><p>Return a vector of obstacles that defines a regular-polygonal billiard with <code>n</code> sides, radius <code>r</code> and given <code>center</code>.</p><p>Note: <code>R</code> denotes the so-called outer radius, not the inner one.</p><p><strong>Settings</strong></p><ul><li>&quot;standard&quot; : Specular reflection occurs during collision.</li><li>&quot;periodic&quot; : The walls are <code>PeriodicWall</code> type, enforcing periodicity at the boundaries. Only available for <code>n=4</code> or <code>n=6</code>.</li><li>&quot;random&quot; : The velocity is randomized upon collision.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/d756c1d6f686dfabe749e6c77a04932414e79b0b/src/billiards/standard_billiards.jl#L113-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.billiard_vertices" href="#DynamicalBilliards.billiard_vertices"><code>DynamicalBilliards.billiard_vertices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">billiard_vertices(v, type = FiniteWall)</code></pre><p>Construct a polygon billiard that connects the given vertices <code>v</code> (vector of 2-vectors). The vertices should construct a billiard in a counter-clockwise orientation (i.e. the normal vector always points to the left of <code>v[i+1] - v[i]</code>.).</p><p><code>type</code> decides what kind of walls to use. Ths function assumes that the first entry of <code>v</code> should be connected with the last.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/d756c1d6f686dfabe749e6c77a04932414e79b0b/src/billiards/standard_billiards.jl#L371-L381">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.billiard_iris" href="#DynamicalBilliards.billiard_iris"><code>DynamicalBilliards.billiard_iris</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">billiard_iris(a=0.2, b=0.4, w=1.0; setting = &quot;standard&quot;)</code></pre><p>Return a billiard that is a square of side <code>w</code> enclosing at its center an ellipse with semi axes <code>a</code>, <code>b</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/d756c1d6f686dfabe749e6c77a04932414e79b0b/src/billiards/standard_billiards.jl#L358-L362">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.billiard_hexagonal_sinai" href="#DynamicalBilliards.billiard_hexagonal_sinai"><code>DynamicalBilliards.billiard_hexagonal_sinai</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">billiard_hexagonal_sinai(r, R, center = [0,0]; setting = &quot;standard&quot;)</code></pre><p>Create a sinai-like billiard, which is a hexagon of outer radius <code>R</code>, containing at its center (given by <code>center</code>) a disk of radius <code>r</code>. The <code>setting</code> keyword is passed to <code>billiard_polygon</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/d756c1d6f686dfabe749e6c77a04932414e79b0b/src/billiards/standard_billiards.jl#L179-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.billiard_raysplitting_showcase" href="#DynamicalBilliards.billiard_raysplitting_showcase"><code>DynamicalBilliards.billiard_raysplitting_showcase</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">billiard_raysplitting_showcase(x=2.0, y=1.0, r1=0.3, r2=0.2) -&gt; bd, rayspl</code></pre><p>Showcase example billiard for ray-splitting processes. A rectangle <code>(x,y)</code> with a SplitterWall at <code>x/2</code> and two disks at each side, with respective radii <code>r1</code>, <code>r2</code>.</p><p><strong>Notice</strong>: This function returns a billiard <code>bd</code> as well as a <code>rayspl</code> dictionary!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/d756c1d6f686dfabe749e6c77a04932414e79b0b/src/billiards/standard_billiards.jl#L197-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.billiard_logo" href="#DynamicalBilliards.billiard_logo"><code>DynamicalBilliards.billiard_logo</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">billiard_logo(;h=1.0, α=0.8, r=0.18, off=0.25) -&gt; bd, ray</code></pre><p>Create the billiard used as logo of <code>DynamicalBilliards</code> and return it along with the tuple of raysplitters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/d756c1d6f686dfabe749e6c77a04932414e79b0b/src/billiards/standard_billiards.jl#L294-L298">source</a></section></article><h2 id="Particle-types-1"><a class="docs-heading-anchor" href="#Particle-types-1">Particle types</a><a class="docs-heading-anchor-permalink" href="#Particle-types-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.Particle" href="#DynamicalBilliards.Particle"><code>DynamicalBilliards.Particle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Particle(ic::Vector{T}) #where ic = [x0, y0, φ0]
Particle(x0, y0, φ0)
Particle(pos::SVector, vel::SVector)</code></pre><p>Create a particle with initial conditions <code>x0, y0, φ0</code>. It propagates as a straight line.</p><p>The field <code>current_cell</code> shows at which cell of a periodic billiard is the particle currently located.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/d756c1d6f686dfabe749e6c77a04932414e79b0b/src/billiards/particles.jl#L13-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.MagneticParticle" href="#DynamicalBilliards.MagneticParticle"><code>DynamicalBilliards.MagneticParticle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MagneticParticle(ic::AbstractVector{T}, ω::Real) # where ic = [x0, y0, φ0]
MagneticParticle(x0, y0, φ0, ω)
MagneticParticle(pos::SVector, vel::SVector, ω)
MagneticParticle(p::AbstractParticle, ω)</code></pre><p>Create a <em>magnetic</em> particle with initial conditions <code>x0, y0, φ0</code> and angular velocity <code>ω</code>. It propagates as a circle instead of a line, with radius <code>1/abs(ω)</code>.</p><p>The field <code>current_cell</code> shows at which cell of a periodic billiard is the particle currently located.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/d756c1d6f686dfabe749e6c77a04932414e79b0b/src/billiards/particles.jl#L56-L69">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Introduction</a><a class="docs-footer-nextpage" href="../../visualizing/">Visualizing &amp; Animating »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 14 March 2020 20:49">Saturday 14 March 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
