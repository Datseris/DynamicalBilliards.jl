{
    "docs": [
        {
            "location": "/", 
            "text": "DynamicalBilliards\n is an easy-to-use, modular and extendable Julia package for dynamical billiards in two dimensions.\n\n\n\n\nVersion 2.0 incoming!\n\n\nWe are currently developing 2.0 of \nDynamicalBilliards\n which will bring massive performance increase, a lot of new features and unfortuantelly some breaking changes! You can view the \nchangelog\n to prepare for up coming changes.\n\n\n\n\n\n\nJulia Billiard animation\n\n\nCheck out the example in the \ntutorials\n page to see the code that created and animated the \"Julia Billiard\"!\n\n\n\n\n\n\nIntroduction\n\n\nA dynamical billiard is a system where a particle is propagating as a straight line from obstacle to obstacle, performing specular reflection at the boundary of the obstacles. Billiard systems have been used extensively in mathematics, nonlinear dynamics and chaos and played an important role in the development of nonlinear science.\n\n\nThe \nwikipedia page\n has many examples of different types of billiards. Also, the \nscholarpedia\n entry is a good read on the subject.\n\n\n\n\nFeatures\n\n\n\n\nModular creation of a billiard from well defined obstacles\n\n\nStraight propagation of a particle in a billiard table\n\n\nSupport for creating random initial conditions in an arbitrary billiard table\n\n\nMagnetic propagation, where the particle moves in a circle instead of a straight line (works with \nany\n billiard)\n\n\nRay-splitting implementation: a particle may propagate through an obstacle given arbitrary transmission and refraction laws. This is also known as a \"semiclassical billiard\"\n\n\nComputation of Poincar\u00e9 surfaces of section (also known as boundary maps) for any table and any particle\n\n\nEscape times\n\n\nEasy to use low-level interface\n\n\nFull support for visualizing and animating billiards and motion in billiards\n\n\nBrutal tests that confirm the package works and overcomes numerical precision issues\n\n\n\n\nThis package does not support finite-sized particles and, as a result, there is also no support for collision between particles.\n\n\n\n\n\n\nUsage\n\n\nIt is highly suggested to first read the \nHigh Level API\n.\n\n\nSee the \nVisualizing\n page for plotting, animating, etc.\n\n\nFor more advanced usage see the \nLow Level API\n.\n\n\nThe following tutorials offer detailed descriptions for various aspects of \nDynamicalBilliards\n:\n\n\n\n\nHow to define your custom Billiard\n\n\nUsing Ray-Splitting billiards\n\n\nCreating your own Obstacle Type\n\n\nExamples page\n\n\n\n\nThe discussion about \nnumerical precision\n is done in the \nPhysics\n page.\n\n\nThe \nLyapunov Exponents\n page has info on how to compute the Lyapunov spectrum of a billiard.\n\n\n\n\n\n\nCiting\n\n\nIf you have used this package for research that resulted in a publication, please be kind enough to cite the paper associated with DynamicalBilliards.jl. The DOI is https://doi.org/10.21105/joss.00458 and you can cite as:\n\n\n\n\nG. Datseris, [The Journal of Open Source Software \n2\n, 458\n\n\n\n\n(2017)](https://doi.org/10.21105/joss.00458).\n\n\nor if you use BibTeX:\n\n\n@article{Datseris2017,\n  doi = {10.21105/joss.00458},\n  url = {https://doi.org/10.21105/joss.00458},\n  year  = {2017},\n  month = {nov},\n  volume = {2},\n  number = {19},\n  pages = {458},\n  author = {George Datseris},\n  title = {{DynamicalBilliards}.jl: An easy-to-use,  modular and extendable Julia package for Dynamical Billiard systems in two dimensions.},\n  journal = {The Journal of Open Source Software}\n}\n\n\n\n\n\n\n\nInstallation\n\n\nThis package is registered, simply use \nPkg.add(\"DynamicalBilliards\")\n to install it. The \nstable documentation\n accompanies the version installed with \nPkg.add()\n.\n\n\nPlotting is done through the \nPyPlot\n module. All plotting functions are brought into scope when \nusing PyPlot\n is done. \u2013-\n\n\n\n\n\n\nSupport\n\n\nIf you are having problems with \nDynamicalBilliards.jl\n do not hesitate to seek for support! There are numerous ways to do that:\n\n\n\n\nVisit our \nofficial chatroom\n on Gitter: https://gitter.im/JuliaDynamics/Lobby\n\n\nOpen a new issue at our \nGitHub issues page\n.\n\n\n\n\n\n\n\n\nContributing\n\n\nEveryone is welcomed to contribute to \nDynamicalBilliards.jl\n! If you have some new algorithm, types of Obstacles or anything new to add, do not hesitate! For formal questions about e.g. structuring of code it is best to contact us through the \ngitter chatroom\n or by opening a new Pull Request and asking for a review of your code.\n\n\nIf you would like to help but do not have anything new to contribute, please go ahead and take a look at the \nGitHub issues page\n of the package. Some of the existing issues are easy to solve and are there specifically for people that would like to contribute.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#introduction", 
            "text": "A dynamical billiard is a system where a particle is propagating as a straight line from obstacle to obstacle, performing specular reflection at the boundary of the obstacles. Billiard systems have been used extensively in mathematics, nonlinear dynamics and chaos and played an important role in the development of nonlinear science.  The  wikipedia page  has many examples of different types of billiards. Also, the  scholarpedia  entry is a good read on the subject.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#features", 
            "text": "Modular creation of a billiard from well defined obstacles  Straight propagation of a particle in a billiard table  Support for creating random initial conditions in an arbitrary billiard table  Magnetic propagation, where the particle moves in a circle instead of a straight line (works with  any  billiard)  Ray-splitting implementation: a particle may propagate through an obstacle given arbitrary transmission and refraction laws. This is also known as a \"semiclassical billiard\"  Computation of Poincar\u00e9 surfaces of section (also known as boundary maps) for any table and any particle  Escape times  Easy to use low-level interface  Full support for visualizing and animating billiards and motion in billiards  Brutal tests that confirm the package works and overcomes numerical precision issues   This package does not support finite-sized particles and, as a result, there is also no support for collision between particles.", 
            "title": "Features"
        }, 
        {
            "location": "/#usage", 
            "text": "It is highly suggested to first read the  High Level API .  See the  Visualizing  page for plotting, animating, etc.  For more advanced usage see the  Low Level API .  The following tutorials offer detailed descriptions for various aspects of  DynamicalBilliards :   How to define your custom Billiard  Using Ray-Splitting billiards  Creating your own Obstacle Type  Examples page   The discussion about  numerical precision  is done in the  Physics  page.  The  Lyapunov Exponents  page has info on how to compute the Lyapunov spectrum of a billiard.", 
            "title": "Usage"
        }, 
        {
            "location": "/#citing", 
            "text": "If you have used this package for research that resulted in a publication, please be kind enough to cite the paper associated with DynamicalBilliards.jl. The DOI is https://doi.org/10.21105/joss.00458 and you can cite as:   G. Datseris, [The Journal of Open Source Software  2 , 458   (2017)](https://doi.org/10.21105/joss.00458).  or if you use BibTeX:  @article{Datseris2017,\n  doi = {10.21105/joss.00458},\n  url = {https://doi.org/10.21105/joss.00458},\n  year  = {2017},\n  month = {nov},\n  volume = {2},\n  number = {19},\n  pages = {458},\n  author = {George Datseris},\n  title = {{DynamicalBilliards}.jl: An easy-to-use,  modular and extendable Julia package for Dynamical Billiard systems in two dimensions.},\n  journal = {The Journal of Open Source Software}\n}", 
            "title": "Citing"
        }, 
        {
            "location": "/#installation", 
            "text": "This package is registered, simply use  Pkg.add(\"DynamicalBilliards\")  to install it. The  stable documentation  accompanies the version installed with  Pkg.add() .  Plotting is done through the  PyPlot  module. All plotting functions are brought into scope when  using PyPlot  is done. \u2013-", 
            "title": "Installation"
        }, 
        {
            "location": "/#support", 
            "text": "If you are having problems with  DynamicalBilliards.jl  do not hesitate to seek for support! There are numerous ways to do that:   Visit our  official chatroom  on Gitter: https://gitter.im/JuliaDynamics/Lobby  Open a new issue at our  GitHub issues page .", 
            "title": "Support"
        }, 
        {
            "location": "/#contributing", 
            "text": "Everyone is welcomed to contribute to  DynamicalBilliards.jl ! If you have some new algorithm, types of Obstacles or anything new to add, do not hesitate! For formal questions about e.g. structuring of code it is best to contact us through the  gitter chatroom  or by opening a new Pull Request and asking for a review of your code.  If you would like to help but do not have anything new to contribute, please go ahead and take a look at the  GitHub issues page  of the package. Some of the existing issues are easy to solve and are there specifically for people that would like to contribute.", 
            "title": "Contributing"
        }, 
        {
            "location": "/basic/high_level/", 
            "text": "High Level API\n\n\nDynamicalBilliards\n was created with easy-of-use as its main cornerstone. With 3 simple steps, the user can get the output of the propagation of a particle in a billiard.\n\n\nIn general, the workflow of \nDynamicalBilliards\n follows these simple steps:\n\n\n\n\nCreate a billiard.\n\n\nCreate a particle inside that billiard.\n\n\nGet the output you want by using one of the high level functions.\n\n\n\n\nAdding more complexity in your billiard does not add complexity in your code. For example, to implement a ray-splitting billiard you only need to define one additional variable, a dictionary \nDict{Int, Vector{Function}}\n.\n\n\nAfter reading through this basic usage page, you will be able to use all aspects of \nDynamicalBilliards.jl\n with minimal effort.\n\n\n\n\nVisualizations\n\n\nVisualizing the billiards, particles and their motion is one of the most important parts of the \nDynamicalBilliards\n. It is not discussed in this page however, but rather in the \nVisualizing\n page.\n\n\n\n\n\n\n\n\nBilliard\n\n\nA \nBilliard\n is simply a collection of \nObstacle\n subtypes. Particles are propagating inside a \nBilliard\n, bouncing from obstacle to obstacle while having constant velocity in-between.\n\n\nThere is a \ntutorial\n on how to create your own billiard. In addition, there are many pre-defined billiards that can be found in the \nStandard Billiards Library\n section. That is why knowing how to construct a \nBilliard\n is not important at this point.\n\n\nIn this page we will be using the Bunimovich billiard as an example:\n\n\nusing\n \nDynamicalBilliards\n\n\nbt\n \n=\n \nbilliard_bunimovich\n()\n \n# using default arguments\n\n\n\n\n\n\nBilliard{Float64} with 4 obstacles:\n  Bottom wall\n  Right semicircle\n  Top wall\n  Left semicircle\n\n\n\n\n\n\n\nParticles\n\n\nA \"particle\" is that thingy that moves around in the billiard. It always moves with velocity measure 1, by convention.\n\n\nCurrently there are two types of particles:\n\n\n\n\nParticle\n, which propagates as a straight line.\n\n\nMagneticParticle\n, which propagates as a circle instead of a line (similar to electrons in a perpendicular magnetic field).\n\n\n\n\nThere are two ways to create a particle. The first one is to provide the constructor with some initial conditions:\n\n\nx0\n \n=\n \nrand\n();\n \ny0\n \n=\n \nrand\n();\n\n\n\u03c60\n \n=\n \n2\n\u03c0\n*\nrand\n()\n \n# an angle is enough\n\n\np\n \n=\n \nParticle\n(\nx0\n,\n \ny0\n,\n \n\u03c60\n)\n\n\n\n\n\n\nParticle{Float64}\nposition: [0.324647, 0.142048]\nvelocity: [0.573107, 0.81948]\n\n\n\n\n\nTo create a \nMagneticParticle\n simply provide the constructor with one more number, the angular velocity:\n\n\n\u03c9\n \n=\n \n0.5\n\n\nmp\n \n=\n \nMagneticParticle\n(\nx0\n,\n \ny0\n,\n \n\u03c60\n,\n \n\u03c9\n)\n\n\n\n\n\n\nMagneticParticle{Float64}\nposition: [0.324647, 0.142048]\nvelocity: [0.573107, 0.81948]\nang. velocity: 0.5\n\n\n\n\n\n\n\nWhy the \n{Float64}\n ?\n\n\nWhen creating a billiard or a particle, the object is printed with \n{Float64}\n at the end. This shows what type of numbers are used for \nall\n numerical operations. If you are curious you can learn more about it in the \nnumerical precision page\n.\n\n\n\n\n\n\nParticles must be inside the Billiard!\n\n\nKeep in mind that the particle must be initialized \ninside a billiard\n for any functionality to work properly and make sense. If you are not sure what we mean by that, then you should check out the \nlow-level API page\n.\n\n\n\n\n\n\nRandom initial conditions\n\n\nIf you have a \nBilliard\n which is not a rectangle, creating many random initial conditions inside it can be a pain. Fortunately, the second way to create a particle is to use the following function:\n\n\n#\n\n\nDynamicalBilliards.randominside\n \n \nFunction\n.\n\n\nrandominside(bt::Billiard [, \u03c9])\n\n\n\n\n\nReturn a particle with random allowed initial conditions inside the given billiard. If supplied with a second argument the type of the returned particle is \nMagneticParticle\n, with angular velocity \n\u03c9\n.\n\n\nsource\n\n\n\n\nFor example:\n\n\np\n \n=\n \nrandominside\n(\nbt\n)\n\n\n\n\n\n\nParticle{Float64}\nposition: [0.274096, 0.612643]\nvelocity: [-0.178995, 0.98385]\n\n\n\n\n\nand\n\n\nmp\n \n=\n \nrandominside\n(\nbt\n,\n \n\u03c9\n)\n\n\n\n\n\n\nMagneticParticle{Float64}\nposition: [0.267054, 0.631786]\nvelocity: [-0.500439, -0.865772]\nang. velocity: 0.5\n\n\n\n\n\nrandominside\n always creates particles with same number type as the billiard.\n\n\n\n\nevolve\n \n \nconstruct\n\n\nNow that we have created a billiard and a particle inside, we want to evolve it! There is a simple function for that, called \nevolve!\n (or \nevolve\n if you don't want to mutate the particle):\n\n\n#\n\n\nDynamicalBilliards.evolve!\n \n \nFunction\n.\n\n\nevolve!(p::AbstractParticle, bt::Billiard, t)\n\n\n\n\n\nEvolve the given particle \np\n inside the billiard \nbt\n. If \nt\n is of type \nAbstractFloat\n, evolve for as much time as \nt\n. If however \nt\n is of type \nInt\n, evolve for as many collisions as \nt\n. Return the states of the particle between collisions.\n\n\nThe evolution takes into account the particle's Type. E.g. if \ntypeof(p) \n: MagneticParticle\n then magnetic evolution will take place.\n\n\nThis function mutates the particle, use \nevolve\n otherwise.\n\n\nReturns\n\n\n\n\nct::Vector{T}\n : Collision times.\n\n\nposs::Vector{SVector{2,T}}\n : Positions at the collisions.\n\n\nvels::Vector{SVector{2,T}})\n : Velocities exactly after the collisions.\n\n\n\u03c9\n, either \nT\n or \nVector{T}\n : Angular velocity/ies (returned only for magnetic particles).\n\n\n\n\nUse the function \nconstruct\n to create timeseries of positions and velocities out of these outputs.\n\n\nThe time \nct[i+1]\n is the time necessary to reach state \nposs[i+1], vels[i+1]\n starting from the state \nposs[i], vels[i]\n. That is why \nct[1]\n is always 0 since \nposs[1], vels[1]\n are the initial conditions. The angular velocity \n\u03c9[i]\n is the one the particle has while propagating from state \nposs[i], vels[i]\n to \ni+1\n.\n\n\nNotice that at any point, the velocity vector \nvels[i]\n is the one obtained \nafter\n the specular reflection of the \ni-1\nth collision. The function \nconstruct\n takes that into account.\n\n\nRay-splitting billiards\n\n\nevolve!(p::AbstractParticle, bt, t [, ray_splitter])\n\n\n\n\n\nTo implement ray-splitting, the \nevolve!\n function is supplemented with a fourth argument, \nray_splitter::Dict{Int, Any}\n, which maps integers to some kind of Function container (Tuple or Vector). The functions in this container are: (\u03c6 is the angle of incidence)\n\n\n\n\nT(\u03c6, pflag, \u03c9) : Transmission probability.\n\n\n\u03b8(\u03c6, pflag, \u03c9) : Transmission (aka refraction) angle.\n\n\n\u03c9_new(\u03c9, pflag) : Angular velocity after transmission.\n\n\n\n\nFor more information and instructions on defining these functions please visit the official documentation.\n\n\nsource\n\n\n\n\nForget the ray-splitting part for now, we'll talk a bit more about it later on (see \nRay-Splitting\n).\n\n\nLet's see an example:\n\n\nct\n,\n \nposs\n,\n \nvels\n \n=\n \nevolve\n(\np\n,\n \nbt\n,\n \n100\n)\n\n\nfor\n \ni\n \nin\n \n1\n:\n5\n\n  \nprintln\n(\nround\n(\nct\n[\ni\n],\n \n3\n),\n \n  \n,\n \nposs\n[\ni\n],\n \n  \n,\n \nvels\n[\ni\n])\n\n\nend\n\n\n\n\n\n\n0.0    [0.274096, 0.612643]  [-0.178995, 0.98385]\n0.394  [0.203623, 1.0]  [-0.178995, -0.98385]\n1.016  [0.0216906, 0.0]  [-0.178995, 0.98385]\n0.991  [-0.155718, 0.975134]  [0.438064, -0.898944]\n1.085  [0.319474, 0.0]  [0.438064, 0.898944]\n\n\n\n\n\nSimilarly, for magnetic propagation\n\n\nct\n,\n \nposs\n,\n \nvels\n,\n \n\u03c9\n \n=\n \nevolve\n(\nmp\n,\n \nbt\n,\n \n100\n)\n\n\nfor\n \ni\n \nin\n \n1\n:\n10\n\n  \nprintln\n(\nround\n(\nct\n[\ni\n],\n \n3\n),\n \n  \n,\n \nposs\n[\ni\n],\n \n  \n,\n \nvels\n[\ni\n])\n\n\nend\n\n\n\n\n\n\n0.0    [0.267054, 0.631786]  [-0.500439, -0.865772]\n0.677  [0.0329496, 2.94431e-13]  [-0.184546, 0.982824]\n0.947  [-0.351508, 0.855587]  [0.783478, -0.621419]\n1.959  [1.4997, 0.517318]  [-0.971386, 0.237507]\n1.905  [-0.283005, 0.0878011]  [0.338364, 0.941015]\n\n\n\n\n\nThe above return types are helpful in some applications. In other applications however one prefers to have the time series of the individual variables. For this, the \nconstruct\n function is used:\n\n\n#\n\n\nDynamicalBilliards.construct\n \n \nFunction\n.\n\n\nconstruct(ct, poss, vels [, \u03c9 [, dt=0.01]]) -\n xt, yt, vxt, vyt, t\n\n\n\n\n\nGiven the output of \nevolve!\n, construct the timeseries of the position and velocity, as well as the time vector.\n\n\nIn case of not given \n\u03c9\n (or \n\u03c9 == 0\n), straight construction takes place. In case of \n\u03c9 != 0\n or \n\u03c9::Vector\n magnetic construction takes place.\n\n\nThe additional optional argument of \ndt\n (only valid for Magnetic construction) is the timestep with which the timeseries are constructed.\n\n\nReturn:\n\n\n\n\nx position time-series\n\n\ny position time-series\n\n\nx velocity time-series\n\n\ny velocity time-series\n\n\ntime vector\n\n\n\n\nsource\n\n\n\n\nThe function is especially useful when one wants immediately the timeseries instead of the output of \nevolve!\n. Because of the simple syntax\n\n\nxt\n,\n \nyt\n,\n \nvxt\n,\n \nvyt\n,\n \nt\n \n=\n \nconstruct\n(\nevolve\n(\np\n,\n \nbt\n,\n \n100\n)\n...\n)\n\n\n\n# print as a matrix:\n\n\nhcat\n(\nxt\n,\n \nyt\n,\n \nvxt\n,\n \nvyt\n,\n \nt\n)[\n1\n:\n5\n,\n \n:\n]\n\n\n\n\n\n\n5\u00d75 Array{Float64,2}:\n  0.274096   0.612643  -0.178995   0.98385   0.0     \n  0.203623   1.0       -0.178995  -0.98385   0.393715\n  0.0216906  0.0       -0.178995   0.98385   1.41013\n -0.155718   0.975134   0.438064  -0.898944  2.40127\n  0.319474   0.0        0.438064   0.898944  3.48603\n\n\n\n\n\nThis nicely reveals why in the case of magnetic propagation \nevolve!\n also returns the angular velocity. So that it is possible to do the same process for magnetic propagation as well (plus, it is also useful in ray-splitting).\n\n\n# evolve the magnetic particle instead:\n\n\nxt\n,\n \nyt\n,\n \nvxt\n,\n \nvyt\n,\n \nt\n \n=\n \nconstruct\n(\nevolve\n(\nmp\n,\n \nbt\n,\n \n100\n)\n...\n)\n\n\n\n# print as a matrix:\n\n\nhcat\n(\nxt\n,\n \nyt\n,\n \nvxt\n,\n \nvyt\n,\n \nt\n)[\n1\n:\n5\n,\n \n:\n]\n\n\n\n\n\n\n5\u00d75 Array{Float64,2}:\n 0.267054  0.631786  -0.500439  -0.865772  0.0\n 0.262071  0.623116  -0.496104  -0.868263  0.01\n 0.257132  0.614421  -0.491756  -0.870733  0.02\n 0.252236  0.605701  -0.487397  -0.873181  0.03\n 0.247384  0.596957  -0.483025  -0.875607  0.04\n\n\n\n\n\n\n\nType of \nt\n\n\nRemember that the behavior of \nevolve!\n depends on the type of the third argument, which represents \"total amount\". If it is \nAbstractFloat\n, it represents total amount of time, but if it is \nInt\n it represents total number of collisions.\n\n\n\n\n\n\nBoundary Maps\n\n\nBoundary maps can be obtained with the high level function\n\n\n#\n\n\nDynamicalBilliards.boundarymap\n \n \nFunction\n.\n\n\nboundarymap(bt::Billiard, t, particles)\n\n\n\n\n\nCompute the boundary map of the billiard \nbt\n by evolving each particle for total amount \nt\n (either float for time or integer for collision number). See below for the returned values.\n\n\nparticles\n can be:\n\n\n\n\nA single particle.\n\n\nA \nVector\n of particles.\n\n\nAn integer \nn\n optionally followed by an angular velocity \n\u03c9\n.\n\n\n\n\nIn the last case \nn\n random particles are produced in the billiard table using \nrandominside\n. If \n\u03c9\n is also given, then the particles are magnetic.\n\n\nThe measurement direction of the arclengths of the individual obstacles is dictated by \nbt\n, see \nBilliard\n for more.\n\n\nReturn\n\n\n\n\nthe arclengths at the collisions \n\u03bes\n\n\nthe incidence angles at the collisions \n\u03c6s\n\n\nobstacle arclength \nintervals\n\n\n\n\nIf \nparticles\n is not a single particle then both \n\u03bes\n and \n\u03c6s\n are vectors of \nVector\n. The \ni\n inner vector corresponds to the results of the \ni\n initial condition/particle.\n\n\nsource\n\n\n\n\nFor example, take a look at boundary maps of the mushroom billiard, which is known to have a mixed phase space:\n\n\nusing\n \nDynamicalBilliards\n\n\n\nbt\n \n=\n \nbilliard_mushroom\n()\n\n\n\nn\n \n=\n \n100\n \n# how many particles to create\n\n\n\n\u03be\u03c2\n,\n \n\u03c6\u03c2\n,\n \n\u03b9\u03c2\n \n=\n \nboundarymap\n(\nbt\n,\n \n10000\n,\n \nn\n)\n\n\n\nusing\n \nPyPlot\n \n# enables plot_boundarymap function\n\n\n\ncolors\n \n=\n \n[\nC\n$\n(\nrand\n(\n1\n:\n9\n))\n \nfor\n \ni\n \nin\n \n1\n:\nn\n]\n \n# random colors\n\n\n\nfigure\n()\n\n\nplot_boundarymap\n(\n\u03be\u03c2\n,\n \n\u03c6\u03c2\n,\n \n\u03b9\u03c2\n,\n \ncolor\n \n=\n \ncolors\n)\n\n\n\n\n\n\n\n\nAnd of course similarly for magnetic fields\n\n\n\u03be\u03c2\n,\n \n\u03c6\u03c2\n,\n \n\u03b9\u03c2\n \n=\n \nboundarymap\n(\nbt\n,\n \n10000\n,\n \nn\n,\n \n1.0\n)\n \n# angular velocity last argument\n\n\nfigure\n()\n\n\nplot_boundarymap\n(\n\u03be\u03c2\n,\n \n\u03c6\u03c2\n,\n \n\u03b9\u03c2\n,\n \ncolor\n \n=\n \ncolors\n)\n\n\n\n\n\n\n\n\n\n\nPoincar\u00e9 Sections\n\n\n#\n\n\nDynamicalBilliards.psos\n \n \nFunction\n.\n\n\npsos(bt::Billiard, plane::InfiniteWall, t, particles)\n\n\n\n\n\nCompute the Poincar\u00e9 section of the \nparticles\n with the given \nplane\n, by evolving each one for time \nt\n (either integer or float) inside \nbt\n.\n\n\nThe \nplane\n can be an \nInfiniteWall\n of \nany\n orientation, however only crossings of the \nplane\n such that \ndot(velocity, normal) \n 0\n are allowed, with \nnormal\n the normal unit vector of the \nplane\n.\n\n\nparticles\n can be:\n\n\n\n\nA single particle.\n\n\nA \nVector\n of particles.\n\n\nAn integer \nn\n optionally followed by an angular velocity \n\u03c9\n.\n\n\n\n\nReturn the positions \nposs\n and velocities \nvels\n at the instances of crossing the \nplane\n. If given more than one particle, the result is a vector of vectors of vectors.\n\n\nsource\n\n\n\n\nFor example, the surface of section in the periodic Sinai billiard with magnetic field reveals the mixed nature of the phase-space:\n\n\nusing\n \nDynamicalBilliards\n,\n \nPyPlot\n\n\nt\n \n=\n \n100\n;\n \nr\n \n=\n \n0.15\n\n\nbt\n \n=\n \nbilliard_sinai\n(\nr\n,\n \nsetting\n \n=\n \nperiodic\n)\n\n\n\n# the direction of the normal vector is IMPORTANT!!!\n\n\n# (always keep in mind that \u03c9 \n 0  means counter-clockwise rotation!)\n\n\nplane\n \n=\n \nInfiniteWall\n([\n0.5\n,\n \n0.0\n],\n \n[\n0.5\n,\n \n1.0\n],\n \n[\n-\n1.0\n,\n \n0.0\n])\n\n\n\nposvector\n,\n \nvelvector\n \n=\n \npsos\n(\nbt\n,\n \nplane\n,\n \nt\n,\n \n10000\n,\n \n2.0\n)\n\n\n\nfor\n \ni\n \nin\n \n1\n:\nlength\n(\nposvector\n)\n\n    \nposs\n \n=\n \nposvector\n[\ni\n]\n \n# vector of positions\n\n    \nvels\n \n=\n \nvelvector\n[\ni\n]\n \n# vector of velocities at the section\n\n    \nL\n \n=\n \nlength\n(\nposs\n)\n\n    \nif\n \nL\n \n \n0\n\n        \n#plot y vs vy\n\n        \ny\n \n=\n \n[\na\n[\n2\n]\n \nfor\n \na\n \nin\n \nposs\n]\n\n        \nvy\n \n=\n \n[\na\n[\n2\n]\n \nfor\n \na\n \nin\n \nvels\n]\n\n        \n# Make results of pinned orbits have only one entry (for plotting speed):\n\n        \ny\n \n=\n \nunique\n(\nround\n.\n(\ny\n,\n \n4\n))\n\n        \nvy\n \n=\n \nunique\n(\nround\n.\n(\nvy\n,\n \n4\n))\n\n        \n# color pinned orbits differently:\n\n        \ncol\n \n=\n \nlength\n(\ny\n)\n \n==\n \n1\n \n?\n \nC1\n \n:\n \nC0\n\n        \nplot\n(\ny\n,\n \nvy\n,\n \nls\n \n=\n \nNone\n,\n \ncolor\n \n=\n \ncol\n,\n \nms\n \n=\n \n1.0\n,\n \nalpha\n \n=\n \n0.5\n,\n \nmarker\n \n=\n \no\n)\n\n    \nend\n\n\nend\n\n\nxlabel\n(\n\\$\ny\n\\$\n);\n \nylabel\n(\n\\$\nv_y\n\\$\n)\n\n\n\n\n\n\n\n\n\n\npsos\n operates on the unit cell\n\n\nThe \npsos\n function always calculates the crossings \nwithin\n the unit cell of a periodic billiard. This means that no information about the \"actual\" position of the particle is stored, everything is modulo the unit cell.\n\n\nThis can be seen very well in the above example, where there aren't any entries in the region \n0.5 - r \u2264 y \u2264 0.5 + r\n.\n\n\n\n\nOf course it is very easy to \"re-normalize\" the result such that it is coherent. The only change we have to do is simply replace the line \ny = [a[2] for a in poss]\n with\n\n\ny\n \n=\n \n[\na\n[\n2\n]\n \n \n0.5\n \n?\n \na\n[\n2\n]\n \n+\n \n1\n \n:\n \na\n[\n2\n]\n  \nfor\n \na\n \nin\n \nposs\n]\n\n\n\n\n\n\nwhich gives \n\n\n\n\nEscape Times\n\n\nIt is very easy to create your own function that calculates an \"escape time\": the time until the particle leaves the billiard by meeting a specified condition. There is also a high-level function for this though:\n\n\n#\n\n\nDynamicalBilliards.escapetime\n \n \nFunction\n.\n\n\nescapetime(p, bt, maxiter; warning = false)\n\n\n\n\n\nCalculate the escape time of a particle \np\n in the billiard \nbt\n, which is the time until colliding with any \"door\" in \nbt\n. As a \"door\" is considered any \nFiniteWall\n with field \nisdoor = true\n.\n\n\nIf the particle performs more than \nmaxiter\n collisions without colliding with the \nDoor\n (i.e. escaping) the returned result is \nInf\n.\n\n\nA warning can be thrown if the result is \nInf\n. Enable this using the keyword \nwarning = true\n.\n\n\nsource\n\n\n\n\nCreating a door\n\n\nTo create a \"door\" simply visit the \nlibrary page\n to learn more about the individual obstacle types (specifically \nFiniteWall\n). To be able to combine them into a \nBilliard\n you should also check out the tutorial on \ndefining your own billiard\n.\n\n\n\n\nFor example, the default implementation of the mushroom billiard has a \"door\" at the bottom of the stem. Thus,\n\n\nbt\n \n=\n \nbilliard_mushroom\n()\n\n\net\n \n=\n \nzeros\n(\n100\n)\n\n\nfor\n \ni\n \n\u2208\n \n1\n:\n100\n\n    \np\n \n=\n \nrandominside\n(\nbt\n)\n\n    \net\n[\ni\n]\n \n=\n \nescapetime\n(\np\n,\n \nbt\n,\n \n10000\n)\n\n\nend\n\n\nprintln\n(\nOut of 100 particles, \n$\n(\ncount\n(\nx\n-\n \nx\n \n!=\n \nInf\n,\n \net\n))\n escaped\n)\n\n\nprintln\n(\nMean escape time was \n$\n(\nmean\n(\net\n[\net\n \n.!=\n \nInf\n]))\n)\n\n\n\n\n\n\nOut of 100 particles, 11 escaped\nMean escape time was 4.436943929428599\n\n\n\n\n\nOf course, \nescapetime\n works with \nMagneticParticle\n as well\n\n\nescapetime\n(\nrandominside\n(\nbt\n,\n \n1.0\n),\n \nbt\n,\n \n10000\n)\n\n\n\n\n\n\n87.17643414941281\n\n\n\n\n\n\n\nRay-Splitting\n\n\nDuring ray-splitting a particle may propagate through an obstacle given arbitrary transmission and refraction laws. This is also known as a \"semiclassical billiard\".\n\n\nNo matter how complex ray-splitting processes you want, and irrespectively of how many obstacles in the billiard table can perform ray-splitting, there is only a single difference on the main function call: The \nevolve!()\n function is supplemented with a fourth argument:\n\n\nray_splitter\n::\nDict\n{\nInt\n,\n \nAny\n}\n\n\n\n\n\n\nThis argument is simply a dictionary which handles all ray-splitting processes in the billiard system.\n\n\nGiven an obstacle index within the billiard table it returns a container of the ray-splitting functions: (\u03c6 is the angle of incidence)\n\n\n\n\nT(\u03c6, pflag, \u03c9) : Transmission probability.\n\n\n\u03b8(\u03c6, pflag, \u03c9) : Transmission (aka diffraction) angle.\n\n\nnew_\u03c9(\u03c9, pflag) : Angular velocity after transmission.\n\n\n\n\nAssuming you have defined a billiard table and a ray-splitter dictionary, the implementation is exactly the same as in the two previous cases: the ray-splitting dictionary is passed to \nevolve!()\n as a fourth argument.\n\n\nray_splitter\n \n=\n \nDict\n(\n5\n \n=\n \n(\nfoo\n,\n \nbar\n,\n \nbaz\n))\n\n\np\n \n=\n \nrandominside\n(\nbt\n,\n \n4.0\n)\n\n\nxt\n,\n \nyt\n,\n \nvxt\n,\n \nvyt\n,\n \nts\n \n=\n \nconstruct\n(\nevolve!\n(\np\n,\n \nbt\n,\n \n100.0\n,\n \nray_splitter\n)\n...\n,\n \n0.01\n)\n\n\n\n\n\n\nFor more information and instructions on defining the \nray_splitter\n dictionary visit the \nRay-Splitting tutorial\n.\n\n\n\n\nStandard Billiards Library\n\n\n#\n\n\nDynamicalBilliards.billiard_rectangle\n \n \nFunction\n.\n\n\nbilliard_rectangle\n(\nx\n=\n1.0\n,\n \ny\n=\n1.0\n;\n \nsetting\n \n=\n \nstandard\n)\n\n\n\n\n\n\nReturn a vector of obstacles that defines a rectangle billiard of size (\nx\n, \ny\n).\n\n\nSettings\n\n\n\n\n\"standard\" : Specular reflection occurs during collision.\n\n\n\"periodic\" : The walls are \nPeriodicWall\n type, enforcing periodicity at the boundaries\n\n\n\"random\" : The velocity is randomized upon collision.\n\n\n\"ray-splitting\" : All obstacles in the billiard allow for ray-splitting.\n\n\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.billiard_sinai\n \n \nFunction\n.\n\n\nbilliard_sinai\n(\nr\n=\n0.25\n,\n \nx\n=\n1.0\n,\n \ny\n=\n1.0\n;\n \nsetting\n \n=\n \nstandard\n)\n\n\n\n\n\n\nReturn a vector of obstacles that defines a Sinai billiard of size (\nx\n, \ny\n) with a disk in its center, of radius \nr\n.\n\n\nIn the periodic case, the system is also known as \"Lorentz Gas\".\n\n\nSettings\n\n\n\n\n\"standard\" : Specular reflection occurs during collision.\n\n\n\"periodic\" : The walls are \nPeriodicWall\n type, enforcing periodicity at the boundaries\n\n\n\"random\" : The velocity is randomized upon collision.\n\n\n\"ray-splitting\" : All obstacles in the billiard allow for ray-splitting.\n\n\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.billiard_bunimovich\n \n \nFunction\n.\n\n\nbilliard_bunimovich(l=1.0, w=1.0)\n\n\n\n\n\nReturn a vector of \nObstacle\ns that define a Buminovich billiard, also called a stadium. The length is considered \nwithout\n the attached semicircles, meaning that the full length of the billiard is \nl + w\n. The left and right edges of the stadium are \nSemicircle\ns.\n\n\nbilliard_stadium\n is an alias of \nbilliard_bunimovich\n.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.billiard_mushroom\n \n \nFunction\n.\n\n\nbilliard_mushroom(stem_length = 1.0, stem_width=0.2, cap_radious=1.0,\nstem_location = 0.0)\n\n\n\n\n\nCreate a mushroom billiard. The center of the cap (which is Semicircle) is always at [0, stem_length]. The bottom-most \nWall\n is a \nDoor\n (see \nescapetime\n).\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.billiard_lorentz\n \n \nFunction\n.\n\n\nbilliard_lorentz(r=0.25, x=1.0, y=1.0)\n\n\n\n\n\nAlias for \nbilliard_sinai(r,x,y; setting = \"periodic\")\n.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.billiard_polygon\n \n \nFunction\n.\n\n\nbilliard_polygon\n(\nn\n::\nInt\n,\n \nR\n,\n \ncenter\n \n=\n \n[\n0\n,\n0\n]\n;\n \nsetting\n \n=\n \nstandard\n)\n\n\n\n\n\n\nReturn a vector of obstacles that defines a regular-polygonal billiard with \nn\n sides, radius \nr\n and given \ncenter\n.\n\n\nNote: \nR\n denotes the so-called outer radius, not the inner one.\n\n\nSettings\n\n\n\n\n\"standard\" : Specular reflection occurs during collision.\n\n\n\"periodic\" : The walls are \nPeriodicWall\n type, enforcing periodicity at the boundaries. Only available for \nn=4\n or \nn=6\n.\n\n\n\"random\" : The velocity is randomized upon collision.\n\n\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.billiard_hexagonal_sinai\n \n \nFunction\n.\n\n\nbilliard_hexagonal_sinai(r, R, center = [0,0]; setting = \nstandard\n)\n\n\n\n\n\nCreate a sinai-like billiard, which is a hexagon of outer radius \nR\n, containing at its center (given by \ncenter\n) a disk of radius \nr\n. The \nsetting\n keyword is passed to \nbilliard_polygon\n.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.billiard_raysplitting_showcase\n \n \nFunction\n.\n\n\nbilliard_raysplitting_showcase(x=2.0, y=1.0, r1=0.3, r2=0.2) -\n bt, rayspl\n\n\n\n\n\nShowcase example billiard for ray-splitting processes. A rectangle \n(x,y)\n with a SplitterWall at \nx/2\n and two disks at each side, with respective radii \nr1\n, \nr2\n.\n\n\nNotice\n: This function returns a billiard \nbt\n as well as a \nrayspl\n dictionary!\n\n\nsource", 
            "title": "High Level API"
        }, 
        {
            "location": "/basic/high_level/#high-level-api", 
            "text": "DynamicalBilliards  was created with easy-of-use as its main cornerstone. With 3 simple steps, the user can get the output of the propagation of a particle in a billiard.  In general, the workflow of  DynamicalBilliards  follows these simple steps:   Create a billiard.  Create a particle inside that billiard.  Get the output you want by using one of the high level functions.   Adding more complexity in your billiard does not add complexity in your code. For example, to implement a ray-splitting billiard you only need to define one additional variable, a dictionary  Dict{Int, Vector{Function}} .  After reading through this basic usage page, you will be able to use all aspects of  DynamicalBilliards.jl  with minimal effort.   Visualizations  Visualizing the billiards, particles and their motion is one of the most important parts of the  DynamicalBilliards . It is not discussed in this page however, but rather in the  Visualizing  page.", 
            "title": "High Level API"
        }, 
        {
            "location": "/basic/high_level/#billiard", 
            "text": "A  Billiard  is simply a collection of  Obstacle  subtypes. Particles are propagating inside a  Billiard , bouncing from obstacle to obstacle while having constant velocity in-between.  There is a  tutorial  on how to create your own billiard. In addition, there are many pre-defined billiards that can be found in the  Standard Billiards Library  section. That is why knowing how to construct a  Billiard  is not important at this point.  In this page we will be using the Bunimovich billiard as an example:  using   DynamicalBilliards  bt   =   billiard_bunimovich ()   # using default arguments   Billiard{Float64} with 4 obstacles:\n  Bottom wall\n  Right semicircle\n  Top wall\n  Left semicircle", 
            "title": "Billiard"
        }, 
        {
            "location": "/basic/high_level/#particles", 
            "text": "A \"particle\" is that thingy that moves around in the billiard. It always moves with velocity measure 1, by convention.  Currently there are two types of particles:   Particle , which propagates as a straight line.  MagneticParticle , which propagates as a circle instead of a line (similar to electrons in a perpendicular magnetic field).   There are two ways to create a particle. The first one is to provide the constructor with some initial conditions:  x0   =   rand ();   y0   =   rand ();  \u03c60   =   2 \u03c0 * rand ()   # an angle is enough  p   =   Particle ( x0 ,   y0 ,   \u03c60 )   Particle{Float64}\nposition: [0.324647, 0.142048]\nvelocity: [0.573107, 0.81948]  To create a  MagneticParticle  simply provide the constructor with one more number, the angular velocity:  \u03c9   =   0.5  mp   =   MagneticParticle ( x0 ,   y0 ,   \u03c60 ,   \u03c9 )   MagneticParticle{Float64}\nposition: [0.324647, 0.142048]\nvelocity: [0.573107, 0.81948]\nang. velocity: 0.5   Why the  {Float64}  ?  When creating a billiard or a particle, the object is printed with  {Float64}  at the end. This shows what type of numbers are used for  all  numerical operations. If you are curious you can learn more about it in the  numerical precision page .    Particles must be inside the Billiard!  Keep in mind that the particle must be initialized  inside a billiard  for any functionality to work properly and make sense. If you are not sure what we mean by that, then you should check out the  low-level API page .", 
            "title": "Particles"
        }, 
        {
            "location": "/basic/high_level/#random-initial-conditions", 
            "text": "If you have a  Billiard  which is not a rectangle, creating many random initial conditions inside it can be a pain. Fortunately, the second way to create a particle is to use the following function:  #  DynamicalBilliards.randominside     Function .  randominside(bt::Billiard [, \u03c9])  Return a particle with random allowed initial conditions inside the given billiard. If supplied with a second argument the type of the returned particle is  MagneticParticle , with angular velocity  \u03c9 .  source   For example:  p   =   randominside ( bt )   Particle{Float64}\nposition: [0.274096, 0.612643]\nvelocity: [-0.178995, 0.98385]  and  mp   =   randominside ( bt ,   \u03c9 )   MagneticParticle{Float64}\nposition: [0.267054, 0.631786]\nvelocity: [-0.500439, -0.865772]\nang. velocity: 0.5  randominside  always creates particles with same number type as the billiard.", 
            "title": "Random initial conditions"
        }, 
        {
            "location": "/basic/high_level/#evolve-construct", 
            "text": "Now that we have created a billiard and a particle inside, we want to evolve it! There is a simple function for that, called  evolve!  (or  evolve  if you don't want to mutate the particle):  #  DynamicalBilliards.evolve!     Function .  evolve!(p::AbstractParticle, bt::Billiard, t)  Evolve the given particle  p  inside the billiard  bt . If  t  is of type  AbstractFloat , evolve for as much time as  t . If however  t  is of type  Int , evolve for as many collisions as  t . Return the states of the particle between collisions.  The evolution takes into account the particle's Type. E.g. if  typeof(p)  : MagneticParticle  then magnetic evolution will take place.  This function mutates the particle, use  evolve  otherwise.  Returns   ct::Vector{T}  : Collision times.  poss::Vector{SVector{2,T}}  : Positions at the collisions.  vels::Vector{SVector{2,T}})  : Velocities exactly after the collisions.  \u03c9 , either  T  or  Vector{T}  : Angular velocity/ies (returned only for magnetic particles).   Use the function  construct  to create timeseries of positions and velocities out of these outputs.  The time  ct[i+1]  is the time necessary to reach state  poss[i+1], vels[i+1]  starting from the state  poss[i], vels[i] . That is why  ct[1]  is always 0 since  poss[1], vels[1]  are the initial conditions. The angular velocity  \u03c9[i]  is the one the particle has while propagating from state  poss[i], vels[i]  to  i+1 .  Notice that at any point, the velocity vector  vels[i]  is the one obtained  after  the specular reflection of the  i-1 th collision. The function  construct  takes that into account.  Ray-splitting billiards  evolve!(p::AbstractParticle, bt, t [, ray_splitter])  To implement ray-splitting, the  evolve!  function is supplemented with a fourth argument,  ray_splitter::Dict{Int, Any} , which maps integers to some kind of Function container (Tuple or Vector). The functions in this container are: (\u03c6 is the angle of incidence)   T(\u03c6, pflag, \u03c9) : Transmission probability.  \u03b8(\u03c6, pflag, \u03c9) : Transmission (aka refraction) angle.  \u03c9_new(\u03c9, pflag) : Angular velocity after transmission.   For more information and instructions on defining these functions please visit the official documentation.  source   Forget the ray-splitting part for now, we'll talk a bit more about it later on (see  Ray-Splitting ).  Let's see an example:  ct ,   poss ,   vels   =   evolve ( p ,   bt ,   100 )  for   i   in   1 : 5 \n   println ( round ( ct [ i ],   3 ),      ,   poss [ i ],      ,   vels [ i ])  end   0.0    [0.274096, 0.612643]  [-0.178995, 0.98385]\n0.394  [0.203623, 1.0]  [-0.178995, -0.98385]\n1.016  [0.0216906, 0.0]  [-0.178995, 0.98385]\n0.991  [-0.155718, 0.975134]  [0.438064, -0.898944]\n1.085  [0.319474, 0.0]  [0.438064, 0.898944]  Similarly, for magnetic propagation  ct ,   poss ,   vels ,   \u03c9   =   evolve ( mp ,   bt ,   100 )  for   i   in   1 : 10 \n   println ( round ( ct [ i ],   3 ),      ,   poss [ i ],      ,   vels [ i ])  end   0.0    [0.267054, 0.631786]  [-0.500439, -0.865772]\n0.677  [0.0329496, 2.94431e-13]  [-0.184546, 0.982824]\n0.947  [-0.351508, 0.855587]  [0.783478, -0.621419]\n1.959  [1.4997, 0.517318]  [-0.971386, 0.237507]\n1.905  [-0.283005, 0.0878011]  [0.338364, 0.941015]  The above return types are helpful in some applications. In other applications however one prefers to have the time series of the individual variables. For this, the  construct  function is used:  #  DynamicalBilliards.construct     Function .  construct(ct, poss, vels [, \u03c9 [, dt=0.01]]) -  xt, yt, vxt, vyt, t  Given the output of  evolve! , construct the timeseries of the position and velocity, as well as the time vector.  In case of not given  \u03c9  (or  \u03c9 == 0 ), straight construction takes place. In case of  \u03c9 != 0  or  \u03c9::Vector  magnetic construction takes place.  The additional optional argument of  dt  (only valid for Magnetic construction) is the timestep with which the timeseries are constructed.  Return:   x position time-series  y position time-series  x velocity time-series  y velocity time-series  time vector   source   The function is especially useful when one wants immediately the timeseries instead of the output of  evolve! . Because of the simple syntax  xt ,   yt ,   vxt ,   vyt ,   t   =   construct ( evolve ( p ,   bt ,   100 ) ... )  # print as a matrix:  hcat ( xt ,   yt ,   vxt ,   vyt ,   t )[ 1 : 5 ,   : ]   5\u00d75 Array{Float64,2}:\n  0.274096   0.612643  -0.178995   0.98385   0.0     \n  0.203623   1.0       -0.178995  -0.98385   0.393715\n  0.0216906  0.0       -0.178995   0.98385   1.41013\n -0.155718   0.975134   0.438064  -0.898944  2.40127\n  0.319474   0.0        0.438064   0.898944  3.48603  This nicely reveals why in the case of magnetic propagation  evolve!  also returns the angular velocity. So that it is possible to do the same process for magnetic propagation as well (plus, it is also useful in ray-splitting).  # evolve the magnetic particle instead:  xt ,   yt ,   vxt ,   vyt ,   t   =   construct ( evolve ( mp ,   bt ,   100 ) ... )  # print as a matrix:  hcat ( xt ,   yt ,   vxt ,   vyt ,   t )[ 1 : 5 ,   : ]   5\u00d75 Array{Float64,2}:\n 0.267054  0.631786  -0.500439  -0.865772  0.0\n 0.262071  0.623116  -0.496104  -0.868263  0.01\n 0.257132  0.614421  -0.491756  -0.870733  0.02\n 0.252236  0.605701  -0.487397  -0.873181  0.03\n 0.247384  0.596957  -0.483025  -0.875607  0.04   Type of  t  Remember that the behavior of  evolve!  depends on the type of the third argument, which represents \"total amount\". If it is  AbstractFloat , it represents total amount of time, but if it is  Int  it represents total number of collisions.", 
            "title": "evolve &amp; construct"
        }, 
        {
            "location": "/basic/high_level/#boundary-maps", 
            "text": "Boundary maps can be obtained with the high level function  #  DynamicalBilliards.boundarymap     Function .  boundarymap(bt::Billiard, t, particles)  Compute the boundary map of the billiard  bt  by evolving each particle for total amount  t  (either float for time or integer for collision number). See below for the returned values.  particles  can be:   A single particle.  A  Vector  of particles.  An integer  n  optionally followed by an angular velocity  \u03c9 .   In the last case  n  random particles are produced in the billiard table using  randominside . If  \u03c9  is also given, then the particles are magnetic.  The measurement direction of the arclengths of the individual obstacles is dictated by  bt , see  Billiard  for more.  Return   the arclengths at the collisions  \u03bes  the incidence angles at the collisions  \u03c6s  obstacle arclength  intervals   If  particles  is not a single particle then both  \u03bes  and  \u03c6s  are vectors of  Vector . The  i  inner vector corresponds to the results of the  i  initial condition/particle.  source   For example, take a look at boundary maps of the mushroom billiard, which is known to have a mixed phase space:  using   DynamicalBilliards  bt   =   billiard_mushroom ()  n   =   100   # how many particles to create  \u03be\u03c2 ,   \u03c6\u03c2 ,   \u03b9\u03c2   =   boundarymap ( bt ,   10000 ,   n )  using   PyPlot   # enables plot_boundarymap function  colors   =   [ C $ ( rand ( 1 : 9 ))   for   i   in   1 : n ]   # random colors  figure ()  plot_boundarymap ( \u03be\u03c2 ,   \u03c6\u03c2 ,   \u03b9\u03c2 ,   color   =   colors )    And of course similarly for magnetic fields  \u03be\u03c2 ,   \u03c6\u03c2 ,   \u03b9\u03c2   =   boundarymap ( bt ,   10000 ,   n ,   1.0 )   # angular velocity last argument  figure ()  plot_boundarymap ( \u03be\u03c2 ,   \u03c6\u03c2 ,   \u03b9\u03c2 ,   color   =   colors )", 
            "title": "Boundary Maps"
        }, 
        {
            "location": "/basic/high_level/#poincare-sections", 
            "text": "#  DynamicalBilliards.psos     Function .  psos(bt::Billiard, plane::InfiniteWall, t, particles)  Compute the Poincar\u00e9 section of the  particles  with the given  plane , by evolving each one for time  t  (either integer or float) inside  bt .  The  plane  can be an  InfiniteWall  of  any  orientation, however only crossings of the  plane  such that  dot(velocity, normal)   0  are allowed, with  normal  the normal unit vector of the  plane .  particles  can be:   A single particle.  A  Vector  of particles.  An integer  n  optionally followed by an angular velocity  \u03c9 .   Return the positions  poss  and velocities  vels  at the instances of crossing the  plane . If given more than one particle, the result is a vector of vectors of vectors.  source   For example, the surface of section in the periodic Sinai billiard with magnetic field reveals the mixed nature of the phase-space:  using   DynamicalBilliards ,   PyPlot  t   =   100 ;   r   =   0.15  bt   =   billiard_sinai ( r ,   setting   =   periodic )  # the direction of the normal vector is IMPORTANT!!!  # (always keep in mind that \u03c9   0  means counter-clockwise rotation!)  plane   =   InfiniteWall ([ 0.5 ,   0.0 ],   [ 0.5 ,   1.0 ],   [ - 1.0 ,   0.0 ])  posvector ,   velvector   =   psos ( bt ,   plane ,   t ,   10000 ,   2.0 )  for   i   in   1 : length ( posvector ) \n     poss   =   posvector [ i ]   # vector of positions \n     vels   =   velvector [ i ]   # vector of velocities at the section \n     L   =   length ( poss ) \n     if   L     0 \n         #plot y vs vy \n         y   =   [ a [ 2 ]   for   a   in   poss ] \n         vy   =   [ a [ 2 ]   for   a   in   vels ] \n         # Make results of pinned orbits have only one entry (for plotting speed): \n         y   =   unique ( round . ( y ,   4 )) \n         vy   =   unique ( round . ( vy ,   4 )) \n         # color pinned orbits differently: \n         col   =   length ( y )   ==   1   ?   C1   :   C0 \n         plot ( y ,   vy ,   ls   =   None ,   color   =   col ,   ms   =   1.0 ,   alpha   =   0.5 ,   marker   =   o ) \n     end  end  xlabel ( \\$ y \\$ );   ylabel ( \\$ v_y \\$ )     psos  operates on the unit cell  The  psos  function always calculates the crossings  within  the unit cell of a periodic billiard. This means that no information about the \"actual\" position of the particle is stored, everything is modulo the unit cell.  This can be seen very well in the above example, where there aren't any entries in the region  0.5 - r \u2264 y \u2264 0.5 + r .   Of course it is very easy to \"re-normalize\" the result such that it is coherent. The only change we have to do is simply replace the line  y = [a[2] for a in poss]  with  y   =   [ a [ 2 ]     0.5   ?   a [ 2 ]   +   1   :   a [ 2 ]    for   a   in   poss ]   which gives", 
            "title": "Poincar\u00e9 Sections"
        }, 
        {
            "location": "/basic/high_level/#escape-times", 
            "text": "It is very easy to create your own function that calculates an \"escape time\": the time until the particle leaves the billiard by meeting a specified condition. There is also a high-level function for this though:  #  DynamicalBilliards.escapetime     Function .  escapetime(p, bt, maxiter; warning = false)  Calculate the escape time of a particle  p  in the billiard  bt , which is the time until colliding with any \"door\" in  bt . As a \"door\" is considered any  FiniteWall  with field  isdoor = true .  If the particle performs more than  maxiter  collisions without colliding with the  Door  (i.e. escaping) the returned result is  Inf .  A warning can be thrown if the result is  Inf . Enable this using the keyword  warning = true .  source   Creating a door  To create a \"door\" simply visit the  library page  to learn more about the individual obstacle types (specifically  FiniteWall ). To be able to combine them into a  Billiard  you should also check out the tutorial on  defining your own billiard .   For example, the default implementation of the mushroom billiard has a \"door\" at the bottom of the stem. Thus,  bt   =   billiard_mushroom ()  et   =   zeros ( 100 )  for   i   \u2208   1 : 100 \n     p   =   randominside ( bt ) \n     et [ i ]   =   escapetime ( p ,   bt ,   10000 )  end  println ( Out of 100 particles,  $ ( count ( x -   x   !=   Inf ,   et ))  escaped )  println ( Mean escape time was  $ ( mean ( et [ et   .!=   Inf ])) )   Out of 100 particles, 11 escaped\nMean escape time was 4.436943929428599  Of course,  escapetime  works with  MagneticParticle  as well  escapetime ( randominside ( bt ,   1.0 ),   bt ,   10000 )   87.17643414941281", 
            "title": "Escape Times"
        }, 
        {
            "location": "/basic/high_level/#ray-splitting", 
            "text": "During ray-splitting a particle may propagate through an obstacle given arbitrary transmission and refraction laws. This is also known as a \"semiclassical billiard\".  No matter how complex ray-splitting processes you want, and irrespectively of how many obstacles in the billiard table can perform ray-splitting, there is only a single difference on the main function call: The  evolve!()  function is supplemented with a fourth argument:  ray_splitter :: Dict { Int ,   Any }   This argument is simply a dictionary which handles all ray-splitting processes in the billiard system.  Given an obstacle index within the billiard table it returns a container of the ray-splitting functions: (\u03c6 is the angle of incidence)   T(\u03c6, pflag, \u03c9) : Transmission probability.  \u03b8(\u03c6, pflag, \u03c9) : Transmission (aka diffraction) angle.  new_\u03c9(\u03c9, pflag) : Angular velocity after transmission.   Assuming you have defined a billiard table and a ray-splitter dictionary, the implementation is exactly the same as in the two previous cases: the ray-splitting dictionary is passed to  evolve!()  as a fourth argument.  ray_splitter   =   Dict ( 5   =   ( foo ,   bar ,   baz ))  p   =   randominside ( bt ,   4.0 )  xt ,   yt ,   vxt ,   vyt ,   ts   =   construct ( evolve! ( p ,   bt ,   100.0 ,   ray_splitter ) ... ,   0.01 )   For more information and instructions on defining the  ray_splitter  dictionary visit the  Ray-Splitting tutorial .", 
            "title": "Ray-Splitting"
        }, 
        {
            "location": "/basic/high_level/#standard-billiards-library", 
            "text": "#  DynamicalBilliards.billiard_rectangle     Function .  billiard_rectangle ( x = 1.0 ,   y = 1.0 ;   setting   =   standard )   Return a vector of obstacles that defines a rectangle billiard of size ( x ,  y ).  Settings   \"standard\" : Specular reflection occurs during collision.  \"periodic\" : The walls are  PeriodicWall  type, enforcing periodicity at the boundaries  \"random\" : The velocity is randomized upon collision.  \"ray-splitting\" : All obstacles in the billiard allow for ray-splitting.   source  #  DynamicalBilliards.billiard_sinai     Function .  billiard_sinai ( r = 0.25 ,   x = 1.0 ,   y = 1.0 ;   setting   =   standard )   Return a vector of obstacles that defines a Sinai billiard of size ( x ,  y ) with a disk in its center, of radius  r .  In the periodic case, the system is also known as \"Lorentz Gas\".  Settings   \"standard\" : Specular reflection occurs during collision.  \"periodic\" : The walls are  PeriodicWall  type, enforcing periodicity at the boundaries  \"random\" : The velocity is randomized upon collision.  \"ray-splitting\" : All obstacles in the billiard allow for ray-splitting.   source  #  DynamicalBilliards.billiard_bunimovich     Function .  billiard_bunimovich(l=1.0, w=1.0)  Return a vector of  Obstacle s that define a Buminovich billiard, also called a stadium. The length is considered  without  the attached semicircles, meaning that the full length of the billiard is  l + w . The left and right edges of the stadium are  Semicircle s.  billiard_stadium  is an alias of  billiard_bunimovich .  source  #  DynamicalBilliards.billiard_mushroom     Function .  billiard_mushroom(stem_length = 1.0, stem_width=0.2, cap_radious=1.0,\nstem_location = 0.0)  Create a mushroom billiard. The center of the cap (which is Semicircle) is always at [0, stem_length]. The bottom-most  Wall  is a  Door  (see  escapetime ).  source  #  DynamicalBilliards.billiard_lorentz     Function .  billiard_lorentz(r=0.25, x=1.0, y=1.0)  Alias for  billiard_sinai(r,x,y; setting = \"periodic\") .  source  #  DynamicalBilliards.billiard_polygon     Function .  billiard_polygon ( n :: Int ,   R ,   center   =   [ 0 , 0 ] ;   setting   =   standard )   Return a vector of obstacles that defines a regular-polygonal billiard with  n  sides, radius  r  and given  center .  Note:  R  denotes the so-called outer radius, not the inner one.  Settings   \"standard\" : Specular reflection occurs during collision.  \"periodic\" : The walls are  PeriodicWall  type, enforcing periodicity at the boundaries. Only available for  n=4  or  n=6 .  \"random\" : The velocity is randomized upon collision.   source  #  DynamicalBilliards.billiard_hexagonal_sinai     Function .  billiard_hexagonal_sinai(r, R, center = [0,0]; setting =  standard )  Create a sinai-like billiard, which is a hexagon of outer radius  R , containing at its center (given by  center ) a disk of radius  r . The  setting  keyword is passed to  billiard_polygon .  source  #  DynamicalBilliards.billiard_raysplitting_showcase     Function .  billiard_raysplitting_showcase(x=2.0, y=1.0, r1=0.3, r2=0.2) -  bt, rayspl  Showcase example billiard for ray-splitting processes. A rectangle  (x,y)  with a SplitterWall at  x/2  and two disks at each side, with respective radii  r1 ,  r2 .  Notice : This function returns a billiard  bt  as well as a  rayspl  dictionary!  source", 
            "title": "Standard Billiards Library"
        }, 
        {
            "location": "/visualizing/", 
            "text": "All plotting functionality of \nDynamicalBilliards\n lies within a few well-defined functions that use the \nPyPlot\n package to plot aspects of the system on the current PyPlot figure.\n\n\nAll plotting functions are brought into scope when \nusing PyPlot\n. The functions are:\n\n\nplot_obstacle\n(\nobst\n::\nObstacle\n;\n \nkwargs\n...\n)\n\n\nplot_particle\n(\np\n::\nAbstractParticle\n;\n \nuse_cell\n=\ntrue\n,\n \nkwargs\n...\n)\n\n\nplot_cyclotron\n(\np\n::\nMagneticParticle\n;\n \nuse_cell\n=\ntrue\n,\n \nkwargs\n...\n)\n\n\nplot_billiard\n(\nbt\n::\nVector\n{\nObstacle\n})\n\n\nplot_billiard\n(\nbt\n,\n \nxt\n::\nVector\n,\n \nyt\n::\nVector\n;\n \nplot_orbit\n \n=\n \ntrue\n)\n\n\nanimate_evolution\n(\np\n,\n \nbt\n,\n \ncolnumber\n[,\n \nray\n-\nsplitter\n];\n \nkwargs\n)\n\n\nplot_boundarymap\n(\n\u03be\u03c2\n,\n \n\u03c6\u03c2\n)\n\n\n\n\n\n\nand each has a detailed documentation string.\n\n\n\n\nPlotting the Billiard Table\n\n\nThe function \nplot_obstacle(obst::Obstacle; kwargs...)\n plots the given obstacle on the current PyPlot figure. The \nkwargs...\n are keywords passed directly into \nPyPlot\n's constructors (like e.g. \nlinewidth = 2.0\n). For example:\n\n\nusing\n \nDynamicalBilliards\n,\n \nPyPlot\n\n\nbt\n \n=\n \nbilliard_sinai\n(\n0.3\n)\n\n\n# Plot disk:\n\n\nplot_obstacle\n(\nbt\n[\n5\n])\n\n\n# Plot left wall:\n\n\nplot_obstacle\n(\nbt\n[\n1\n])\n\n\n# Plot right wall with different settings:\n\n\nplot_obstacle\n(\nbt\n[\n2\n];\n \nlinewidth\n \n=\n \n3.0\n,\n \nlinestyle\n \n=\n \ndashed\n,\n \ncolor\n \n=\n \n(\n1.0\n,\n \n0.5\n,\n \n0.5\n))\n\n\n# Set limits for the purpose of the tutorial\n\n\nxlim\n(\n-\n0.1\n,\n \n1.1\n);\n \nylim\n(\n-\n0.1\n,\n \n1.1\n)\n\n\n\n\n\n\nwill plot something like this:\n\n\n\n\nIf you want to quickly plot the entire billiard without changing the settings, simply use the function \nplot_billiard(bt)\n:\n\n\nbt\n \n=\n \nbilliard_polygon\n(\n6\n,\n \n1\n)\n\n\na\n \n=\n \nAntidot\n([\n0.0\n,\n0.0\n],\n \n0.5\n)\n\n\nbt\n \n=\n \nBilliard\n(\nbt\n.\nobstacles\n...\n,\n \na\n)\n\n\nplot_billiard\n(\nbt\n)\n\n\n\n\n\n\nwhich will plot something like this:\n\n\n\n\nplot_billiard()\n also sets up the axis to have equal aspect ratio and sets up the axis limits to be just large enough to contain the entire billiard.\n\n\n\n\nPlotting particles\n\n\nFollowing the above example, we create and plot a particle using the function \nplot_particle\n:\n\n\np\n \n=\n \nrandominside\n(\nbt\n)\n\n\nplot_particle\n(\np\n)\n\n\n# Plot one more particle with purple color,\n\n\n# pentagon shape and bigger size (default is s=30):\n\n\np2\n \n=\n \nrandominside\n(\nbt\n)\n\n\nplot_particle\n(\np2\n;\n \ncolor\n=\n(\n0.5\n,\n \n0\n,\n \n0.8\n),\n \nmarker\n=\np\n,\n \ns\n=\n60.0\n)\n\n\n\n\n\n\nwhich should give you something like this (notice that the particle position and direction are random):\n\n\n\n\n\n\nColor conventions\n\n\nThe default plotting settings have been chosen for maximum clarity and consistency. The color conventions followed are:\n\n\n\n\nParticles are black.\n\n\nParticle orbits/trajectories are blue.\n\n\nReflecting obstacles (e.g. \nDisk\n, \nFiniteWall\n or \nInfiniteWall\n) are green.\n\n\nRandomly reflecting obstacles (e.g. \nRandomDisk\n or \nRandomWall\n) are yellow.\n\n\nRay-splitting obstacles are red with dashed linestyle.\n\n\nPeriodicity enforcing obstacles are purple with dotted linestyle (if and when plotted).\n\n\nDoors (\nInfiniteWall\n with \nisdoor=true\n) are plotted with alternating black and cyan dashed lines.\n\n\n\n\n\n\nAnimating the motion of a particle\n\n\nThe function \nanimate_evolution\n is provided to animate the evolution of a particle from collision to collision:\n\n\nanimate_evolution\n(\np\n,\n \nbt\n,\n \ncolnumber\n[,\n \nray\n-\nsplitter\n];\n \nkwargs\n...\n)\n\n\n\n\n\n\nArguments:\n\n\n\n\np::AbstractParticle\n : The particle to be evolved (gets mutated!).\n\n\nbt::Billiard\n : The billiard.\n\n\ncolnumber::Int\n : Number of collisions to evolve the particle for.\n\n\nray-splitter::Dict{Int, Any}\n : (Optional) Ray-splitting dictionary   that enables ray-splitting processes during evolution.\n\n\n\n\nKeyword Arguments:\n\n\n\n\nnewfig = true\n : Creates a new figure at the function call, and plots the billiard in that figure.\n\n\nsleeptime\n : Time passed to \nsleep()\n between each collision.\n\n\ncol_to_plot\n : How many previous collisions are shown during the animation.\n\n\nparticle_kwargs\n : Either a Dict{Symbol, Any} or a vector of Tuple{Symbol, Any}. Keywords passed into \nplot_particle()\n.\n\n\norbit_kwargs\n : Either a Dict{Symbol, Any} or a Vector of Tuple{Symbol, Any}. Keywords passed into \nPyPlot.plot()\n which plots the orbit of the particle (\nline\n object).\n\n\nsavefigs::Bool\n : If \ntrue\n save .png figures of each frame of the animation A direct movie (like creating a .mp4) of the animation cannot be made automatically, since the animation process mutates the particle.\n\n\nsavename\n : Name (\nincluding path\n) of the figures to be produced. The ending \"_i.png\" will be attached to all figures.\n\n\n\n\nThe function returns \na, b, c\n. Do \na[:remove](), b[:remove](), c[:remove]()\n to clear the particle out of the figure.\n\n\nAutomatic output into an animated image (e.g. \".gif\" format) is not yet supported.\n\n\nLet's animate a particle inside a simple pentagon with magnetic field:\n\n\nbt\n \n=\n \nbilliard_polygon\n(\n5\n,\n \n1\n)\n\n\na\n \n=\n \nDisk\n([\n0.0\n,\n0.0\n],\n \n0.4\n)\n\n\nbt\n \n=\n \n(\nbt\n.\nobstacles\n...\n,\n \na\n)\n\n\np\n \n=\n \nrandominside\n(\nbt\n,\n \n1.0\n)\n\n\n\nsavedir\n \n=\n \ntempdir\n()\n\n\nanimate_evolution\n(\np\n,\n \nbt\n,\n \n50\n;\n \nsavefigs\n \n=\n \ntrue\n,\n \nsavename\n \n=\n \nsavedir\n)\n\n\n\n\n\n\nThis code produced 50 \".png\" images which were later combined into a single \".gif\" animation:\n\n\n\n\n\n\nPeriodic Billiards\n\n\nIn order to plot periodic billiards, you have need to call a different method of \nplot_billiard\n, since now you also have to specify the limits of plotting. The methods provided are:\n\n\nplot_billiard\n(\nbt\n,\n \nxmin\n,\n \nymin\n,\n \nxmax\n,\n \nymax\n)\n\n\nplot_billiard\n(\nbt\n,\n \nxt\n::\nVector\n{\nT\n},\n \nyt\n::\nVector\n{\nT\n})\n\n\n\n\n\n\nThe last one conveniently plots the combo of particle-trajectory and periodic-billiard taking care of all the details internally. Give the keyword \nplot_orbit = false\n if you do not want to plot the orbit defined by \n(xt, yt)\n.\n\n\nFor example, the following code\n\n\nusing\n \nDynamicalBilliards\n,\n \nPyPlot\n\n\nr\n \n=\n \n0.25\n\n\nbt\n \n=\n \nbilliard_rectangle\n(\n2\n,\n \n1\n;\n \nsetting\n \n=\n \nperiodic\n)\n\n\nd\n \n=\n \nDisk\n([\n0.5\n,\n \n0.5\n],\n \nr\n)\n\n\nd2\n \n=\n \nDisk\n([\n1.5\n,\n \n0.5\n],\n \nr\n/\n2\n)\n\n\nbt\n \n=\n \nBilliard\n(\nbt\n.\nobstacles\n...\n,\n \nd\n,\n \nd2\n)\n\n\np\n \n=\n \nrandominside\n(\nbt\n)\n\n\nxt\n,\n \nyt\n,\n \nvxt\n,\n \nvyt\n,\n \nt\n \n=\n \nconstruct\n(\nevolve!\n(\np\n,\n \nbt\n,\n \n50\n)\n...\n)\n\n\nplot_billiard\n(\nbt\n,\n \nxt\n,\n \nyt\n)\n\n\nplot_particle\n(\np\n)\n\n\n\n\n\n\nwill produce something like this: \n\n\nAnimations for periodic billiards are not supported yet.", 
            "title": "Visualizing"
        }, 
        {
            "location": "/visualizing/#plotting-the-billiard-table", 
            "text": "The function  plot_obstacle(obst::Obstacle; kwargs...)  plots the given obstacle on the current PyPlot figure. The  kwargs...  are keywords passed directly into  PyPlot 's constructors (like e.g.  linewidth = 2.0 ). For example:  using   DynamicalBilliards ,   PyPlot  bt   =   billiard_sinai ( 0.3 )  # Plot disk:  plot_obstacle ( bt [ 5 ])  # Plot left wall:  plot_obstacle ( bt [ 1 ])  # Plot right wall with different settings:  plot_obstacle ( bt [ 2 ];   linewidth   =   3.0 ,   linestyle   =   dashed ,   color   =   ( 1.0 ,   0.5 ,   0.5 ))  # Set limits for the purpose of the tutorial  xlim ( - 0.1 ,   1.1 );   ylim ( - 0.1 ,   1.1 )   will plot something like this:   If you want to quickly plot the entire billiard without changing the settings, simply use the function  plot_billiard(bt) :  bt   =   billiard_polygon ( 6 ,   1 )  a   =   Antidot ([ 0.0 , 0.0 ],   0.5 )  bt   =   Billiard ( bt . obstacles ... ,   a )  plot_billiard ( bt )   which will plot something like this:   plot_billiard()  also sets up the axis to have equal aspect ratio and sets up the axis limits to be just large enough to contain the entire billiard.", 
            "title": "Plotting the Billiard Table"
        }, 
        {
            "location": "/visualizing/#plotting-particles", 
            "text": "Following the above example, we create and plot a particle using the function  plot_particle :  p   =   randominside ( bt )  plot_particle ( p )  # Plot one more particle with purple color,  # pentagon shape and bigger size (default is s=30):  p2   =   randominside ( bt )  plot_particle ( p2 ;   color = ( 0.5 ,   0 ,   0.8 ),   marker = p ,   s = 60.0 )   which should give you something like this (notice that the particle position and direction are random):", 
            "title": "Plotting particles"
        }, 
        {
            "location": "/visualizing/#color-conventions", 
            "text": "The default plotting settings have been chosen for maximum clarity and consistency. The color conventions followed are:   Particles are black.  Particle orbits/trajectories are blue.  Reflecting obstacles (e.g.  Disk ,  FiniteWall  or  InfiniteWall ) are green.  Randomly reflecting obstacles (e.g.  RandomDisk  or  RandomWall ) are yellow.  Ray-splitting obstacles are red with dashed linestyle.  Periodicity enforcing obstacles are purple with dotted linestyle (if and when plotted).  Doors ( InfiniteWall  with  isdoor=true ) are plotted with alternating black and cyan dashed lines.", 
            "title": "Color conventions"
        }, 
        {
            "location": "/visualizing/#animating-the-motion-of-a-particle", 
            "text": "The function  animate_evolution  is provided to animate the evolution of a particle from collision to collision:  animate_evolution ( p ,   bt ,   colnumber [,   ray - splitter ];   kwargs ... )   Arguments:   p::AbstractParticle  : The particle to be evolved (gets mutated!).  bt::Billiard  : The billiard.  colnumber::Int  : Number of collisions to evolve the particle for.  ray-splitter::Dict{Int, Any}  : (Optional) Ray-splitting dictionary   that enables ray-splitting processes during evolution.   Keyword Arguments:   newfig = true  : Creates a new figure at the function call, and plots the billiard in that figure.  sleeptime  : Time passed to  sleep()  between each collision.  col_to_plot  : How many previous collisions are shown during the animation.  particle_kwargs  : Either a Dict{Symbol, Any} or a vector of Tuple{Symbol, Any}. Keywords passed into  plot_particle() .  orbit_kwargs  : Either a Dict{Symbol, Any} or a Vector of Tuple{Symbol, Any}. Keywords passed into  PyPlot.plot()  which plots the orbit of the particle ( line  object).  savefigs::Bool  : If  true  save .png figures of each frame of the animation A direct movie (like creating a .mp4) of the animation cannot be made automatically, since the animation process mutates the particle.  savename  : Name ( including path ) of the figures to be produced. The ending \"_i.png\" will be attached to all figures.   The function returns  a, b, c . Do  a[:remove](), b[:remove](), c[:remove]()  to clear the particle out of the figure.  Automatic output into an animated image (e.g. \".gif\" format) is not yet supported.  Let's animate a particle inside a simple pentagon with magnetic field:  bt   =   billiard_polygon ( 5 ,   1 )  a   =   Disk ([ 0.0 , 0.0 ],   0.4 )  bt   =   ( bt . obstacles ... ,   a )  p   =   randominside ( bt ,   1.0 )  savedir   =   tempdir ()  animate_evolution ( p ,   bt ,   50 ;   savefigs   =   true ,   savename   =   savedir )   This code produced 50 \".png\" images which were later combined into a single \".gif\" animation:", 
            "title": "Animating the motion of a particle"
        }, 
        {
            "location": "/visualizing/#periodic-billiards", 
            "text": "In order to plot periodic billiards, you have need to call a different method of  plot_billiard , since now you also have to specify the limits of plotting. The methods provided are:  plot_billiard ( bt ,   xmin ,   ymin ,   xmax ,   ymax )  plot_billiard ( bt ,   xt :: Vector { T },   yt :: Vector { T })   The last one conveniently plots the combo of particle-trajectory and periodic-billiard taking care of all the details internally. Give the keyword  plot_orbit = false  if you do not want to plot the orbit defined by  (xt, yt) .  For example, the following code  using   DynamicalBilliards ,   PyPlot  r   =   0.25  bt   =   billiard_rectangle ( 2 ,   1 ;   setting   =   periodic )  d   =   Disk ([ 0.5 ,   0.5 ],   r )  d2   =   Disk ([ 1.5 ,   0.5 ],   r / 2 )  bt   =   Billiard ( bt . obstacles ... ,   d ,   d2 )  p   =   randominside ( bt )  xt ,   yt ,   vxt ,   vyt ,   t   =   construct ( evolve! ( p ,   bt ,   50 ) ... )  plot_billiard ( bt ,   xt ,   yt )  plot_particle ( p )   will produce something like this:   Animations for periodic billiards are not supported yet.", 
            "title": "Periodic Billiards"
        }, 
        {
            "location": "/basic/low_level/", 
            "text": "Low Level API\n\n\n\n\nImplementation\n\n\nBefore talking about the low level methods that enable everything to work nicely together, let's talk about how this package works.\n\n\nFirstly one defines a \nBilliard\n and (if desired) the \nray-splitting dictionary\n. Then one creates a particle inside the defined billiard table. The algorithm for the propagation of a particle is the following:\n\n\n\n\nCalculate the \ncollisiontime\n of the particle with \nall\n obstacles in the billiard.\n\n\nFind the smallest time, and the obstacle corresponding to that.\n\n\nrelocate!\n the particle, so that it is on the correct side of the obstacle to-be-collided with.\n\n\n\n\n(Optionally) check if there is transmission for ray-splitting: \nT(\u03c6) \n rand()\n\n\n\n\nIf yes, perform the ray-splitting algorithm (not discussed here).\n\n\nIf not, then \nresolvecollision!\n of the particle with the obstacle.\n\n\nContinue this loop for a given amount of time.\n\n\n\n\n\n\n\n\nNotice that the \nrelocate!\n step is \nvery\n important because it takes care that all particles remain inside the billiard.\n\n\n\n\nWhere is \"inside\"?\n\n\nIf for some reason (finite numeric precision) a particle goes outside a billiard, then it will escape to infinity. But what \nis\n inside?\n\n\n\"Inside\" is defined on obstacle level by the function \ndistance\n:\n\n\n#\n\n\nDynamicalBilliards.distance\n \n \nFunction\n.\n\n\ndistance(p::AbstractParticle, o::Obstacle)\n\n\n\n\n\nReturn the \nsigned\n distance between particle \np\n and obstacle \no\n, based on \np.pos\n. Positive distance corresponds to the particle being on the \nallowed\n region of the \nObstacle\n. E.g. for a \nDisk\n, the distance is positive when the particle is outside of the disk, negative otherwise.\n\n\ndistance(p::AbstractParticle, bt::Billiard)\n\n\n\n\n\nReturn minimum \ndistance(p, obst)\n for all \nobst\n in \nbt\n. If the \ndistance(p, bt)\n is negative this means that the particle is outside the billiard.\n\n\nAll \ndistance\n functions can also be given a position (vector) instead of a particle.\n\n\nsource\n\n\n\n\n\n\nIt's all about bounce!\n\n\nThe algorithm steps 1-3 described above are bundled in the following well-behaving function:\n\n\n#\n\n\nDynamicalBilliards.bounce!\n \n \nFunction\n.\n\n\nbounce!(p::AbstractParticle, bt::Billiard) -\n i, t, pos, vel\n\n\n\n\n\n\"Bounce\" the particle (advance for one collision) in the billiard.\n\n\nSpecifically, find the \nnext_collision\n of \np\n with \nbt\n, \nrelocate!\n the particle correctly, \nresolvecollision!\n with the colliding obstacle and finally return:\n\n\n\n\nindex of the obstacle that the particle just collided with\n\n\nthe time from the previous collision until the current collision \nt\n\n\nposition and velocity of the particle at the current collision (\nafter\n the collision has been resolved!). The position is given in the unit cell of periodic billiards. Do \npos += p.current_cell\n for the position in real space.\n\n\n\n\nsource\n\n\n\n\nbounce!\n is the function used internally by all high-level functions, like \nevolve!\n, \nboundarymap\n, \nescapetime\n, etc.\n\n\nThis is the function a user should use if they want to calculate other things besides what is already available in the high level API.\n\n\n\n\nObstacle Library\n\n\n#\n\n\nDynamicalBilliards.Obstacle\n \n \nType\n.\n\n\nObstacle{\n:AbstractFloat}\n\n\n\n\n\nObstacle supertype.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.Circular\n \n \nType\n.\n\n\nCircular{T\n:AbstractFloat} \n: Obstacle{T}\n\n\n\n\n\nCircular obstacle supertype.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.Disk\n \n \nType\n.\n\n\nDisk{T\n:AbstractFloat}  \n: Circular{T}\n\n\n\n\n\nDisk-like obstacle with propagation allowed outside of the circle (immutable type).\n\n\nFields:\n\n\n\n\nc::SVector{2,T}\n : Center.\n\n\nr::T\n : Radius.\n\n\nname::String\n : Some name given for user convenience. Defaults to \"Disk\".\n\n\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.RandomDisk\n \n \nType\n.\n\n\nRandomDisk{T\n:AbstractFloat} \n: Circular{T}\n\n\n\n\n\nDisk-like obstacle that randomly (and uniformly) reflects colliding particles. The propagation is allowed outside of the circle.\n\n\nFields:\n\n\n\n\nc::SVector{2,T}\n : Center.\n\n\nr::T\n : Radius.\n\n\nname::String\n : Some name given for user convenience. Defaults to \"Random disk\".\n\n\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.Antidot\n \n \nType\n.\n\n\nAntidot{T\n:AbstractFloat} \n: Circular{T}\n\n\n\n\n\nDisk-like obstacle that allows propagation both inside and outside of the disk (mutable type). Used in ray-splitting billiards.\n\n\nFields:\n\n\n\n\nc::SVector{2,T}\n : Center.\n\n\nr::T\n : Radius.\n\n\npflag::Bool\n : Flag that keeps track of where the particle is currently propagating (\npflag\n = propagation-flag). \ntrue\n stands for \noutside\n the disk, \nfalse\n for \ninside\n the disk. Defaults to \ntrue\n.\n\n\nname::String\n : Name of the obstacle given for user convenience. Defaults to \"Antidot\".\n\n\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.Semicircle\n \n \nType\n.\n\n\nSemicircle{T\n:AbstractFloat} \n: Circular{T}\n\n\n\n\n\nObstacle that represents half a circle.\n\n\nFields:\n\n\n\n\nc::SVector{2,T}\n : Center.\n\n\nr::T\n : Radius.\n\n\nfacedir::SVector{2,T}\n : Direction where the open face of the Semicircle is facing.\n\n\nname::String\n : Name of the obstacle given for user convenience. Defaults to \"Semicircle\".\n\n\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.Wall\n \n \nType\n.\n\n\nWall{T\n:AbstractFloat} \n: Obstacle{T}\n\n\n\n\n\nWall obstacle supertype.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.InfiniteWall\n \n \nType\n.\n\n\nInfiniteWall{T\n:AbstractFloat} \n: Wall{T}\n\n\n\n\n\nWall obstacle imposing specular reflection during collision (immutable type). Faster than \nFiniteWall\n, meant to be used for convex billiards.\n\n\nFields:\n\n\n\n\nsp::SVector{2,T}\n : Starting point of the Wall.\n\n\nep::SVector{2,T}\n : Ending point of the Wall.\n\n\nnormal::SVector{2,T}\n : Normal vector to the wall, pointing to where the particle \nwill come from before a collision\n (pointing towards the inside of the billiard). The size of the vector is irrelevant since it is internally normalized.\n\n\nname::String\n : Name of the obstacle, given for user convenience. Defaults to \"Wall\".\n\n\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.RandomWall\n \n \nType\n.\n\n\nRandomWall{T\n:AbstractFloat} \n: Wall{T}\n\n\n\n\n\nWall obstacle imposing (uniformly) random reflection during collision (immutable type).\n\n\nFields:\n\n\n\n\nsp::SVector{2,T}\n : Starting point of the Wall.\n\n\nep::SVector{2,T}\n : Ending point of the Wall.\n\n\nnormal::SVector{2,T}\n : Normal vector to the wall, pointing to where the particle \nis expected to come from\n (pointing towards the inside of the billiard).\n\n\nname::String\n : Name of the obstacle, given for user convenience. Defaults to \"Random wall\".\n\n\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.PeriodicWall\n \n \nType\n.\n\n\nPeriodicWall{T\n:AbstractFloat} \n: Wall{T}\n\n\n\n\n\nWall obstacle that imposes periodic boundary conditions upon collision (immutable type).\n\n\nFields:\n\n\n\n\nsp::SVector{2,T}\n : Starting point of the Wall.\n\n\nep::SVector{2,T}\n : Ending point of the Wall.\n\n\nnormal::SVector{2,T}\n : Normal vector to the wall, pointing to where the particle \nwill come from\n (to the inside the billiard). The size of the vector is \nimportant\n! This vector is added to a particle's \npos\n during collision. Therefore the size of the normal vector must be correctly associated with the size of the periodic cell.\n\n\nname::String\n : Name of the obstacle, given for user convenience. Defaults to \"Periodic wall\".\n\n\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.SplitterWall\n \n \nType\n.\n\n\nSplitterWall{T\n:AbstractFloat} \n: Wall{T}\n\n\n\n\n\nWall obstacle imposing allowing for ray-splitting (mutable type).\n\n\nFields:\n\n\n\n\nsp::SVector{2,T}\n : Starting point of the Wall.\n\n\nep::SVector{2,T}\n : Ending point of the Wall.\n\n\nnormal::SVector{2,T}\n : Normal vector to the wall, pointing to where the particle \nwill come from before a collision\n. The size of the vector is irrelevant.\n\n\npflag::Bool\n : Flag that keeps track of where the particle is currently propagating (\npflag\n = propagation flag). \ntrue\n is associated with the \nnormal\n vector the wall is instantiated with. Defaults to \ntrue\n.\n\n\nname::String\n : Name of the obstacle, given for user convenience. Defaults to \"Splitter wall\".\n\n\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.FiniteWall\n \n \nType\n.\n\n\nFiniteWall{T\n:AbstractFloat} \n: Wall{T}\n\n\n\n\n\nWall obstacle imposing specular reflection during collision (immutable type). Slower than \nInfiniteWall\n, meant to be used for non-convex billiards.\n\n\nGiving a \ntrue\n value to the field \nisdoor\n designates this obstacle to be a \nDoor\n. This is used in \nescapetime\n function. A \nDoor\n is a obstacle of the billiard that the particle can escape from, thus enabling calculations of escape times.\n\n\nFields:\n\n\n\n\nsp::SVector{2,T}\n : Starting point of the Wall.\n\n\nep::SVector{2,T}\n : Ending point of the Wall.\n\n\nnormal::SVector{2,T}\n : Normal vector to the wall, pointing to where the particle \nwill come from before a collision\n (pointing towards the inside of the billiard). The size of the vector is irrelevant since it is internally normalized.\n\n\nisdoor::Bool\n : Flag of whether this \nFiniteWall\n instance is a \"Door\".\n\n\nname::String\n : Name of the obstacle, given for user convenience. Defaults to \"Finite Wall\".\n\n\n\n\nsource\n\n\n\n\n\n\nObstacle-related functions\n\n\n#\n\n\nDynamicalBilliards.normalvec\n \n \nFunction\n.\n\n\nnormalvec(obst::Obstacle, position)\n\n\n\n\n\nReturn the vector normal to the obstacle's boundary at the given position (which is assumed to be very close to the obstacle's boundary).\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.cellsize\n \n \nFunction\n.\n\n\ncellsize(bt)\n\n\n\n\n\nReturn the delimiters \nxmin, ymin, xmax, ymax\n of the given obstacle/billiard.\n\n\nUsed in \nrandominside()\n, error checking and plotting.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.arclength\n \n \nFunction\n.\n\n\narclength(p::AbstractParticle, o::Obstacle)\n\n\n\n\n\nReturns the boundary coordinate of the particle on the obstacle, assuming that the particle position is on the obstacle.\n\n\nThe boundary coordinate is measured as:\n\n\n\n\nthe distance from start point to end point in \nWall\ns\n\n\nthe arc length measured counterclockwise from the open face in \nSemicircle\ns\n\n\nthe arc length measured counterclockwise from the rightmost point in \nCircular\ns\n\n\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.totallength\n \n \nFunction\n.\n\n\ntotallength(o::Obstacle)\n\n\n\n\n\nReturn the total length of \no\n.\n\n\nsource\n\n\n\n\nCollision Times\n\n\n#\n\n\nDynamicalBilliards.collisiontime\n \n \nFunction\n.\n\n\ncollisiontime(p::AbstractParticle, o::Obstacle)\n\n\n\n\n\nCalculate the collision time between given particle and obstacle. Returns \nInf\n if the collision is not possible \nor\n if the collision happens backwards in time.\n\n\nIn the case of magnetic propagation, there are always two possible collisions. The function \nrealangle\n decides which of the two will occur first, based on the sign of the angular velocity of the magnetic particle.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.next_collision\n \n \nFunction\n.\n\n\nnext_collision(p, bt) -\n (tmin, index)\n\n\n\n\n\nReturn the minimum collision time out of all \ncollisiontime(p, obst)\n for \nobst \u2208 bt\n, as well as the \nindex\n of the corresponding obstacle.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.realangle\n \n \nFunction\n.\n\n\nrealangle(p::MagneticParticle, o::Obstacle, pc, pr, I) -\n \u03b8\n\n\n\n\n\nGiven the intersection point \nI\n of the trajectory of a magnetic particle \np\n with some obstacle \no\n, find the real angle that will be spanned until the particle collides with the obstacle.\n\n\nThe function also takes care of problems that may arise when particles are very close to the obstacle's boundaries, due to floating-point precision.\n\n\n(the cyclotron center \npc\n and radius \npr\n are suplimented for efficiency, since they have been calculated already)\n\n\nsource\n\n\n\n\nPropagation functions\n\n\n#\n\n\nDynamicalBilliards.propagate!\n \n \nFunction\n.\n\n\npropagate!(p::AbstractParticle, t)\n\n\n\n\n\nPropagate the particle \np\n for given time \nt\n, changing appropriately the the \np.pos\n and \np.vel\n fields.\n\n\nFor a \nParticle\n the propagation is a straight line (i.e. velocity vector is constant). For a \nMagneticParticle\n the propagation is circular motion with cyclic frequency \np.omega\n and radius \n1/p.omega\n.\n\n\npropagate!(p, position, t)\n\n\n\n\n\nDo the same, but take advantage of the already calculated \nposition\n that the particle should end up at.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.resolvecollision!\n \n \nFunction\n.\n\n\nresolvecollision!(p::AbstractParticle, o::Obstacle)\n\n\n\n\n\nResolve the collision between particle \np\n and obstacle \no\n, depending on the type of \no\n (do \nspecular!\n or \nperiodicity!\n).\n\n\nresolvecollision!(p, o, T::Function, \u03b8::Function, new_\u03c9::Function)\n\n\n\n\n\nThis is the ray-splitting implementation. The three functions given are drawn from the ray-splitting dictionary that is passed directly to \nevolve!()\n. For a calculated incidence angle \u03c6, if T(\u03c6) \n rand(), ray-splitting occurs.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.relocate!\n \n \nFunction\n.\n\n\nrelocate!(p::AbstractParticle, o::Obstacle, t) -\n newt\n\n\n\n\n\nPropagate the particle's position for time \nt\n, and check if it is on the correct side of the obstacle. If not, adjust the time \nt\n by \ntimeprec\n and re-evalute until correct. When correct, propagate the particle itself to the correct position and return the final adjusted time.\n\n\nNotice that the adjustment is increased geometrically; if one adjustment is not enough, the adjusted time is multiplied by a factor of 10. This happens as many times as necessary.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.specular!\n \n \nFunction\n.\n\n\nspecular!(p::AbstractParticle, o::Obstacle)\n\n\n\n\n\nPerform specular reflection based on the normal vector of the Obstacle.\n\n\nIn the case where the given obstacle is a \nRandomObstacle\n, the specular reflection randomizes the velocity instead (within -\u03c0/2+\u03b5 to \u03c0/2-\u03b5 of the normal vector).\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.periodicity!\n \n \nFunction\n.\n\n\nperiodicity!(p::AbstractParticle, w::PeriodicWall)\n\n\n\n\n\nPerform periodicity conditions of \nw\n on \np\n.\n\n\nsource\n\n\n\n\nRay-splitting\n\n\n#\n\n\nDynamicalBilliards.isphysical\n \n \nFunction\n.\n\n\nisphysical\n(\nraysplitter\n::\nDict\n;\n \nonly_mandatory\n \n=\n \nfalse\n)\n\n\n\n\n\n\nReturn \ntrue\n if the given ray-splitting dictionary has physically plausible properties.\n\n\nSpecifically, check if (\u03c6 is the incidence angle, \u03b8 the refraction angle):\n\n\n\n\nCritical angle means total reflection: If \u03b8(\u03c6) \u2265 \u03c0/2 then Tr(\u03c6) = 0\n\n\nTransmission probability is even function: Tr(\u03c6) \u2248 Tr(-\u03c6) at \u03c9 = 0\n\n\nRefraction angle is odd function: \u03b8(\u03c6) \u2248 -\u03b8(-\u03c6) at \u03c9 = 0\n\n\nRay reversal is true: \u03b8(\u03b8(\u03c6, pflag, \u03c9), !pflag, \u03c9) \u2248 \u03c6\n\n\nMagnetic conservation is true: (\u03c9_new(\u03c9_new(\u03c9, pflag), !pflag) \u2248 \u03c9\n\n\n\n\nThe first property is mandatory to hold for any setting and is always checked. The rest are checked if \nonly_mandatory = false\n.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.acceptable_raysplitter\n \n \nFunction\n.\n\n\nacceptable_raysplitter(raysplitter, bt)\n\n\n\n\n\nReturn \ntrue\n if the given ray-splitting dictionary \nraysplitter\n can be used in conjuction with given billiard table \nbt\n.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.reset_billiard!\n \n \nFunction\n.\n\n\nreset_billiard!(bt)\n\n\n\n\n\nSets the \npflag\n field of all ray-splitting obstacles of a billiard table to \ntrue\n.\n\n\nsource", 
            "title": "Low Level API"
        }, 
        {
            "location": "/basic/low_level/#low-level-api", 
            "text": "", 
            "title": "Low Level API"
        }, 
        {
            "location": "/basic/low_level/#implementation", 
            "text": "Before talking about the low level methods that enable everything to work nicely together, let's talk about how this package works.  Firstly one defines a  Billiard  and (if desired) the  ray-splitting dictionary . Then one creates a particle inside the defined billiard table. The algorithm for the propagation of a particle is the following:   Calculate the  collisiontime  of the particle with  all  obstacles in the billiard.  Find the smallest time, and the obstacle corresponding to that.  relocate!  the particle, so that it is on the correct side of the obstacle to-be-collided with.   (Optionally) check if there is transmission for ray-splitting:  T(\u03c6)   rand()   If yes, perform the ray-splitting algorithm (not discussed here).  If not, then  resolvecollision!  of the particle with the obstacle.  Continue this loop for a given amount of time.     Notice that the  relocate!  step is  very  important because it takes care that all particles remain inside the billiard.", 
            "title": "Implementation"
        }, 
        {
            "location": "/basic/low_level/#where-is-inside", 
            "text": "If for some reason (finite numeric precision) a particle goes outside a billiard, then it will escape to infinity. But what  is  inside?  \"Inside\" is defined on obstacle level by the function  distance :  #  DynamicalBilliards.distance     Function .  distance(p::AbstractParticle, o::Obstacle)  Return the  signed  distance between particle  p  and obstacle  o , based on  p.pos . Positive distance corresponds to the particle being on the  allowed  region of the  Obstacle . E.g. for a  Disk , the distance is positive when the particle is outside of the disk, negative otherwise.  distance(p::AbstractParticle, bt::Billiard)  Return minimum  distance(p, obst)  for all  obst  in  bt . If the  distance(p, bt)  is negative this means that the particle is outside the billiard.  All  distance  functions can also be given a position (vector) instead of a particle.  source", 
            "title": "Where is \"inside\"?"
        }, 
        {
            "location": "/basic/low_level/#its-all-about-bounce", 
            "text": "The algorithm steps 1-3 described above are bundled in the following well-behaving function:  #  DynamicalBilliards.bounce!     Function .  bounce!(p::AbstractParticle, bt::Billiard) -  i, t, pos, vel  \"Bounce\" the particle (advance for one collision) in the billiard.  Specifically, find the  next_collision  of  p  with  bt ,  relocate!  the particle correctly,  resolvecollision!  with the colliding obstacle and finally return:   index of the obstacle that the particle just collided with  the time from the previous collision until the current collision  t  position and velocity of the particle at the current collision ( after  the collision has been resolved!). The position is given in the unit cell of periodic billiards. Do  pos += p.current_cell  for the position in real space.   source   bounce!  is the function used internally by all high-level functions, like  evolve! ,  boundarymap ,  escapetime , etc.  This is the function a user should use if they want to calculate other things besides what is already available in the high level API.", 
            "title": "It's all about bounce!"
        }, 
        {
            "location": "/basic/low_level/#obstacle-library", 
            "text": "#  DynamicalBilliards.Obstacle     Type .  Obstacle{ :AbstractFloat}  Obstacle supertype.  source  #  DynamicalBilliards.Circular     Type .  Circular{T :AbstractFloat}  : Obstacle{T}  Circular obstacle supertype.  source  #  DynamicalBilliards.Disk     Type .  Disk{T :AbstractFloat}   : Circular{T}  Disk-like obstacle with propagation allowed outside of the circle (immutable type).  Fields:   c::SVector{2,T}  : Center.  r::T  : Radius.  name::String  : Some name given for user convenience. Defaults to \"Disk\".   source  #  DynamicalBilliards.RandomDisk     Type .  RandomDisk{T :AbstractFloat}  : Circular{T}  Disk-like obstacle that randomly (and uniformly) reflects colliding particles. The propagation is allowed outside of the circle.  Fields:   c::SVector{2,T}  : Center.  r::T  : Radius.  name::String  : Some name given for user convenience. Defaults to \"Random disk\".   source  #  DynamicalBilliards.Antidot     Type .  Antidot{T :AbstractFloat}  : Circular{T}  Disk-like obstacle that allows propagation both inside and outside of the disk (mutable type). Used in ray-splitting billiards.  Fields:   c::SVector{2,T}  : Center.  r::T  : Radius.  pflag::Bool  : Flag that keeps track of where the particle is currently propagating ( pflag  = propagation-flag).  true  stands for  outside  the disk,  false  for  inside  the disk. Defaults to  true .  name::String  : Name of the obstacle given for user convenience. Defaults to \"Antidot\".   source  #  DynamicalBilliards.Semicircle     Type .  Semicircle{T :AbstractFloat}  : Circular{T}  Obstacle that represents half a circle.  Fields:   c::SVector{2,T}  : Center.  r::T  : Radius.  facedir::SVector{2,T}  : Direction where the open face of the Semicircle is facing.  name::String  : Name of the obstacle given for user convenience. Defaults to \"Semicircle\".   source  #  DynamicalBilliards.Wall     Type .  Wall{T :AbstractFloat}  : Obstacle{T}  Wall obstacle supertype.  source  #  DynamicalBilliards.InfiniteWall     Type .  InfiniteWall{T :AbstractFloat}  : Wall{T}  Wall obstacle imposing specular reflection during collision (immutable type). Faster than  FiniteWall , meant to be used for convex billiards.  Fields:   sp::SVector{2,T}  : Starting point of the Wall.  ep::SVector{2,T}  : Ending point of the Wall.  normal::SVector{2,T}  : Normal vector to the wall, pointing to where the particle  will come from before a collision  (pointing towards the inside of the billiard). The size of the vector is irrelevant since it is internally normalized.  name::String  : Name of the obstacle, given for user convenience. Defaults to \"Wall\".   source  #  DynamicalBilliards.RandomWall     Type .  RandomWall{T :AbstractFloat}  : Wall{T}  Wall obstacle imposing (uniformly) random reflection during collision (immutable type).  Fields:   sp::SVector{2,T}  : Starting point of the Wall.  ep::SVector{2,T}  : Ending point of the Wall.  normal::SVector{2,T}  : Normal vector to the wall, pointing to where the particle  is expected to come from  (pointing towards the inside of the billiard).  name::String  : Name of the obstacle, given for user convenience. Defaults to \"Random wall\".   source  #  DynamicalBilliards.PeriodicWall     Type .  PeriodicWall{T :AbstractFloat}  : Wall{T}  Wall obstacle that imposes periodic boundary conditions upon collision (immutable type).  Fields:   sp::SVector{2,T}  : Starting point of the Wall.  ep::SVector{2,T}  : Ending point of the Wall.  normal::SVector{2,T}  : Normal vector to the wall, pointing to where the particle  will come from  (to the inside the billiard). The size of the vector is  important ! This vector is added to a particle's  pos  during collision. Therefore the size of the normal vector must be correctly associated with the size of the periodic cell.  name::String  : Name of the obstacle, given for user convenience. Defaults to \"Periodic wall\".   source  #  DynamicalBilliards.SplitterWall     Type .  SplitterWall{T :AbstractFloat}  : Wall{T}  Wall obstacle imposing allowing for ray-splitting (mutable type).  Fields:   sp::SVector{2,T}  : Starting point of the Wall.  ep::SVector{2,T}  : Ending point of the Wall.  normal::SVector{2,T}  : Normal vector to the wall, pointing to where the particle  will come from before a collision . The size of the vector is irrelevant.  pflag::Bool  : Flag that keeps track of where the particle is currently propagating ( pflag  = propagation flag).  true  is associated with the  normal  vector the wall is instantiated with. Defaults to  true .  name::String  : Name of the obstacle, given for user convenience. Defaults to \"Splitter wall\".   source  #  DynamicalBilliards.FiniteWall     Type .  FiniteWall{T :AbstractFloat}  : Wall{T}  Wall obstacle imposing specular reflection during collision (immutable type). Slower than  InfiniteWall , meant to be used for non-convex billiards.  Giving a  true  value to the field  isdoor  designates this obstacle to be a  Door . This is used in  escapetime  function. A  Door  is a obstacle of the billiard that the particle can escape from, thus enabling calculations of escape times.  Fields:   sp::SVector{2,T}  : Starting point of the Wall.  ep::SVector{2,T}  : Ending point of the Wall.  normal::SVector{2,T}  : Normal vector to the wall, pointing to where the particle  will come from before a collision  (pointing towards the inside of the billiard). The size of the vector is irrelevant since it is internally normalized.  isdoor::Bool  : Flag of whether this  FiniteWall  instance is a \"Door\".  name::String  : Name of the obstacle, given for user convenience. Defaults to \"Finite Wall\".   source", 
            "title": "Obstacle Library"
        }, 
        {
            "location": "/basic/low_level/#obstacle-related-functions", 
            "text": "#  DynamicalBilliards.normalvec     Function .  normalvec(obst::Obstacle, position)  Return the vector normal to the obstacle's boundary at the given position (which is assumed to be very close to the obstacle's boundary).  source  #  DynamicalBilliards.cellsize     Function .  cellsize(bt)  Return the delimiters  xmin, ymin, xmax, ymax  of the given obstacle/billiard.  Used in  randominside() , error checking and plotting.  source  #  DynamicalBilliards.arclength     Function .  arclength(p::AbstractParticle, o::Obstacle)  Returns the boundary coordinate of the particle on the obstacle, assuming that the particle position is on the obstacle.  The boundary coordinate is measured as:   the distance from start point to end point in  Wall s  the arc length measured counterclockwise from the open face in  Semicircle s  the arc length measured counterclockwise from the rightmost point in  Circular s   source  #  DynamicalBilliards.totallength     Function .  totallength(o::Obstacle)  Return the total length of  o .  source", 
            "title": "Obstacle-related functions"
        }, 
        {
            "location": "/basic/low_level/#collision-times", 
            "text": "#  DynamicalBilliards.collisiontime     Function .  collisiontime(p::AbstractParticle, o::Obstacle)  Calculate the collision time between given particle and obstacle. Returns  Inf  if the collision is not possible  or  if the collision happens backwards in time.  In the case of magnetic propagation, there are always two possible collisions. The function  realangle  decides which of the two will occur first, based on the sign of the angular velocity of the magnetic particle.  source  #  DynamicalBilliards.next_collision     Function .  next_collision(p, bt) -  (tmin, index)  Return the minimum collision time out of all  collisiontime(p, obst)  for  obst \u2208 bt , as well as the  index  of the corresponding obstacle.  source  #  DynamicalBilliards.realangle     Function .  realangle(p::MagneticParticle, o::Obstacle, pc, pr, I) -  \u03b8  Given the intersection point  I  of the trajectory of a magnetic particle  p  with some obstacle  o , find the real angle that will be spanned until the particle collides with the obstacle.  The function also takes care of problems that may arise when particles are very close to the obstacle's boundaries, due to floating-point precision.  (the cyclotron center  pc  and radius  pr  are suplimented for efficiency, since they have been calculated already)  source", 
            "title": "Collision Times"
        }, 
        {
            "location": "/basic/low_level/#propagation-functions", 
            "text": "#  DynamicalBilliards.propagate!     Function .  propagate!(p::AbstractParticle, t)  Propagate the particle  p  for given time  t , changing appropriately the the  p.pos  and  p.vel  fields.  For a  Particle  the propagation is a straight line (i.e. velocity vector is constant). For a  MagneticParticle  the propagation is circular motion with cyclic frequency  p.omega  and radius  1/p.omega .  propagate!(p, position, t)  Do the same, but take advantage of the already calculated  position  that the particle should end up at.  source  #  DynamicalBilliards.resolvecollision!     Function .  resolvecollision!(p::AbstractParticle, o::Obstacle)  Resolve the collision between particle  p  and obstacle  o , depending on the type of  o  (do  specular!  or  periodicity! ).  resolvecollision!(p, o, T::Function, \u03b8::Function, new_\u03c9::Function)  This is the ray-splitting implementation. The three functions given are drawn from the ray-splitting dictionary that is passed directly to  evolve!() . For a calculated incidence angle \u03c6, if T(\u03c6)   rand(), ray-splitting occurs.  source  #  DynamicalBilliards.relocate!     Function .  relocate!(p::AbstractParticle, o::Obstacle, t) -  newt  Propagate the particle's position for time  t , and check if it is on the correct side of the obstacle. If not, adjust the time  t  by  timeprec  and re-evalute until correct. When correct, propagate the particle itself to the correct position and return the final adjusted time.  Notice that the adjustment is increased geometrically; if one adjustment is not enough, the adjusted time is multiplied by a factor of 10. This happens as many times as necessary.  source  #  DynamicalBilliards.specular!     Function .  specular!(p::AbstractParticle, o::Obstacle)  Perform specular reflection based on the normal vector of the Obstacle.  In the case where the given obstacle is a  RandomObstacle , the specular reflection randomizes the velocity instead (within -\u03c0/2+\u03b5 to \u03c0/2-\u03b5 of the normal vector).  source  #  DynamicalBilliards.periodicity!     Function .  periodicity!(p::AbstractParticle, w::PeriodicWall)  Perform periodicity conditions of  w  on  p .  source", 
            "title": "Propagation functions"
        }, 
        {
            "location": "/basic/low_level/#ray-splitting", 
            "text": "#  DynamicalBilliards.isphysical     Function .  isphysical ( raysplitter :: Dict ;   only_mandatory   =   false )   Return  true  if the given ray-splitting dictionary has physically plausible properties.  Specifically, check if (\u03c6 is the incidence angle, \u03b8 the refraction angle):   Critical angle means total reflection: If \u03b8(\u03c6) \u2265 \u03c0/2 then Tr(\u03c6) = 0  Transmission probability is even function: Tr(\u03c6) \u2248 Tr(-\u03c6) at \u03c9 = 0  Refraction angle is odd function: \u03b8(\u03c6) \u2248 -\u03b8(-\u03c6) at \u03c9 = 0  Ray reversal is true: \u03b8(\u03b8(\u03c6, pflag, \u03c9), !pflag, \u03c9) \u2248 \u03c6  Magnetic conservation is true: (\u03c9_new(\u03c9_new(\u03c9, pflag), !pflag) \u2248 \u03c9   The first property is mandatory to hold for any setting and is always checked. The rest are checked if  only_mandatory = false .  source  #  DynamicalBilliards.acceptable_raysplitter     Function .  acceptable_raysplitter(raysplitter, bt)  Return  true  if the given ray-splitting dictionary  raysplitter  can be used in conjuction with given billiard table  bt .  source  #  DynamicalBilliards.reset_billiard!     Function .  reset_billiard!(bt)  Sets the  pflag  field of all ray-splitting obstacles of a billiard table to  true .  source", 
            "title": "Ray-splitting"
        }, 
        {
            "location": "/tutorials/billiard_table/", 
            "text": "Creating your own Billiard\n\n\n#\n\n\nDynamicalBilliards.Billiard\n \n \nType\n.\n\n\nBilliard(obstacles...)\n\n\n\n\n\nConstruct a \nBilliard\n from given \nobstacles\n (tuple, vector, varargs).\n\n\nIf you want to use the \nboundarymap\n function, then it is expected to provide the obstacles of the billiard in sorted order, such that the boundary coordinate (measured using \narclength\n) around the billiard is increasing counter-clockwise.\n\n\nThe boundary coordinate is measured as:\n\n\n\n\nthe distance from start point to end point in \nWall\ns\n\n\nthe arc length measured counterclockwise from the open face in \nSemicircle\ns\n\n\nthe arc length measured counterclockwise from the rightmost point in \nCircular\ns\n\n\n\n\nsource\n\n\n\n\nA billiard \nbt\n is a wrapper of a \nTuple\n of \nObstacles\n. The abstract Type \nObstacle{T}\n is the supertype of all objects that a particle may collide with, with global billiard precision of type \nT\n.\n\n\nThere are many premade functions that construct well-known billiards, like the periodic Sinai billiard. You can find all of them at the \nStandard Billiards Library\n.\n\n\nTo create a custom billiard from scratch, it is often convenient to start with an empty \nVector{Obstacle{T}}\n:\n\n\nusing\n \nDynamicalBilliards\n\n\nbt\n \n=\n \nObstacle\n{\nFloat64\n}[]\n  \n# T\n: AbstractFloat\n\n\n\n\n\n\nand then you create your obstacles one by one and add them to it. All obstacles that are already defined in the package can be found at the \nObstacles page\n of the library. The function \nbilliard_polygon\n creates a polygonal billiard table. However, for the example of this page, we will create a hexagonal billiard with a disk in the middle step-by-step.\n\n\nThe first step is to define the six walls of the billiard table. An \nInfiniteWall\n object needs to be supplemented with a start point, an end point, a normal vector and, optionally, a name.\n\n\nThe vertex points of a regular hexagon of radius \nr\n are given by the formula:\n\n\n\n\n\n(x,y) = \\left( r\\cos\\left(\\frac{2\\pi i}{6}\\right), r\\cos\\left(\\frac{2\\pi i}{6}\\right) \\right)\\,, \\quad \\text{for i $\\in$ \\{1,...,6\\}}\n\n\n\n\n(x,y) = \\left( r\\cos\\left(\\frac{2\\pi i}{6}\\right), r\\cos\\left(\\frac{2\\pi i}{6}\\right) \\right)\\,, \\quad \\text{for i $\\in$ \\{1,...,6\\}}\n\n\n\n\n\nTo create each wall object, we will implement the following loop:\n\n\nhexagon_vertex\n \n=\n \n(\nr\n)\n \n-\n \n[\n \n[\nr\n*\ncos\n(\n2\n\u03c0\n*\ni\n/\n6\n),\n \nr\n*\nsin\n(\n2\n\u03c0\n*\ni\n/\n6\n)]\n \nfor\n \ni\n \nin\n \n1\n:\n6\n]\n\n\nhexver\n \n=\n \nhexagon_vertex\n(\n2.0\n)\n\n\n\nfor\n \ni\n \nin\n \neachindex\n(\nhexver\n)\n\n  \nstarting\n \n=\n \nhexver\n[\ni\n]\n\n  \nending\n \n=\n \nhexver\n[\nmod1\n(\ni\n+\n1\n,\n \nlength\n(\nhexver\n))]\n\n  \nw\n \n=\n \nending\n \n-\n \nstarting\n\n  \nnormal\n \n=\n \n[\n-\nw\n[\n2\n],\n \nw\n[\n1\n]]\n\n  \nwall\n \n=\n \nInfiniteWall\n(\nstarting\n,\n \nending\n,\n \nnormal\n,\n \nwall \n$i\n)\n\n  \npush!\n(\nbt\n,\n \nwall\n)\n\n\nend\n\n\n\n\n\n\nThe \nnormal\n vector of a \nWall\n obstacle is necessary to be supplemented by the user because it must point towards where the particle is expected to come from. If \nw\n is the vector (wall) pointing from start- to end-point then the vector \n[-w[2], w[1]]\n is pointing to the left of \nw\n and the vector \n[w[2], -[w1]]\n is pointing to the right. Both are normal to \nw\n, but you have to know which one to pick. In this case this is very easy, since the normal has to simply point towards the origin.\n\n\nWe add a disk by specifying a center and radius (and optionally a name):\n\n\nd\n \n=\n \nDisk\n([\n0\n,\n0\n],\n \n0.8\n)\n\n\npush!\n(\nbt\n,\n \nd\n)\n\n\n# Make the structure required:\n\n\nbilliard\n \n=\n \nBilliard\n(\nbt\n)\n\n\n\n\n\n\nTo make sure the billiard looks as you would expect, use the function \nplot_billiard(bt)\n. Create a particle inside that billiard and evolve it:\n\n\nusing\n \nPyPlot\n\n\nplot_billiard\n(\nbilliard\n)\n\n\n\u03c9\n \n=\n \n0.5\n\n\np\n \n=\n \nrandominside\n(\nbilliard\n,\n \n\u03c9\n)\n\n\nxt\n,\n \nyt\n,\n \nvxt\n,\n \nvyt\n,\n \nt\n \n=\n \nconstruct\n(\nevolve!\n(\np\n,\n \nbilliard\n,\n \n100\n)\n...\n)\n\n\nplot\n(\nxt\n,\n \nyt\n)\n\n\n\n\n\n\nThe billiard table now works for straight or magnetic propagation. To expand this to ray-splitting you have to use ray-splitting \nObstacle\ns (\nsee the tutorial on Ray-Splitting\n). Additional information on how to define your own \nObstacle\n sub-type is given in the tutorial on \nDefining your own Obstacles\n.\n\n\nIf you make \nany\n billiard system that you think is cool and missing from this package, you are more than welcome to submit a PR extending the Standard Billiards Library with your contribution!\n\n\n\n\nObstacle order\n\n\n\n\nThe obstacle order matters.\n\n\nThe order that the obstacles are given to the constructor is important for the function \nboundarymap\n. For any other functionality it is irrelevant.\n\n\n\n\n\n\nConvex Billiards\n\n\nThese 2 types of walls used by \nDynamicalBilliards\n that behave differently during evolution:\n\n\n\n\nInfiniteWall\n : This wall is not actually infinite. It has a starting and ending position. However, when the collision time is calculated, this wall is assumed to be a line (i.e. \ninfinite\n). This is absolutely fine, as long as the billiards used are \nconvex\n polygons\n. \nSplitterWall\n, \nPeriodicWall\n and \nRandomWall\n behave like \nInfiniteWall\n during evolution.\n\n\nFiniteWall\n : This wall is indeed finite in every sense of the word. This means that during collision time estimation, if the collision point that was calculated lies \noutside\n of the boundaries of the \nFiniteWall\n, then the returned collision time is \nInf\n (no collision). \nFiniteWall\n is slower than \nInfiniteWall\n for that reason.\n\n\n\n\nIf you wish to create a billiard table that you know will be convex, you should then use \nInfiniteWall\ns for faster evolution. Notice that using \nescapetime\n requires at least one \nFiniteWall\n with field \nisdoor=true\n.", 
            "title": "Defining a Billiard Table"
        }, 
        {
            "location": "/tutorials/billiard_table/#creating-your-own-billiard", 
            "text": "#  DynamicalBilliards.Billiard     Type .  Billiard(obstacles...)  Construct a  Billiard  from given  obstacles  (tuple, vector, varargs).  If you want to use the  boundarymap  function, then it is expected to provide the obstacles of the billiard in sorted order, such that the boundary coordinate (measured using  arclength ) around the billiard is increasing counter-clockwise.  The boundary coordinate is measured as:   the distance from start point to end point in  Wall s  the arc length measured counterclockwise from the open face in  Semicircle s  the arc length measured counterclockwise from the rightmost point in  Circular s   source   A billiard  bt  is a wrapper of a  Tuple  of  Obstacles . The abstract Type  Obstacle{T}  is the supertype of all objects that a particle may collide with, with global billiard precision of type  T .  There are many premade functions that construct well-known billiards, like the periodic Sinai billiard. You can find all of them at the  Standard Billiards Library .  To create a custom billiard from scratch, it is often convenient to start with an empty  Vector{Obstacle{T}} :  using   DynamicalBilliards  bt   =   Obstacle { Float64 }[]    # T : AbstractFloat   and then you create your obstacles one by one and add them to it. All obstacles that are already defined in the package can be found at the  Obstacles page  of the library. The function  billiard_polygon  creates a polygonal billiard table. However, for the example of this page, we will create a hexagonal billiard with a disk in the middle step-by-step.  The first step is to define the six walls of the billiard table. An  InfiniteWall  object needs to be supplemented with a start point, an end point, a normal vector and, optionally, a name.  The vertex points of a regular hexagon of radius  r  are given by the formula:   \n(x,y) = \\left( r\\cos\\left(\\frac{2\\pi i}{6}\\right), r\\cos\\left(\\frac{2\\pi i}{6}\\right) \\right)\\,, \\quad \\text{for i $\\in$ \\{1,...,6\\}}  \n(x,y) = \\left( r\\cos\\left(\\frac{2\\pi i}{6}\\right), r\\cos\\left(\\frac{2\\pi i}{6}\\right) \\right)\\,, \\quad \\text{for i $\\in$ \\{1,...,6\\}}   To create each wall object, we will implement the following loop:  hexagon_vertex   =   ( r )   -   [   [ r * cos ( 2 \u03c0 * i / 6 ),   r * sin ( 2 \u03c0 * i / 6 )]   for   i   in   1 : 6 ]  hexver   =   hexagon_vertex ( 2.0 )  for   i   in   eachindex ( hexver ) \n   starting   =   hexver [ i ] \n   ending   =   hexver [ mod1 ( i + 1 ,   length ( hexver ))] \n   w   =   ending   -   starting \n   normal   =   [ - w [ 2 ],   w [ 1 ]] \n   wall   =   InfiniteWall ( starting ,   ending ,   normal ,   wall  $i ) \n   push! ( bt ,   wall )  end   The  normal  vector of a  Wall  obstacle is necessary to be supplemented by the user because it must point towards where the particle is expected to come from. If  w  is the vector (wall) pointing from start- to end-point then the vector  [-w[2], w[1]]  is pointing to the left of  w  and the vector  [w[2], -[w1]]  is pointing to the right. Both are normal to  w , but you have to know which one to pick. In this case this is very easy, since the normal has to simply point towards the origin.  We add a disk by specifying a center and radius (and optionally a name):  d   =   Disk ([ 0 , 0 ],   0.8 )  push! ( bt ,   d )  # Make the structure required:  billiard   =   Billiard ( bt )   To make sure the billiard looks as you would expect, use the function  plot_billiard(bt) . Create a particle inside that billiard and evolve it:  using   PyPlot  plot_billiard ( billiard )  \u03c9   =   0.5  p   =   randominside ( billiard ,   \u03c9 )  xt ,   yt ,   vxt ,   vyt ,   t   =   construct ( evolve! ( p ,   billiard ,   100 ) ... )  plot ( xt ,   yt )   The billiard table now works for straight or magnetic propagation. To expand this to ray-splitting you have to use ray-splitting  Obstacle s ( see the tutorial on Ray-Splitting ). Additional information on how to define your own  Obstacle  sub-type is given in the tutorial on  Defining your own Obstacles .  If you make  any  billiard system that you think is cool and missing from this package, you are more than welcome to submit a PR extending the Standard Billiards Library with your contribution!", 
            "title": "Creating your own Billiard"
        }, 
        {
            "location": "/tutorials/billiard_table/#obstacle-order", 
            "text": "The obstacle order matters.  The order that the obstacles are given to the constructor is important for the function  boundarymap . For any other functionality it is irrelevant.", 
            "title": "Obstacle order"
        }, 
        {
            "location": "/tutorials/billiard_table/#convex-billiards", 
            "text": "These 2 types of walls used by  DynamicalBilliards  that behave differently during evolution:   InfiniteWall  : This wall is not actually infinite. It has a starting and ending position. However, when the collision time is calculated, this wall is assumed to be a line (i.e.  infinite ). This is absolutely fine, as long as the billiards used are  convex  polygons .  SplitterWall ,  PeriodicWall  and  RandomWall  behave like  InfiniteWall  during evolution.  FiniteWall  : This wall is indeed finite in every sense of the word. This means that during collision time estimation, if the collision point that was calculated lies  outside  of the boundaries of the  FiniteWall , then the returned collision time is  Inf  (no collision).  FiniteWall  is slower than  InfiniteWall  for that reason.   If you wish to create a billiard table that you know will be convex, you should then use  InfiniteWall s for faster evolution. Notice that using  escapetime  requires at least one  FiniteWall  with field  isdoor=true .", 
            "title": "Convex Billiards"
        }, 
        {
            "location": "/tutorials/ray-splitting/", 
            "text": "Ray-Splitting\n\n\nRay-splitting is a semi-classical approach to the billiard system, giving a wave attribute to the ray traced by the particle. Upon collision a particle may propagate through an obstacle (transmission \n refraction) or be reflected. Following the mindset of this package, implementing a ray-splitting billiard requires only three very simple steps.\n\n\n\n\nRay-Splitting Obstacles\n\n\nFirst, an obstacle that supports ray-splitting is required to be present in your billiard table. The only new feature these obstacles have is an additional Boolean field called \npflag\n (propagation flag). This field notes on which side of the obstacle the particle is currently propagating.\n\n\nThe normal vector as well as the distance from boundary change sign depending on the value of \npflag\n. The obstacles \nAntidot\n and \nSplitterWall\n are the equivalents of disk and wall for ray-splitting.\n\n\nLet's add an \nAntidot\n to a billiard table:\n\n\nusing\n \nDynamicalBilliards\n\n\nbt\n \n=\n \nbilliard_rectangle\n()\n\n\na\n \n=\n \nAntidot\n([\n0.5\n,\n0.5\n],\n \n0.3\n)\n\n\npush!\n(\nbt\n,\n \na\n)\n\n\n\n\n\n\n\n\nRay-Splitting Functions\n\n\nSecondly, for each obstacle in your billiard table that you want to perform ray-splitting, you have to define 3 functions (\u03c6 = angle of incidence, \u03c9 = angular velocity \nbefore\n transmission):\n\n\n\n\nT(\u03c6, \npflag\n, \u03c9) : Transmission probability \u03a4 depending on whether the particle is inside or outside the obstacle (\npflag\n) and optionally depending on \u03c9.\n\n\n\u03b8(\u03c6, \npflag\n, \u03c9) : Transmission (aka refraction) angle \u03b8 depending on whether the particle is inside or outside the obstacle (\npflag\n) and optionally depending on \u03c9.\n\n\n\u03c9_new(\u03c9, \npflag\n) : Angular velocity after transmission.\n\n\n\n\nThe above three functions use the \nsame convention\n: the argument \npflag\n is the one the Obstacle has \nbefore transmission\n. For example, if a particle is outside a disk (let \npflag = true\n here) and is transmitted inside the disk (\npflag\n becomes \nfalse\n here), then all three functions will be given their second argument (the Boolean one) as \ntrue\n!\n\n\n\n\nRay-Splitter Dictionary\n\n\nTo pass the information of the aforementioned functions into the main API a dictionary is required:\n\n\nraysplitter\n::\nDict\n{\nInt\n,\n \nAny\n}\n\n\n\n\n\n\nThis dictionary is a map of the \nobstacle index\n within the billiard table to a \ncontainer of the ray-splitting functions\n. This container could be a \nVector\n or a \nTuple\n and the later is the suggested version.\n\n\nFor example, if we wanted to allocate ray-splitting functions for the \n5th\n obstacle in our billiard table, which could be e.g. an \nAntidot\n, we would write something like:\n\n\nsa\n \n=\n \n(\n\u03b8\n,\n \npflag\n,\n \n\u03c9\n)\n \n-\n \npflag\n \n?\n \n2\n\u03b8\n \n:\n \n0.5\n\u03b8\n  \n# refraction (scatter) angle\n\n\nT\n \n=\n \n(\n\u03b8\n,\n \npflag\n,\n \n\u03c9\n)\n \n-\n \nbegin\n   \n# Transmission probability\n\n  \nif\n \npflag\n\n    \nabs\n(\n\u03b8\n)\n \n \n\u03c0\n/\n4\n \n?\n \n0.5\nexp\n(\n-\n(\n\u03b8\n)\n^\n2\n/\n2\n(\n\u03c0\n/\n8\n)\n^\n2\n)\n \n:\n \n0.0\n\n  \nelse\n\n    \n0.75\n*\nexp\n(\n-\n(\n\u03b8\n)\n^\n2\n/\n2\n(\n\u03c0\n/\n4\n)\n^\n2\n)\n\n  \nend\n\n\nend\n\n\nnewo\n \n=\n \n(\n\u03c9\n,\n \nbool\n)\n \n-\n \nbool\n \n?\n \n-\n0.5\n\u03c9\n \n:\n \n-\n2\n\u03c9\n   \n# new angular velocity\n\n\nraysplitter\n \n=\n \nDict\n(\n5\n \n=\n \n(\nT\n,\n \nsa\n,\n \nnewo\n))\n  \n# Index maps to container of Functions\n\n\n\n\n\n\n\n\nOrder of Arguments\n\n\nThe functions \nmust accept the specific number of arguments shown in the previous section\n even if some are not used. Also, the functions must be given \nin the specific order: [1. transmission probability, 2. refraction angle, 3. new \u03c9]\n in the vector passed to the dictionary.\n\n\n\n\nThe next step is very simple: the \nraysplitter\n dictionary is directly passed into \nevolve!()\n as a fourth argument. Using the billiard table we defined previously, where its 5th element is a ray-splitting \nAntidot\n, we now do:\n\n\nbt\n \n=\n \nbilliard_rectangle\n()\n\n\na\n \n=\n \nAntidot\n([\n0.5\n,\n \n0.5\n],\n \n0.25\n)\n\n\npush!\n(\nbt\n,\n \na\n)\n\n\n\u03c9\n \n=\n \n1.25\n\n\np\n \n=\n \nrandominside\n(\nbt\n,\n \n\u03c9\n)\n\n\ndt\n \n=\n \n0.05\n\n\nxt\n,\n \nyt\n,\n \nvxt\n,\n \nvyt\n,\n \nts\n \n=\n \nconstruct\n(\nevolve!\n(\np\n,\n \nbt\n,\n \n25.0\n,\n \nraysplitter\n)\n...\n,\n \ndt\n)\n\n\nusing\n \nPyPlot\n\n\nDynamicalBilliards\n.\nenableplotting\n()\n\n\nplot_billiard\n(\nbt\n)\n\n\nplot\n(\nxt\n,\n \nyt\n)\n\n\n\n\n\n\nwhich should give a result similar to this:\n\n\n\n\nA final difference to be noted is that in the case of ray-splitting with magnetic fields, the fourth value returned by \nevolve!()\n is not a number, but a vector of angular velocities \nomegas\n. The value \nomegas[i]\n is the angular velocity the particle has while propagating from state \npos[i], vel[i]\n to state \npos[i+1], vel[i+1]\n. The \nconstruct()\n function takes this into account.\n\n\n\n\nNo field \npflag\n error\n\n\nIf you ever encounter the error \nERROR: type SomeObstacleType has no field pflag\n this means that the index provided by your ray-splitting dictionary points to an object that does not support ray-splitting. Use the functions:\n\n\nacceptable_raysplitter\n(\nraysplitter\n,\n \nbt\n)\n\n\nsupports_raysplitting\n(\nobst\n::\nObstacle\n)\n\n\n\n\n\n\nto find out what you did wrong. Most likely, the index you supplied was incorrect, i.e. the index could be \n5\n instead of \n4\n.\n\n\n\n\nExample Animation\n\n\nIn the [examples page], you can find the code for the following animation, which includes ray-splitting:\n\n\n\n\n\n\nPhysics\n\n\nThe condition for transmission is simply: \nT(\u03c6, pflag, \u03c9) \n rand()\n. If it returns \ntrue\n, transmission (i.e. ray-splitting) will happen. Otherwise just specular reflection will take place. A more detailed discussion is on the ray-splitting section of the \nPhysics\n page.", 
            "title": "Ray-Splitting"
        }, 
        {
            "location": "/tutorials/ray-splitting/#ray-splitting", 
            "text": "Ray-splitting is a semi-classical approach to the billiard system, giving a wave attribute to the ray traced by the particle. Upon collision a particle may propagate through an obstacle (transmission   refraction) or be reflected. Following the mindset of this package, implementing a ray-splitting billiard requires only three very simple steps.", 
            "title": "Ray-Splitting"
        }, 
        {
            "location": "/tutorials/ray-splitting/#ray-splitting-obstacles", 
            "text": "First, an obstacle that supports ray-splitting is required to be present in your billiard table. The only new feature these obstacles have is an additional Boolean field called  pflag  (propagation flag). This field notes on which side of the obstacle the particle is currently propagating.  The normal vector as well as the distance from boundary change sign depending on the value of  pflag . The obstacles  Antidot  and  SplitterWall  are the equivalents of disk and wall for ray-splitting.  Let's add an  Antidot  to a billiard table:  using   DynamicalBilliards  bt   =   billiard_rectangle ()  a   =   Antidot ([ 0.5 , 0.5 ],   0.3 )  push! ( bt ,   a )", 
            "title": "Ray-Splitting Obstacles"
        }, 
        {
            "location": "/tutorials/ray-splitting/#ray-splitting-functions", 
            "text": "Secondly, for each obstacle in your billiard table that you want to perform ray-splitting, you have to define 3 functions (\u03c6 = angle of incidence, \u03c9 = angular velocity  before  transmission):   T(\u03c6,  pflag , \u03c9) : Transmission probability \u03a4 depending on whether the particle is inside or outside the obstacle ( pflag ) and optionally depending on \u03c9.  \u03b8(\u03c6,  pflag , \u03c9) : Transmission (aka refraction) angle \u03b8 depending on whether the particle is inside or outside the obstacle ( pflag ) and optionally depending on \u03c9.  \u03c9_new(\u03c9,  pflag ) : Angular velocity after transmission.   The above three functions use the  same convention : the argument  pflag  is the one the Obstacle has  before transmission . For example, if a particle is outside a disk (let  pflag = true  here) and is transmitted inside the disk ( pflag  becomes  false  here), then all three functions will be given their second argument (the Boolean one) as  true !", 
            "title": "Ray-Splitting Functions"
        }, 
        {
            "location": "/tutorials/ray-splitting/#ray-splitter-dictionary", 
            "text": "To pass the information of the aforementioned functions into the main API a dictionary is required:  raysplitter :: Dict { Int ,   Any }   This dictionary is a map of the  obstacle index  within the billiard table to a  container of the ray-splitting functions . This container could be a  Vector  or a  Tuple  and the later is the suggested version.  For example, if we wanted to allocate ray-splitting functions for the  5th  obstacle in our billiard table, which could be e.g. an  Antidot , we would write something like:  sa   =   ( \u03b8 ,   pflag ,   \u03c9 )   -   pflag   ?   2 \u03b8   :   0.5 \u03b8    # refraction (scatter) angle  T   =   ( \u03b8 ,   pflag ,   \u03c9 )   -   begin     # Transmission probability \n   if   pflag \n     abs ( \u03b8 )     \u03c0 / 4   ?   0.5 exp ( - ( \u03b8 ) ^ 2 / 2 ( \u03c0 / 8 ) ^ 2 )   :   0.0 \n   else \n     0.75 * exp ( - ( \u03b8 ) ^ 2 / 2 ( \u03c0 / 4 ) ^ 2 ) \n   end  end  newo   =   ( \u03c9 ,   bool )   -   bool   ?   - 0.5 \u03c9   :   - 2 \u03c9     # new angular velocity  raysplitter   =   Dict ( 5   =   ( T ,   sa ,   newo ))    # Index maps to container of Functions    Order of Arguments  The functions  must accept the specific number of arguments shown in the previous section  even if some are not used. Also, the functions must be given  in the specific order: [1. transmission probability, 2. refraction angle, 3. new \u03c9]  in the vector passed to the dictionary.   The next step is very simple: the  raysplitter  dictionary is directly passed into  evolve!()  as a fourth argument. Using the billiard table we defined previously, where its 5th element is a ray-splitting  Antidot , we now do:  bt   =   billiard_rectangle ()  a   =   Antidot ([ 0.5 ,   0.5 ],   0.25 )  push! ( bt ,   a )  \u03c9   =   1.25  p   =   randominside ( bt ,   \u03c9 )  dt   =   0.05  xt ,   yt ,   vxt ,   vyt ,   ts   =   construct ( evolve! ( p ,   bt ,   25.0 ,   raysplitter ) ... ,   dt )  using   PyPlot  DynamicalBilliards . enableplotting ()  plot_billiard ( bt )  plot ( xt ,   yt )   which should give a result similar to this:   A final difference to be noted is that in the case of ray-splitting with magnetic fields, the fourth value returned by  evolve!()  is not a number, but a vector of angular velocities  omegas . The value  omegas[i]  is the angular velocity the particle has while propagating from state  pos[i], vel[i]  to state  pos[i+1], vel[i+1] . The  construct()  function takes this into account.", 
            "title": "Ray-Splitter Dictionary"
        }, 
        {
            "location": "/tutorials/ray-splitting/#no-field-pflag-error", 
            "text": "If you ever encounter the error  ERROR: type SomeObstacleType has no field pflag  this means that the index provided by your ray-splitting dictionary points to an object that does not support ray-splitting. Use the functions:  acceptable_raysplitter ( raysplitter ,   bt )  supports_raysplitting ( obst :: Obstacle )   to find out what you did wrong. Most likely, the index you supplied was incorrect, i.e. the index could be  5  instead of  4 .", 
            "title": "No field pflag error"
        }, 
        {
            "location": "/tutorials/ray-splitting/#example-animation", 
            "text": "In the [examples page], you can find the code for the following animation, which includes ray-splitting:", 
            "title": "Example Animation"
        }, 
        {
            "location": "/tutorials/ray-splitting/#physics", 
            "text": "The condition for transmission is simply:  T(\u03c6, pflag, \u03c9)   rand() . If it returns  true , transmission (i.e. ray-splitting) will happen. Otherwise just specular reflection will take place. A more detailed discussion is on the ray-splitting section of the  Physics  page.", 
            "title": "Physics"
        }, 
        {
            "location": "/tutorials/own_obstacle/", 
            "text": "Creating your own \nObstacle\n Type\n\n\nIn this tutorial we will go through the processes of creating a new obstacle type, a \nSemicircle\n. This type is already used in the \nbilliard_bunimovich\n and \nbilliard_mushroom\n functions.\n\n\n\n\nEverything uses \nSVector{2}\n\n\nFields of \nParticle\ns and \nObstacle\ns contain all their information in 2-dimensional static vectors from module \nStaticArrays\n. This is important to keep in mind when extending new methods.\n\n\n\n\n\n\nType Definition\n\n\nThe first thing you have to do is make your new type a sub-type of \nObstacle{T}\n (or any other abstract sub-type of it). We will do:\n\n\nstruct\n \nSemicircle\n{\nT\n:\nAbstractFloat\n}\n \n:\n \nCircular\n{\nT\n}\n \n# \n: Obstacle{T}\n\n    \nc\n::\nSVector\n{\n2\n,\nT\n}\n \n# this MUST be a static vector\n\n    \nr\n::\nT\n\n    \nfacedir\n::\nSVector\n{\n2\n,\nT\n}\n \n# this MUST be a static vector\n\n    \nname\n::\nString\n\n\nend\n\n\n\n\n\n\nc\n is the center and \nr\n is the radius of the full circle. \nfacedir\n is the direction which the semicircle is facing, which is also the direction of its \"open\" face. \nname\n is a final (mandatory) field that is there to easily identify which obstacle is which.\n\n\nNotice that the \nstruct\n must be parameterized by \nT\n:AbstractFloat\n (see the \nnumerical precision\n page for more).\n\n\nFor convenience, I will also define:\n\n\nfunction\n \nSemicircle\n(\n\n    \nc\n::\nAbstractVector\n{\nT\n},\n \nr\n::\nReal\n,\n \nfacedir\n,\n \nname\n \n=\n \nSemicircle\n)\n \nwhere\n \n{\nT\n:\nReal\n}\n\n    \nS\n \n=\n \nT\n \n:\n \nInteger\n \n?\n \nFloat64\n \n:\n \nT\n\n    \nreturn\n \nSemicircle\n{\nS\n}(\nSVector\n{\n2\n,\nS\n}(\nc\n),\n \nconvert\n(\nS\n,\n \nabs\n(\nr\n)),\n \nname\n)\n\n\nend\n\n\n\n\n\n\nso that constructing a \nSemicircle\n is possible from arbitrary vectors.\n\n\n\n\nNecessary Methods\n\n\nThe following functions must obtain methods for \nSemicircle\n (or any other custom \nObstacle\n) in order for it to work with \nDynamicalBilliards\n:\n\n\n\n\nnormalvec\n\n\ndistance\n (with arguments \n(position, obstacle)\n)\n\n\ncollisiontime\n with \nParticle\n\n\nTrivial \ncollisiontime\n method with \nMagneticParticle\n that returns \nerror()\n (see optional methods)\n\n\n\n\nAssuming that upon collision a specular reflection happens, then you don't need to define a method for \nresolvecollision!\n.\n\n\nThe first method is very simple, just do:\n\n\nnormalvec\n(\nd\n::\nSemicircle\n,\n \npos\n)\n \n=\n \nnormalize\n(\nd\n.\nc\n \n-\n \npos\n)\n\n\n\n\n\n\nSince the function is only used during \ndistance\n and \nresolvecollision!\n and since we will be writing explicit methods for the first, we don't have to care about what happens when the particle is far away from the boundary.\n\n\nThe \ndistance\n method is a bit tricky. Since the type already subtypes \nCircular\n, the following definition from \nDynamicalBilliards\n applies:\n\n\ndistance\n(\npos\n::\nAbstractVector\n,\n \nd\n::\nCircular\n)\n \n=\n \nnorm\n(\npos\n \n-\n \nd\n.\nc\n)\n \n-\n \nd\n.\nr\n\n\n\n\n\n\nHowever, the method must be expanded. That is because when the particle is on the \"open\" half of the disk, the distance is not correct. We write:\n\n\nSV\n \n=\n \nSVector\n{\n2\n}\n \n#convenience\n\n\nfunction\n \ndistance\n(\npos\n::\nAbstractVector\n{\nT\n},\n \ns\n::\nSemicircle\n{\nT\n})\n \nwhere\n \n{\nT\n}\n\n    \n# Check on which half of circle is the particle\n\n    \nv1\n \n=\n \npos\n \n.-\n \ns\n.\nc\n\n    \nnn\n \n=\n \ndot\n(\nv1\n,\n \ns\n.\nfacedir\n)\n\n    \nif\n \nnn\n \n\u2264\n \n0\n \n# I am \ninside semicircle\n\n        \nreturn\n \ns\n.\nr\n \n-\n \nnorm\n(\npos\n \n-\n \ns\n.\nc\n)\n\n    \nelse\n \n# I am on the \nother side\n\n        \nend1\n \n=\n \nSV\n(\ns\n.\nc\n[\n1\n]\n \n+\n \ns\n.\nr\n*\ns\n.\nfacedir\n[\n2\n],\n \ns\n.\nc\n[\n2\n]\n \n-\n \ns\n.\nr\n*\ns\n.\nfacedir\n[\n1\n])\n\n        \nend2\n \n=\n \nSV\n(\ns\n.\nc\n[\n1\n]\n \n-\n \ns\n.\nr\n*\ns\n.\nfacedir\n[\n2\n],\n \ns\n.\nc\n[\n2\n]\n \n+\n \ns\n.\nr\n*\ns\n.\nfacedir\n[\n1\n])\n\n        \nreturn\n \nmin\n(\nnorm\n(\npos\n \n-\n \nend1\n),\n \nnorm\n(\npos\n \n-\n \nend2\n))\n\n    \nend\n\n\nend\n\n\n\n\n\n\nNotice that this definition always returns positive distance when the particle is on the \"other side\".\n\n\nFinally, the method for \ncollisiontime\n is by far the most \ntrickiest\n. But, with pen, paper and a significant amount of patience, one can find a way:\n\n\nfunction\n \ncollisiontime\n(\np\n::\nParticle\n{\nT\n},\n \nd\n::\nSemicircle\n{\nT\n})\n::\nT\n \nwhere\n \n{\nT\n}\n\n\n    \ndc\n \n=\n \np\n.\npos\n \n-\n \nd\n.\nc\n\n    \nB\n \n=\n \ndot\n(\np\n.\nvel\n,\n \ndc\n)\n         \n#velocity towards circle center: B \n 0\n\n    \nC\n \n=\n \ndot\n(\ndc\n,\n \ndc\n)\n \n-\n \nd\n.\nr\n^\n2\n    \n#being outside of circle: C \n 0\n\n    \n\u0394\n \n=\n \nB\n^\n2\n \n-\n \nC\n\n\n    \n\u0394\n \n=\n \n0\n \n \nreturn\n \nInf\n\n    \nsqrtD\n \n=\n \nsqrt\n(\n\u0394\n)\n\n\n    \nnn\n \n=\n \ndot\n(\ndc\n,\n \nd\n.\nfacedir\n)\n\n    \nif\n \nnn\n \n\u2265\n \n0\n \n# I am NOT inside semicircle\n\n        \n# Return most positive time\n\n        \nt\n \n=\n \n-\nB\n \n+\n \nsqrtD\n\n    \nelse\n \n# I am inside semicircle:\n\n        \n# these lines make sure that the code works for ANY starting position:\n\n        \nt\n \n=\n \n-\nB\n \n-\n \nsqrtD\n\n        \nif\n \nt\n \n\u2264\n \n0\n \n||\n \ndistance\n(\np\n,\n \nd\n)\n \n\u2264\n \ndistancecheck\n(\nT\n)\n\n            \nt\n \n=\n \n-\nB\n \n+\n \nsqrtD\n\n        \nend\n\n    \nend\n\n    \n# This check is necessary to not collide with the non-existing side\n\n    \nnewpos\n \n=\n \np\n.\npos\n \n+\n \np\n.\nvel\n \n.*\n \nt\n\n    \nif\n \ndot\n(\nnewpos\n \n-\n \nd\n.\nc\n,\n \nd\n.\nfacedir\n)\n \n\u2265\n \n0\n \n# collision point on BAD HALF;\n\n        \nreturn\n \nInf\n\n    \nend\n\n    \n# If collision time is negative, return Inf:\n\n    \nt\n \n\u2264\n \n0.0\n \n?\n \nInf\n \n:\n \nt\n\n\nend\n\n\n\n\n\n\nAnd that is all. The obstacle now works perfectly fine for straight propagation and properly initializes particles with \nrandominside\n!\n\n\n\n\nOptional Methods\n\n\n\n\ncollisiontime\n with \nMagneticParticle\n : enables magnetic propagation\n\n\nplot_obstacle\n : enables plotting (used in \nplot_billiard\n)\n\n\narclength\n so that the \nboundarymap\n can be computed.\n\n\n\n\nThe \ncollisiontime\n method for \nMagneticParticle\n is very easy in this case, because it is almost identical with the method for the general \nCircular\n obstacle:\n\n\nfunction\n \ncollisiontime\n(\np\n::\nMagneticParticle\n{\nT\n},\n \no\n::\nSemicircle\n{\nT\n})\n::\nT\n \nwhere\n \n{\nT\n}\n\n    \n\u03c9\n \n=\n \np\n.\nomega\n\n    \npc\n,\n \nrc\n \n=\n \ncyclotron\n(\np\n)\n\n    \np1\n \n=\n \no\n.\nc\n\n    \nr1\n \n=\n \no\n.\nr\n\n    \nd\n \n=\n \nnorm\n(\np1\n-\npc\n)\n\n    \nif\n \n(\nd\n \n=\n \nrc\n \n+\n \nr1\n)\n \n||\n \n(\nd\n \n=\n \nabs\n(\nrc\n-\nr1\n))\n\n        \nreturn\n \nInf\n\n    \nend\n\n    \n# Solve quadratic:\n\n    \na\n \n=\n \n(\nrc\n^\n2\n \n-\n \nr1\n^\n2\n \n+\n \nd\n^\n2\n)\n/\n2\nd\n\n    \nh\n \n=\n \nsqrt\n(\nrc\n^\n2\n \n-\n \na\n^\n2\n)\n\n    \n# Collision points (always 2):\n\n    \nI1\n \n=\n \nSVector\n{\n2\n,\n \nT\n}(\n\n    \npc\n[\n1\n]\n \n+\n \na\n*\n(\np1\n[\n1\n]\n \n-\n \npc\n[\n1\n])\n/\nd\n \n+\n \nh\n*\n(\np1\n[\n2\n]\n \n-\n \npc\n[\n2\n])\n/\nd\n,\n\n    \npc\n[\n2\n]\n \n+\n \na\n*\n(\np1\n[\n2\n]\n \n-\n \npc\n[\n2\n])\n/\nd\n \n-\n \nh\n*\n(\np1\n[\n1\n]\n \n-\n \npc\n[\n1\n])\n/\nd\n)\n\n    \nI2\n \n=\n \nSVector\n{\n2\n,\n \nT\n}(\n\n    \npc\n[\n1\n]\n \n+\n \na\n*\n(\np1\n[\n1\n]\n \n-\n \npc\n[\n1\n])\n/\nd\n \n-\n \nh\n*\n(\np1\n[\n2\n]\n \n-\n \npc\n[\n2\n])\n/\nd\n,\n\n    \npc\n[\n2\n]\n \n+\n \na\n*\n(\np1\n[\n2\n]\n \n-\n \npc\n[\n2\n])\n/\nd\n \n+\n \nh\n*\n(\np1\n[\n1\n]\n \n-\n \npc\n[\n1\n])\n/\nd\n)\n\n    \n# Only consider intersections on the \ncorrect\n side of Semicircle:\n\n    \nII\n \n=\n \nSVector\n{\n2\n,\nT\n}[]\n\n    \nif\n \ndot\n(\nI1\n-\no\n.\nc\n,\n \no\n.\nfacedir\n)\n \n \n0\n \n#intersection 1 is OUT\n\n        \npush!\n(\nII\n,\n \nI1\n)\n\n    \nend\n\n    \nif\n \ndot\n(\nI2\n-\no\n.\nc\n,\n \no\n.\nfacedir\n)\n \n \n0\n\n        \npush!\n(\nII\n,\n \nI2\n)\n\n    \nend\n\n    \nif\n \nlength\n(\nII\n)\n \n==\n \n0\n\n        \nreturn\n \nInf\n\n    \nend\n\n    \n# Calculate real time until intersection:\n\n    \n\u03b8\n \n=\n \nrealangle\n(\np\n,\n \no\n,\n \nII\n,\n \npc\n,\n \nrc\n)\n\n    \n# Collision time, equiv. to arc-length until collision point:\n\n    \nreturn\n \n\u03b8\n*\nrc\n\n\nend\n\n\n\n\n\n\nThen, we add swag by writing a method for \nplot_obstacle\n:\n\n\nArc\n \n=\n \nPyPlot\n.\nmatplotlib\n[\n:\npatches\n][\n:\nArc\n]\n\n\nfunction\n \nplot_obstacle\n(\nd\n::\nSemicircle\n;\n \nkwargs\n...\n)\n\n  \ntheta1\n \n=\n \natan2\n(\nd\n.\nfacedir\n[\n2\n],\n \nd\n.\nfacedir\n[\n1\n])\n*\n180\n/\n\u03c0\n \n+\n \n90\n\n  \ntheta2\n \n=\n \ntheta1\n \n+\n \n180\n\n  \ns1\n \n=\n \nArc\n(\nd\n.\nc\n,\n \n2\nd\n.\nr\n,\n \n2\nd\n.\nr\n,\n \ntheta1\n \n=\n \ntheta1\n,\n \ntheta2\n \n=\n \ntheta2\n,\n\n  \nedgecolor\n \n=\n \n(\n0\n,\n0.6\n,\n0\n),\n \nlinewidth\n \n=\n \n2.0\n,\n \nkwargs\n...\n)\n\n  \nPyPlot\n.\ngca\n()[\n:\nadd_artist\n](\ns1\n)\n\n  \nPyPlot\n.\nshow\n()\n\n\nend\n\n\n\n\n\n\n(this method is in the \n/plotting/obstacles.jl\n file and is loaded on-demand when \nusing PyPlot\n)\n\n\nFinally, we also add a method to the \narclength\n function, so that we can compute the \nboundarymap\n of billiards containing our new obstacle\n\n\nfunction\n \narclength\n(\npos\n,\n \no\n::\nSemicircle\n)\n\n    \n#project pos on open face\n\n    \nchrd\n \n=\n \nSVector\n{\n2\n}(\n-\no\n.\nfacedir\n[\n2\n],\n \no\n.\nfacedir\n[\n1\n])\n \n#tangent to open face\n\n    \nd\n \n=\n \n(\npos\n \n-\n \no\n.\nc\n)\n/\no\n.\nr\n\n    \nx\n \n=\n \ndot\n(\nd\n,\n \nchrd\n)\n\n    \nr\n \n=\n  \nacos\n(\nclamp\n(\nx\n,\n \n-\n1\n,\n \n1\n))\n*\no\n.\nr\n\n    \nreturn\n \nr\n\n\nend\n\n\n\n\n\n\nand we are done!", 
            "title": "Creating your own Obstacle"
        }, 
        {
            "location": "/tutorials/own_obstacle/#creating-your-own-obstacle-type", 
            "text": "In this tutorial we will go through the processes of creating a new obstacle type, a  Semicircle . This type is already used in the  billiard_bunimovich  and  billiard_mushroom  functions.   Everything uses  SVector{2}  Fields of  Particle s and  Obstacle s contain all their information in 2-dimensional static vectors from module  StaticArrays . This is important to keep in mind when extending new methods.", 
            "title": "Creating your own Obstacle Type"
        }, 
        {
            "location": "/tutorials/own_obstacle/#type-definition", 
            "text": "The first thing you have to do is make your new type a sub-type of  Obstacle{T}  (or any other abstract sub-type of it). We will do:  struct   Semicircle { T : AbstractFloat }   :   Circular { T }   #  : Obstacle{T} \n     c :: SVector { 2 , T }   # this MUST be a static vector \n     r :: T \n     facedir :: SVector { 2 , T }   # this MUST be a static vector \n     name :: String  end   c  is the center and  r  is the radius of the full circle.  facedir  is the direction which the semicircle is facing, which is also the direction of its \"open\" face.  name  is a final (mandatory) field that is there to easily identify which obstacle is which.  Notice that the  struct  must be parameterized by  T :AbstractFloat  (see the  numerical precision  page for more).  For convenience, I will also define:  function   Semicircle ( \n     c :: AbstractVector { T },   r :: Real ,   facedir ,   name   =   Semicircle )   where   { T : Real } \n     S   =   T   :   Integer   ?   Float64   :   T \n     return   Semicircle { S }( SVector { 2 , S }( c ),   convert ( S ,   abs ( r )),   name )  end   so that constructing a  Semicircle  is possible from arbitrary vectors.", 
            "title": "Type Definition"
        }, 
        {
            "location": "/tutorials/own_obstacle/#necessary-methods", 
            "text": "The following functions must obtain methods for  Semicircle  (or any other custom  Obstacle ) in order for it to work with  DynamicalBilliards :   normalvec  distance  (with arguments  (position, obstacle) )  collisiontime  with  Particle  Trivial  collisiontime  method with  MagneticParticle  that returns  error()  (see optional methods)   Assuming that upon collision a specular reflection happens, then you don't need to define a method for  resolvecollision! .  The first method is very simple, just do:  normalvec ( d :: Semicircle ,   pos )   =   normalize ( d . c   -   pos )   Since the function is only used during  distance  and  resolvecollision!  and since we will be writing explicit methods for the first, we don't have to care about what happens when the particle is far away from the boundary.  The  distance  method is a bit tricky. Since the type already subtypes  Circular , the following definition from  DynamicalBilliards  applies:  distance ( pos :: AbstractVector ,   d :: Circular )   =   norm ( pos   -   d . c )   -   d . r   However, the method must be expanded. That is because when the particle is on the \"open\" half of the disk, the distance is not correct. We write:  SV   =   SVector { 2 }   #convenience  function   distance ( pos :: AbstractVector { T },   s :: Semicircle { T })   where   { T } \n     # Check on which half of circle is the particle \n     v1   =   pos   .-   s . c \n     nn   =   dot ( v1 ,   s . facedir ) \n     if   nn   \u2264   0   # I am  inside semicircle \n         return   s . r   -   norm ( pos   -   s . c ) \n     else   # I am on the  other side \n         end1   =   SV ( s . c [ 1 ]   +   s . r * s . facedir [ 2 ],   s . c [ 2 ]   -   s . r * s . facedir [ 1 ]) \n         end2   =   SV ( s . c [ 1 ]   -   s . r * s . facedir [ 2 ],   s . c [ 2 ]   +   s . r * s . facedir [ 1 ]) \n         return   min ( norm ( pos   -   end1 ),   norm ( pos   -   end2 )) \n     end  end   Notice that this definition always returns positive distance when the particle is on the \"other side\".  Finally, the method for  collisiontime  is by far the most  trickiest . But, with pen, paper and a significant amount of patience, one can find a way:  function   collisiontime ( p :: Particle { T },   d :: Semicircle { T }) :: T   where   { T } \n\n     dc   =   p . pos   -   d . c \n     B   =   dot ( p . vel ,   dc )           #velocity towards circle center: B   0 \n     C   =   dot ( dc ,   dc )   -   d . r ^ 2      #being outside of circle: C   0 \n     \u0394   =   B ^ 2   -   C \n\n     \u0394   =   0     return   Inf \n     sqrtD   =   sqrt ( \u0394 ) \n\n     nn   =   dot ( dc ,   d . facedir ) \n     if   nn   \u2265   0   # I am NOT inside semicircle \n         # Return most positive time \n         t   =   - B   +   sqrtD \n     else   # I am inside semicircle: \n         # these lines make sure that the code works for ANY starting position: \n         t   =   - B   -   sqrtD \n         if   t   \u2264   0   ||   distance ( p ,   d )   \u2264   distancecheck ( T ) \n             t   =   - B   +   sqrtD \n         end \n     end \n     # This check is necessary to not collide with the non-existing side \n     newpos   =   p . pos   +   p . vel   .*   t \n     if   dot ( newpos   -   d . c ,   d . facedir )   \u2265   0   # collision point on BAD HALF; \n         return   Inf \n     end \n     # If collision time is negative, return Inf: \n     t   \u2264   0.0   ?   Inf   :   t  end   And that is all. The obstacle now works perfectly fine for straight propagation and properly initializes particles with  randominside !", 
            "title": "Necessary Methods"
        }, 
        {
            "location": "/tutorials/own_obstacle/#optional-methods", 
            "text": "collisiontime  with  MagneticParticle  : enables magnetic propagation  plot_obstacle  : enables plotting (used in  plot_billiard )  arclength  so that the  boundarymap  can be computed.   The  collisiontime  method for  MagneticParticle  is very easy in this case, because it is almost identical with the method for the general  Circular  obstacle:  function   collisiontime ( p :: MagneticParticle { T },   o :: Semicircle { T }) :: T   where   { T } \n     \u03c9   =   p . omega \n     pc ,   rc   =   cyclotron ( p ) \n     p1   =   o . c \n     r1   =   o . r \n     d   =   norm ( p1 - pc ) \n     if   ( d   =   rc   +   r1 )   ||   ( d   =   abs ( rc - r1 )) \n         return   Inf \n     end \n     # Solve quadratic: \n     a   =   ( rc ^ 2   -   r1 ^ 2   +   d ^ 2 ) / 2 d \n     h   =   sqrt ( rc ^ 2   -   a ^ 2 ) \n     # Collision points (always 2): \n     I1   =   SVector { 2 ,   T }( \n     pc [ 1 ]   +   a * ( p1 [ 1 ]   -   pc [ 1 ]) / d   +   h * ( p1 [ 2 ]   -   pc [ 2 ]) / d , \n     pc [ 2 ]   +   a * ( p1 [ 2 ]   -   pc [ 2 ]) / d   -   h * ( p1 [ 1 ]   -   pc [ 1 ]) / d ) \n     I2   =   SVector { 2 ,   T }( \n     pc [ 1 ]   +   a * ( p1 [ 1 ]   -   pc [ 1 ]) / d   -   h * ( p1 [ 2 ]   -   pc [ 2 ]) / d , \n     pc [ 2 ]   +   a * ( p1 [ 2 ]   -   pc [ 2 ]) / d   +   h * ( p1 [ 1 ]   -   pc [ 1 ]) / d ) \n     # Only consider intersections on the  correct  side of Semicircle: \n     II   =   SVector { 2 , T }[] \n     if   dot ( I1 - o . c ,   o . facedir )     0   #intersection 1 is OUT \n         push! ( II ,   I1 ) \n     end \n     if   dot ( I2 - o . c ,   o . facedir )     0 \n         push! ( II ,   I2 ) \n     end \n     if   length ( II )   ==   0 \n         return   Inf \n     end \n     # Calculate real time until intersection: \n     \u03b8   =   realangle ( p ,   o ,   II ,   pc ,   rc ) \n     # Collision time, equiv. to arc-length until collision point: \n     return   \u03b8 * rc  end   Then, we add swag by writing a method for  plot_obstacle :  Arc   =   PyPlot . matplotlib [ : patches ][ : Arc ]  function   plot_obstacle ( d :: Semicircle ;   kwargs ... ) \n   theta1   =   atan2 ( d . facedir [ 2 ],   d . facedir [ 1 ]) * 180 / \u03c0   +   90 \n   theta2   =   theta1   +   180 \n   s1   =   Arc ( d . c ,   2 d . r ,   2 d . r ,   theta1   =   theta1 ,   theta2   =   theta2 , \n   edgecolor   =   ( 0 , 0.6 , 0 ),   linewidth   =   2.0 ,   kwargs ... ) \n   PyPlot . gca ()[ : add_artist ]( s1 ) \n   PyPlot . show ()  end   (this method is in the  /plotting/obstacles.jl  file and is loaded on-demand when  using PyPlot )  Finally, we also add a method to the  arclength  function, so that we can compute the  boundarymap  of billiards containing our new obstacle  function   arclength ( pos ,   o :: Semicircle ) \n     #project pos on open face \n     chrd   =   SVector { 2 }( - o . facedir [ 2 ],   o . facedir [ 1 ])   #tangent to open face \n     d   =   ( pos   -   o . c ) / o . r \n     x   =   dot ( d ,   chrd ) \n     r   =    acos ( clamp ( x ,   - 1 ,   1 )) * o . r \n     return   r  end   and we are done!", 
            "title": "Optional Methods"
        }, 
        {
            "location": "/tutorials/examples/", 
            "text": "This section has some examples of usage of \nDynamicalBilliards\n, with some brief comments.\n\n\n\n\nJulia-logo Billiard\n\n\nThe \"Julia-logo\" billiard animation was made with:\n\n\nusing\n \nDynamicalBilliards\n,\n \nPyPlot\n\n\nfigure\n()\n\n\nbt\n \n=\n \nbilliard_rectangle\n()\n\n\n# Plot walls:\n\n\nfor\n \nw\n \nin\n \nbt\n\n  \nplot_obstacle\n(\nw\n;\n \ncolor\n \n=\n \n(\n0\n,\n0\n,\n0\n,\n \n1\n),\n \nlinewidth\n \n=\n \n3.0\n)\n\n\nend\n\n\n\n# Create and plot the 3 disks:\n\n\nr\n \n=\n \n0.165\n\n\newidth\n \n=\n \n6.0\n\n\nredcent\n \n=\n \n[\n0.28\n,\n \n0.32\n]\n\n\nred\n \n=\n \nDisk\n(\nredcent\n,\n \nr\n,\n \nred\n)\n\n\nplot_obstacle\n(\nred\n;\n \nedgecolor\n \n=\n \n(\n203\n/\n255\n,\n \n60\n/\n255\n,\n \n51\n/\n255\n),\n\n\nfacecolor\n \n=\n \n(\n213\n/\n255\n,\n \n99\n/\n255\n,\n \n92\n/\n255\n),\n \nlinewidth\n \n=\n \newidth\n)\n\n\n\npurple\n \n=\n \nDisk\n([\n1\n \n-\n \nredcent\n[\n1\n],\n \nredcent\n[\n2\n]],\n \nr\n,\n \npurple\n)\n\n\nplot_obstacle\n(\npurple\n;\n \nedgecolor\n \n=\n \n(\n149\n/\n255\n,\n \n88\n/\n255\n,\n \n178\n/\n255\n),\n\n\nfacecolor\n \n=\n \n(\n170\n/\n255\n,\n \n121\n/\n255\n,\n \n193\n/\n255\n),\n \nlinewidth\n \n=\n \newidth\n)\n\n\n\ngreen\n \n=\n \nDisk\n([\n0.5\n,\n \n1\n \n-\n \nredcent\n[\n2\n]],\n \nr\n,\n \ngreen\n)\n\n\nplot_obstacle\n(\ngreen\n,\n \nedgecolor\n \n=\n \n(\n56\n/\n255\n,\n \n152\n/\n255\n,\n \n38\n/\n255\n),\n\n\nfacecolor\n \n=\n \n(\n96\n/\n255\n,\n \n173\n/\n255\n,\n \n81\n/\n255\n),\n \nlinewidth\n \n=\n \newidth\n)\n\n\n\n# Create billiard\n\n\nbt\n \n=\n \nBilliard\n(\nbt\n.\nobstacles\n...\n,\n \nred\n,\n \npurple\n,\n \ngreen\n)\n\n\n\n# Set axis\n\n\naxis\n(\noff\n)\n\n\ntight_layout\n()\n\n\ngca\n()[\n:\nset_aspect\n](\nequal\n)\n\n\nxlim\n(\n-\n0.1\n,\n1.1\n)\n\n\nylim\n(\n-\n0.1\n,\n1.1\n)\n\n\n\n# Create a particle\n\n\np\n \n=\n \nrandominside\n(\nbt\n,\n \n2.0\n)\n\n\n# particle colors\n\n\ndarkblue\n \n=\n \n(\n64\n/\n255\n,\n \n99\n/\n255\n,\n \n216\n/\n255\n)\n\n\nlightblue\n \n=\n \n(\n102\n/\n255\n,\n \n130\n/\n255\n,\n \n223\n/\n255\n)\n\n\n\nokwargs\n \n=\n \nDict\n(\n:\nlinewidth\n \n=\n \n2.0\n,\n \n:\ncolor\n \n=\n \nlightblue\n)\n\n\npkwargs\n \n=\n \nDict\n(\n:\ncolor\n \n=\n \ndarkblue\n,\n \n:\ns\n \n=\n \n150.0\n)\n\n\n\n# create the animation:\n\n\nanimate_evolution\n(\np\n,\n \nbt\n,\n \n200\n;\n \ncol_to_plot\n \n=\n \n7\n,\n\n\nparticle_kwargs\n \n=\n \npkwargs\n,\n \norbit_kwargs\n \n=\n \nokwargs\n,\n \nnewfig\n \n=\n \nfalse\n)\n\n\n\n\n\n\nand produces:\n\n\n\n\n\n\nMean Free Path of the Lorentz Gas\n\n\nusing\n \nDynamicalBilliards\n\n\nbt\n \n=\n \nbilliard_lorentz\n(\n0.2\n)\n \n#alias for billiard_sinai(setting = \nperiodic\n)\n\n\nmfp\n \n=\n \n0.0\n\n\nfor\n \ni\n \nin\n \n1\n:\n1000\n\n  \np\n \n=\n \nrandominside\n(\nbt\n)\n\n  \nct\n,\n \nposs\n,\n \nvels\n \n=\n \nevolve!\n(\np\n,\n \nbt\n,\n \n10000.0\n)\n\n  \n#skip first two entries because they are not \nfull\n collisions:\n\n  \nmfp\n \n+=\n \nmean\n(\nct\n[\n3\n:\nend\n])\n\n\nend\n\n\nmfp\n \n/=\n \n1000\n\n\n\n\n\n\ngives the value of \n2.1899...\n which is very close to the analytic result:\n\n\n\\text{m.f.p.} =  \\frac{1-\\pi r^2 }{2r} \\stackrel{r=0.2}{=} 2.18584\n\\text{m.f.p.} =  \\frac{1-\\pi r^2 }{2r} \\stackrel{r=0.2}{=} 2.18584\n\n\nwhich you can find for example \nhere\n.\n\n\n\n\nSemi-Periodic Billiard\n\n\nDynamicalBilliards.jl\n allows for your system to be periodic in only some specific directions. For example, the following code produces a billiard that is periodic in only the x-direction:\n\n\nusing\n \nDynamicalBilliards\n\n\no\n \n=\n \n0.0\n;\n \nx\n \n=\n \n2.0\n;\n \ny\n=\n1.0\n\n\nbt\n \n=\n \nObstacle\n{\nFloat64\n}[]\n\n\n\nsp\n \n=\n \n[\no\n,\no\n];\n \nep\n \n=\n \n[\no\n,\n \ny\n];\n \nn\n \n=\n \n[\nx\n,\no\n]\n\n\nleftw\n \n=\n \nPeriodicWall\n(\nsp\n,\n \nep\n,\n \nn\n,\n \nLeft periodic boundary\n)\n\n\nsp\n \n=\n \n[\nx\n,\no\n];\n \nep\n \n=\n \n[\nx\n,\n \ny\n];\n \nn\n \n=\n \n[\n-\nx\n,\no\n]\n\n\nrightw\n \n=\n \nPeriodicWall\n(\nsp\n,\n \nep\n,\n \nn\n,\n \nRight periodic boundary\n)\n\n\n\nsp\n \n=\n \n[\no\n,\ny\n];\n \nep\n \n=\n \n[\nx\n,\n \ny\n];\n \nn\n \n=\n \n[\no\n,\n-\ny\n]\n\n\ntopw2\n \n=\n \nInfiniteWall\n(\nsp\n,\n \nep\n,\n \nn\n,\n \nTop wall\n)\n\n\nsp\n \n=\n \n[\no\n,\no\n];\n \nep\n \n=\n \n[\nx\n,\n \no\n];\n \nn\n \n=\n \n[\no\n,\ny\n]\n\n\nbotw2\n \n=\n \nInfiniteWall\n(\nsp\n,\n \nep\n,\n \nn\n,\n \nBottom wall\n)\n\n\npush!\n(\nbt\n,\n \nleftw\n,\n \nrightw\n,\n \ntopw2\n,\n \nbotw2\n)\n\n\n\nr\n \n=\n \n0.25\n\n\nd\n \n=\n \nDisk\n([\n0.5\n,\n \n0.5\n],\n \nr\n)\n\n\nd2\n \n=\n \nDisk\n([\n1.5\n,\n \n0.5\n],\n \nr\n/\n2\n)\n\n\npush!\n(\nbt\n,\n \nd\n,\n \nd2\n)\n\n\n\np\n \n=\n \nrandominside\n(\nbt\n,\n \n0.5\n)\n\n\nxt\n,\n \nyt\n,\n \nvxt\n,\n \nvyt\n,\n \nt\n \n=\n \nconstruct\n(\nevolve!\n(\np\n,\n \nbt\n,\n \n25\n)\n...\n)\n\n\nplot_billiard\n(\nbt\n,\n \nxt\n,\n \nyt\n)\n\n\nplot_particle\n(\np\n)\n\n\n\n\n\n\nResult:\n\n\n\n\n\n\nRay-Splitting\n\n\nThe following code produces an animation of a Ray-Splitting billiard:\n\n\nusing\n \nDynamicalBilliards\n,\n \nPyPlot\n\n\n\nbt\n \n=\n \nbilliard_rectangle\n(\n2\n,\n \n1\n)\n\n\nsw\n \n=\n \nSplitterWall\n([\n1.0\n,\n \n0.0\n],\n \n[\n1\n,\n1\n],\n \n[\n-\n1\n,\n0\n],\n \ntrue\n)\n\n\npush!\n(\nbt\n,\n \nsw\n)\n\n\na1\n \n=\n \nAntidot\n([\n0.5\n,\n \n0.5\n],\n \n0.3\n)\n\n\npush!\n(\nbt\n,\n \na1\n)\n\n\na2\n \n=\n \nAntidot\n([\n1.5\n,\n \n0.5\n],\n \n0.2\n)\n\n\npush!\n(\nbt\n,\n \na2\n)\n\n\n\nsa\n \n=\n \n(\n\u03b8\n,\n \nwhere\n,\n \n\u03c9\n)\n \n-\n \nwhere\n \n?\n \n1.25\n*\n\u03b8\n \n:\n \n0.8\n*\n\u03b8\n\n\nTp\n \n=\n \n(\np\n)\n \n-\n \n(\n\u03b8\n,\n \nwhere\n,\n \n\u03c9\n)\n \n-\n \nbegin\n\n  \nif\n \nwhere\n\n    \nabs\n(\n\u03b8\n)\n \n \n\u03c0\n/\n2\n/\n1.25\n \n?\n \np\n*\nexp\n(\n-\n(\n\u03b8\n)\n^\n2\n/\n2\n(\n\u03c0\n/\n8\n)\n^\n2\n)\n \n:\n \n0.0\n\n  \nelse\n\n    \n(\np\n)\n*\nexp\n(\n-\n(\n\u03b8\n)\n^\n2\n/\n2\n(\n\u03c0\n/\n4\n)\n^\n2\n)\n\n  \nend\n\n\nend\n\n\nnewo\n \n=\n \n((\nx\n,\n \nbool\n)\n \n-\n \nbool\n \n?\n \n-\n2.0\nx\n \n:\n \n-\n0.5\nx\n)\n\n\nnewo2\n \n=\n \n((\nx\n,\n \nbool\n)\n \n-\n \nbool\n \n?\n \n-\nx\n \n:\n \n-\nx\n)\n\n\nrayspl\n \n=\n \nDict\n(\n\n\n5\n \n=\n \n(\nTp\n(\n0.9\n),\n \nsa\n,\n \nnewo2\n),\n\n\n6\n \n=\n \n(\nTp\n(\n0.7\n),\n \nsa\n,\n \nnewo\n),\n\n\n7\n \n=\n \n(\nTp\n(\n0.65\n),\n \nsa\n,\n \nnewo\n))\n\n\n\np\n \n=\n \nrandominside\n(\nbt\n,\n \n1.0\n)\n\n\nplot_billiard\n(\nbt\n)\n\n\n\nsavedir\n \n=\n \nC:\n\\\\\n***\n\\\\\nanim\n\n\nanimate_evolution\n(\np\n,\n \nbt\n,\n \n200\n,\n \nrayspl\n,\n \nsavefigs\n \n=\n \ntrue\n,\n \nsavename\n \n=\n \nsavedir\n)\n\n\n\n\n\n\nresult:", 
            "title": "Examples"
        }, 
        {
            "location": "/tutorials/examples/#julia-logo-billiard", 
            "text": "The \"Julia-logo\" billiard animation was made with:  using   DynamicalBilliards ,   PyPlot  figure ()  bt   =   billiard_rectangle ()  # Plot walls:  for   w   in   bt \n   plot_obstacle ( w ;   color   =   ( 0 , 0 , 0 ,   1 ),   linewidth   =   3.0 )  end  # Create and plot the 3 disks:  r   =   0.165  ewidth   =   6.0  redcent   =   [ 0.28 ,   0.32 ]  red   =   Disk ( redcent ,   r ,   red )  plot_obstacle ( red ;   edgecolor   =   ( 203 / 255 ,   60 / 255 ,   51 / 255 ),  facecolor   =   ( 213 / 255 ,   99 / 255 ,   92 / 255 ),   linewidth   =   ewidth )  purple   =   Disk ([ 1   -   redcent [ 1 ],   redcent [ 2 ]],   r ,   purple )  plot_obstacle ( purple ;   edgecolor   =   ( 149 / 255 ,   88 / 255 ,   178 / 255 ),  facecolor   =   ( 170 / 255 ,   121 / 255 ,   193 / 255 ),   linewidth   =   ewidth )  green   =   Disk ([ 0.5 ,   1   -   redcent [ 2 ]],   r ,   green )  plot_obstacle ( green ,   edgecolor   =   ( 56 / 255 ,   152 / 255 ,   38 / 255 ),  facecolor   =   ( 96 / 255 ,   173 / 255 ,   81 / 255 ),   linewidth   =   ewidth )  # Create billiard  bt   =   Billiard ( bt . obstacles ... ,   red ,   purple ,   green )  # Set axis  axis ( off )  tight_layout ()  gca ()[ : set_aspect ]( equal )  xlim ( - 0.1 , 1.1 )  ylim ( - 0.1 , 1.1 )  # Create a particle  p   =   randominside ( bt ,   2.0 )  # particle colors  darkblue   =   ( 64 / 255 ,   99 / 255 ,   216 / 255 )  lightblue   =   ( 102 / 255 ,   130 / 255 ,   223 / 255 )  okwargs   =   Dict ( : linewidth   =   2.0 ,   : color   =   lightblue )  pkwargs   =   Dict ( : color   =   darkblue ,   : s   =   150.0 )  # create the animation:  animate_evolution ( p ,   bt ,   200 ;   col_to_plot   =   7 ,  particle_kwargs   =   pkwargs ,   orbit_kwargs   =   okwargs ,   newfig   =   false )   and produces:", 
            "title": "Julia-logo Billiard"
        }, 
        {
            "location": "/tutorials/examples/#mean-free-path-of-the-lorentz-gas", 
            "text": "using   DynamicalBilliards  bt   =   billiard_lorentz ( 0.2 )   #alias for billiard_sinai(setting =  periodic )  mfp   =   0.0  for   i   in   1 : 1000 \n   p   =   randominside ( bt ) \n   ct ,   poss ,   vels   =   evolve! ( p ,   bt ,   10000.0 ) \n   #skip first two entries because they are not  full  collisions: \n   mfp   +=   mean ( ct [ 3 : end ])  end  mfp   /=   1000   gives the value of  2.1899...  which is very close to the analytic result:  \\text{m.f.p.} =  \\frac{1-\\pi r^2 }{2r} \\stackrel{r=0.2}{=} 2.18584 \\text{m.f.p.} =  \\frac{1-\\pi r^2 }{2r} \\stackrel{r=0.2}{=} 2.18584  which you can find for example  here .", 
            "title": "Mean Free Path of the Lorentz Gas"
        }, 
        {
            "location": "/tutorials/examples/#semi-periodic-billiard", 
            "text": "DynamicalBilliards.jl  allows for your system to be periodic in only some specific directions. For example, the following code produces a billiard that is periodic in only the x-direction:  using   DynamicalBilliards  o   =   0.0 ;   x   =   2.0 ;   y = 1.0  bt   =   Obstacle { Float64 }[]  sp   =   [ o , o ];   ep   =   [ o ,   y ];   n   =   [ x , o ]  leftw   =   PeriodicWall ( sp ,   ep ,   n ,   Left periodic boundary )  sp   =   [ x , o ];   ep   =   [ x ,   y ];   n   =   [ - x , o ]  rightw   =   PeriodicWall ( sp ,   ep ,   n ,   Right periodic boundary )  sp   =   [ o , y ];   ep   =   [ x ,   y ];   n   =   [ o , - y ]  topw2   =   InfiniteWall ( sp ,   ep ,   n ,   Top wall )  sp   =   [ o , o ];   ep   =   [ x ,   o ];   n   =   [ o , y ]  botw2   =   InfiniteWall ( sp ,   ep ,   n ,   Bottom wall )  push! ( bt ,   leftw ,   rightw ,   topw2 ,   botw2 )  r   =   0.25  d   =   Disk ([ 0.5 ,   0.5 ],   r )  d2   =   Disk ([ 1.5 ,   0.5 ],   r / 2 )  push! ( bt ,   d ,   d2 )  p   =   randominside ( bt ,   0.5 )  xt ,   yt ,   vxt ,   vyt ,   t   =   construct ( evolve! ( p ,   bt ,   25 ) ... )  plot_billiard ( bt ,   xt ,   yt )  plot_particle ( p )   Result:", 
            "title": "Semi-Periodic Billiard"
        }, 
        {
            "location": "/tutorials/examples/#ray-splitting", 
            "text": "The following code produces an animation of a Ray-Splitting billiard:  using   DynamicalBilliards ,   PyPlot  bt   =   billiard_rectangle ( 2 ,   1 )  sw   =   SplitterWall ([ 1.0 ,   0.0 ],   [ 1 , 1 ],   [ - 1 , 0 ],   true )  push! ( bt ,   sw )  a1   =   Antidot ([ 0.5 ,   0.5 ],   0.3 )  push! ( bt ,   a1 )  a2   =   Antidot ([ 1.5 ,   0.5 ],   0.2 )  push! ( bt ,   a2 )  sa   =   ( \u03b8 ,   where ,   \u03c9 )   -   where   ?   1.25 * \u03b8   :   0.8 * \u03b8  Tp   =   ( p )   -   ( \u03b8 ,   where ,   \u03c9 )   -   begin \n   if   where \n     abs ( \u03b8 )     \u03c0 / 2 / 1.25   ?   p * exp ( - ( \u03b8 ) ^ 2 / 2 ( \u03c0 / 8 ) ^ 2 )   :   0.0 \n   else \n     ( p ) * exp ( - ( \u03b8 ) ^ 2 / 2 ( \u03c0 / 4 ) ^ 2 ) \n   end  end  newo   =   (( x ,   bool )   -   bool   ?   - 2.0 x   :   - 0.5 x )  newo2   =   (( x ,   bool )   -   bool   ?   - x   :   - x )  rayspl   =   Dict (  5   =   ( Tp ( 0.9 ),   sa ,   newo2 ),  6   =   ( Tp ( 0.7 ),   sa ,   newo ),  7   =   ( Tp ( 0.65 ),   sa ,   newo ))  p   =   randominside ( bt ,   1.0 )  plot_billiard ( bt )  savedir   =   C: \\\\ *** \\\\ anim  animate_evolution ( p ,   bt ,   200 ,   rayspl ,   savefigs   =   true ,   savename   =   savedir )   result:", 
            "title": "Ray-Splitting"
        }, 
        {
            "location": "/physics/", 
            "text": "This page briefly discusses physical aspects of billiard systems.\n\n\n\n\nNumerical Precision\n\n\nAll core types of \nDynamicalBilliards.jl\n are parametrically constructed, with parameter \nT\n:AbstractFloat\n. This means that the fields of all particles and obstacles contain numbers strictly of type \nT\n. You will understand why this choice happened as you continue reading this paragraph.\n\n\nThe main concerns during evolution in a billiard table are:\n\n\n\n\nThe particle must never leak out of the billiard table. This is simply translated to the \ndistance()\n function being \nalways\n positive \nafter\n any collision.\n\n\nThe collision time is never infinite, besides the cases of \npinned particles\n in a magnetic billiard.\n\n\nThe \nrelocate!()\n process is always finite (and very swift!).\n\n\n\n\nThese are solved with the following approach: after the minimum collision time has been calculated, a \"test propagation\" is done on the position of the particle. If the \ndistance(p, obst)\n with the colliding obstacle is found to be \"wrong\", the collision time is reduced by the \nDynamicalBilliards.timeprec(T)\n function, with \nT\n being the parametric type of both the particle and the obstacle. This reduction happens geometrically, i.e. the time adjusting increment is self-multiplied by 10 at each recursive relocating step.\n\n\n\n\nMagnetic propagation and straight propagation both use \ntimeprec(T)\n. For both cases the maximum number of geometric iterations is 1 (for the default value of \ntimeprec(T)\n.\n\n\n\n\nThis \ntimeprec\n cannot be used with \nPeriodicWall\n and RaySplitting obstacles with \nMagneticParticle\ns because when relocating forward in time you get progressively shallower and shallower angles. This mean that you need huge changes in time for even tiny changes in \ndistance\n.\n\n\n\n\nFor this special case the function \ntimeprec_forward(T)\n is used instead. This function results to on average 3-5 geometric relocation steps.\n\n\n\n\n\n\n\n\nThe current definition of these functions is:\n\n\ntimeprec\n(\n::\nType\n{\nT\n})\n \nwhere\n \n{\nT\n}\n \n=\n \neps\n(\nT\n)\n^\n(\n4\n/\n5\n)\n\n\ntimeprec_forward\n(\n::\nType\n{\nT\n})\n \nwhere\n \n{\nT\n}\n \n=\n \neps\n(\nT\n)\n^\n(\n3\n/\n4\n)\n\n\ntimeprec_forward\n(\n::\nType\n{\nBigFloat\n})\n \n=\n \nBigFloat\n(\n1e-12\n)\n\n\n\n\n\n\nAdjusting the global precision of \nDynamicalBilliards\n is very easy and can be done in two ways:\n\n\n\n\nChoose the floating precision you would like, by initializing your billiard table with parametric type \nT\n, e.g. \nbt = billiard_sinai(Float16(0.3))\n. This choice will propagate to the entire \nbt\n, all particles resulting from \nrandominside()\n, \nas well as the entire evolution process\n.\n\n\nRe-define the functions \ntimeprec(T)\n and \ntimeprec_forward(T)\n. Decreasing their values will make the evolution process slower, but the resulting numbers given by \nevolve!()\n will be more precise. There are no guarantees if you follow this method as it may lead to breaking code if \ntimeprec_forward\n becomes too small.\n\n\n\n\n\n\nBigFloats\n\n\nEvolution with \nBigFloat\n in \nDynamicalBilliards\n is on average 3 to 4 orders of magnitude slower than with \nFloat64\n.\n\n\n\n\n\n\n\n\nRay-Splitting Functions\n\n\nIf \nT\n is the transmission probability function, then the condition for transmission is simply: \nT(\u03c6, pflag, \u03c9) \n rand()\n. If it returns \ntrue\n, transmission (i.e. ray-splitting) will happen. As it has already been discussed in the \nRay-Splitting tutorial\n, the condition of total internal reflection must be taken care of by the user.\n\n\nThe \nthree key functions\n given to the \nray-splitter\n dictionary must have some properties in order to have physical meaning, like for example that the scattering probability function is even towards \u03c6. One of these properties is absolutely \nmandatory\n for this package to work properly. This is the property of total internal reflection, i.e. if the refraction angle is calculated to be greater/equal than \u03c0/2, no transmission can happen. \nThis condition is not assured internally\n and therefore you must be sure that your transmission probability function satisfies it. In the above example, the function \nT\n makes sure to return 0 in that case.\n\n\nIn order to test if the \nraysplitter\n dictionary you have defined has physical meaning, the function \nisphysical()\n is provided:\n\n\nisphysical\n(\nraysplitter\n::\nDict\n{\nInt\n,\n \nAny\n};\n \nonly_mandatory\n \n=\n \nfalse\n)\n\n\n\n\n\n\nReturn \ntrue\n if the given ray-splitting dictionary has physically plausible properties.\n\n\nSpecifically, check if (\u03c6 is the incidence angle, \u03b8 the refraction angle):\n\n\n\n\nCritical angle means total reflection: If \u03b8(\u03c6) \u2265 \u03c0/2 then T(\u03c6) = 0\n\n\nTransmission probability is even function: T(\u03c6) \u2248 T(-\u03c6) at \u03c9 = 0\n\n\nRefraction angle is odd function: \u03b8(\u03c6) \u2248 -\u03b8(-\u03c6) at \u03c9 = 0\n\n\nRay reversal is true: \u03b8(\u03b8(\u03c6, pflag, \u03c9), !pflag, \u03c9) \u2248 \u03c6\n\n\nMagnetic conservation is true: (\u03c9_new(\u03c9_new(\u03c9, pflag), !pflag) \u2248 \u03c9\n\n\n\n\nThe first property is mandatory and must hold for correct propagation. The above tests are done for all possible combinations of arguments.\n\n\nThey keyword \nonly_mandatory\n notes whether the rest of the properties should be tested or not.\n\n\n\n\n\n\nPinned Particles\n\n\nIn the case of propagation with magnetic field, a particle may be \"pinned\" (collision-less): There are no possible collisions that take place and the particle will revolve in circles forever. This can happen for specific initial conditions depending on your billiard table and the angular velocity \u03c9.\n\n\nIn such event, the convention followed by \nDynamicalBilliards\n is the following: \nevolve!()\n returns the expected output, however all returned vectors have only 2 entries. The collision times always have the entries \n0.0, Inf\n. All other returned vectors have the initial conditions, repeated once.\n\n\nevolve!()\n can be given an additional \nwarning\n keyword argument in the case of magnetic propagation, e.g. \nwarning = true\n. This optional argument throws a \nwarn()\n message whenever a pinned particle is evolved.\n\n\n\n\nUsing \nconstruct()\n\n\nWhen using the syntax \nconstruct(evolve!(p, bt, t)...)\n be sure that there aren't any pinned particles given to evolve. If there are any, construct will result in an error.\n\n\n\n\n\n\n\n\nVelocity measure\n\n\nBoth \nParticle\n and \nMagneticParticle\n are assumed to \nalways\n have a velocity vector of measure 1 during evolution. This simplifies the formulas used internally to a significant amount.\n\n\nHowever, during ray-splitting, the a \nMagneticParticle\n may be in areas with different angular velocities (result of the \n\u03c9_new\n function). Physically, in such a situation, the velocity measure of the particle could also change. This change depends on the forces acting on the particle (e.g. magnetic field) as well as the relation of the momentum with the velocity (functional type of kinetic energy).\n\n\nIn any case, such a change is not accounted for internally by \nDynamicalBilliards\n. However it is very easy to implement this by \"re-normalizing\" the angular velocities you use. Since the \"code\" velocity has measure one, the rotation radius is given by\n\n\n\n\n\nr = \\frac{1}{\\omega_\\text{code}} = \\frac{v_\\text{real}}{\\omega_\\text{real}}\n\n\n\n\nr = \\frac{1}{\\omega_\\text{code}} = \\frac{v_\\text{real}}{\\omega_\\text{real}}\n\n\n\n\n\nthen one simply has to adjust the values of \n\u03c9\n given in the code with\n\n\n\n\n\n\\omega_\\text{code} = \\frac{\\omega_\\text{real}}{v_\\text{real}}\n\n\n\n\n\\omega_\\text{code} = \\frac{\\omega_\\text{real}}{v_\\text{real}}\n\n\n\n\n\nAfter getting the timeseries from \nconstruct()\n:\n\n\n# These are the \ncode\n-data. |v| = 1 always\n\n\nct\n,\n \nposs\n,\n \nvels\n,\n \nomegas\n \n=\n \nevolve!\n(\np\n,\n \nbt\n,\n \nttotal\n,\n \nray_splt\n)\n\n\nxt\n,\n \nyt\n,\n \nvxt\n,\n \nvyt\n,\n \nt\n \n=\n \nconstruct\n(\nct\n,\n \nposs\n,\n \nvels\n,\n \nomegas\n)\n\n\n\n\n\n\nyou only need to make some final adjustment on the \nvxt, vyt\n. The position and time data are completely unaffected.\n\n\nomegas_code\n \n=\n \nomegas\n\n\n# real angular velocities:\n\n\nomegas_real\n \n=\n \nsupplied_by_user\n\n\n# or with some user provided function:\n\n\nf\n \n=\n \no\n \n-\n \n(\no\n \n==\n \n0.5\n \n?\n \n2\no\n \n:\n \no\n*\u221a\n2\n)\n\n\nomegas_real\n \n=\n \nf\n.\n(\nomegas_code\n)\n\n\n# real velocity measure:\n\n\nvels_real\n \n=\n \nabs\n.\n(\nomegas_real\n \n./\n \nomegas_code\n)\n\n\n\ncontt\n \n=\n \ncumsum\n(\nct\n)\n\n\nomega_t\n \n=\n \nzeros\n(\nt\n)\n\n\nvxtreal\n \n=\n \ncopy\n(\nvxt\n)\n\n\nvytreal\n \n=\n \ncopy\n(\nvyt\n)\n\n\nj\n \n=\n \n1\n\n\nfor\n \ni\n \nin\n \neachindex\n(\nt\n)\n\n  \nvxtreal\n[\ni\n]\n \n*=\n \nvels_real\n[\nj\n]\n\n  \nvytreal\n[\ni\n]\n \n*=\n \nvels_real\n[\nj\n]\n\n  \nomega_t\n[\ni\n]\n \n=\n \nomegas_real\n[\nj\n]\n\n\n  \nif\n \nt\n[\ni\n]\n \n=\n  \ncontt\n[\nj\n]\n\n    \nj\n \n+=\n \n1\n\n  \nend\n\n\nend\n\n\n\n\n\n\nNow you can be sure that the particle at time \nt[i]\n had real velocity \n[vxtreal[i], vytreal[i]]\n and was propagating with real angular velocity \nomega_t[i]\n.", 
            "title": "Physics"
        }, 
        {
            "location": "/physics/#numerical-precision", 
            "text": "All core types of  DynamicalBilliards.jl  are parametrically constructed, with parameter  T :AbstractFloat . This means that the fields of all particles and obstacles contain numbers strictly of type  T . You will understand why this choice happened as you continue reading this paragraph.  The main concerns during evolution in a billiard table are:   The particle must never leak out of the billiard table. This is simply translated to the  distance()  function being  always  positive  after  any collision.  The collision time is never infinite, besides the cases of  pinned particles  in a magnetic billiard.  The  relocate!()  process is always finite (and very swift!).   These are solved with the following approach: after the minimum collision time has been calculated, a \"test propagation\" is done on the position of the particle. If the  distance(p, obst)  with the colliding obstacle is found to be \"wrong\", the collision time is reduced by the  DynamicalBilliards.timeprec(T)  function, with  T  being the parametric type of both the particle and the obstacle. This reduction happens geometrically, i.e. the time adjusting increment is self-multiplied by 10 at each recursive relocating step.   Magnetic propagation and straight propagation both use  timeprec(T) . For both cases the maximum number of geometric iterations is 1 (for the default value of  timeprec(T) .   This  timeprec  cannot be used with  PeriodicWall  and RaySplitting obstacles with  MagneticParticle s because when relocating forward in time you get progressively shallower and shallower angles. This mean that you need huge changes in time for even tiny changes in  distance .   For this special case the function  timeprec_forward(T)  is used instead. This function results to on average 3-5 geometric relocation steps.     The current definition of these functions is:  timeprec ( :: Type { T })   where   { T }   =   eps ( T ) ^ ( 4 / 5 )  timeprec_forward ( :: Type { T })   where   { T }   =   eps ( T ) ^ ( 3 / 4 )  timeprec_forward ( :: Type { BigFloat })   =   BigFloat ( 1e-12 )   Adjusting the global precision of  DynamicalBilliards  is very easy and can be done in two ways:   Choose the floating precision you would like, by initializing your billiard table with parametric type  T , e.g.  bt = billiard_sinai(Float16(0.3)) . This choice will propagate to the entire  bt , all particles resulting from  randominside() ,  as well as the entire evolution process .  Re-define the functions  timeprec(T)  and  timeprec_forward(T) . Decreasing their values will make the evolution process slower, but the resulting numbers given by  evolve!()  will be more precise. There are no guarantees if you follow this method as it may lead to breaking code if  timeprec_forward  becomes too small.    BigFloats  Evolution with  BigFloat  in  DynamicalBilliards  is on average 3 to 4 orders of magnitude slower than with  Float64 .", 
            "title": "Numerical Precision"
        }, 
        {
            "location": "/physics/#ray-splitting-functions", 
            "text": "If  T  is the transmission probability function, then the condition for transmission is simply:  T(\u03c6, pflag, \u03c9)   rand() . If it returns  true , transmission (i.e. ray-splitting) will happen. As it has already been discussed in the  Ray-Splitting tutorial , the condition of total internal reflection must be taken care of by the user.  The  three key functions  given to the  ray-splitter  dictionary must have some properties in order to have physical meaning, like for example that the scattering probability function is even towards \u03c6. One of these properties is absolutely  mandatory  for this package to work properly. This is the property of total internal reflection, i.e. if the refraction angle is calculated to be greater/equal than \u03c0/2, no transmission can happen.  This condition is not assured internally  and therefore you must be sure that your transmission probability function satisfies it. In the above example, the function  T  makes sure to return 0 in that case.  In order to test if the  raysplitter  dictionary you have defined has physical meaning, the function  isphysical()  is provided:  isphysical ( raysplitter :: Dict { Int ,   Any };   only_mandatory   =   false )   Return  true  if the given ray-splitting dictionary has physically plausible properties.  Specifically, check if (\u03c6 is the incidence angle, \u03b8 the refraction angle):   Critical angle means total reflection: If \u03b8(\u03c6) \u2265 \u03c0/2 then T(\u03c6) = 0  Transmission probability is even function: T(\u03c6) \u2248 T(-\u03c6) at \u03c9 = 0  Refraction angle is odd function: \u03b8(\u03c6) \u2248 -\u03b8(-\u03c6) at \u03c9 = 0  Ray reversal is true: \u03b8(\u03b8(\u03c6, pflag, \u03c9), !pflag, \u03c9) \u2248 \u03c6  Magnetic conservation is true: (\u03c9_new(\u03c9_new(\u03c9, pflag), !pflag) \u2248 \u03c9   The first property is mandatory and must hold for correct propagation. The above tests are done for all possible combinations of arguments.  They keyword  only_mandatory  notes whether the rest of the properties should be tested or not.", 
            "title": "Ray-Splitting Functions"
        }, 
        {
            "location": "/physics/#pinned-particles", 
            "text": "In the case of propagation with magnetic field, a particle may be \"pinned\" (collision-less): There are no possible collisions that take place and the particle will revolve in circles forever. This can happen for specific initial conditions depending on your billiard table and the angular velocity \u03c9.  In such event, the convention followed by  DynamicalBilliards  is the following:  evolve!()  returns the expected output, however all returned vectors have only 2 entries. The collision times always have the entries  0.0, Inf . All other returned vectors have the initial conditions, repeated once.  evolve!()  can be given an additional  warning  keyword argument in the case of magnetic propagation, e.g.  warning = true . This optional argument throws a  warn()  message whenever a pinned particle is evolved.   Using  construct()  When using the syntax  construct(evolve!(p, bt, t)...)  be sure that there aren't any pinned particles given to evolve. If there are any, construct will result in an error.", 
            "title": "Pinned Particles"
        }, 
        {
            "location": "/physics/#velocity-measure", 
            "text": "Both  Particle  and  MagneticParticle  are assumed to  always  have a velocity vector of measure 1 during evolution. This simplifies the formulas used internally to a significant amount.  However, during ray-splitting, the a  MagneticParticle  may be in areas with different angular velocities (result of the  \u03c9_new  function). Physically, in such a situation, the velocity measure of the particle could also change. This change depends on the forces acting on the particle (e.g. magnetic field) as well as the relation of the momentum with the velocity (functional type of kinetic energy).  In any case, such a change is not accounted for internally by  DynamicalBilliards . However it is very easy to implement this by \"re-normalizing\" the angular velocities you use. Since the \"code\" velocity has measure one, the rotation radius is given by   \nr = \\frac{1}{\\omega_\\text{code}} = \\frac{v_\\text{real}}{\\omega_\\text{real}}  \nr = \\frac{1}{\\omega_\\text{code}} = \\frac{v_\\text{real}}{\\omega_\\text{real}}   then one simply has to adjust the values of  \u03c9  given in the code with   \n\\omega_\\text{code} = \\frac{\\omega_\\text{real}}{v_\\text{real}}  \n\\omega_\\text{code} = \\frac{\\omega_\\text{real}}{v_\\text{real}}   After getting the timeseries from  construct() :  # These are the  code -data. |v| = 1 always  ct ,   poss ,   vels ,   omegas   =   evolve! ( p ,   bt ,   ttotal ,   ray_splt )  xt ,   yt ,   vxt ,   vyt ,   t   =   construct ( ct ,   poss ,   vels ,   omegas )   you only need to make some final adjustment on the  vxt, vyt . The position and time data are completely unaffected.  omegas_code   =   omegas  # real angular velocities:  omegas_real   =   supplied_by_user  # or with some user provided function:  f   =   o   -   ( o   ==   0.5   ?   2 o   :   o *\u221a 2 )  omegas_real   =   f . ( omegas_code )  # real velocity measure:  vels_real   =   abs . ( omegas_real   ./   omegas_code )  contt   =   cumsum ( ct )  omega_t   =   zeros ( t )  vxtreal   =   copy ( vxt )  vytreal   =   copy ( vyt )  j   =   1  for   i   in   eachindex ( t ) \n   vxtreal [ i ]   *=   vels_real [ j ] \n   vytreal [ i ]   *=   vels_real [ j ] \n   omega_t [ i ]   =   omegas_real [ j ] \n\n   if   t [ i ]   =    contt [ j ] \n     j   +=   1 \n   end  end   Now you can be sure that the particle at time  t[i]  had real velocity  [vxtreal[i], vytreal[i]]  and was propagating with real angular velocity  omega_t[i] .", 
            "title": "Velocity measure"
        }, 
        {
            "location": "/lyapunovs/", 
            "text": "The Finite Time Lyapunov Spectrum (FTLS) for a 2D billiard system consists of a set of 4 numbers \n\\lambda_i \\, , \\{ i = 1, ...,4 \\}\n\\lambda_i \\, , \\{ i = 1, ...,4 \\}\n that characterize the chaoticity of the billiard. They depend on the initial condition and the total time of integration.\n\n\nIt can be shown theoretically that two of these exponents must be zero (\n\\lambda_2\n\\lambda_2\n =\n\\lambda_3\n\\lambda_3\n = 0) and the other two are paired in such a way that they sum up to zero, i.e. \n\\lambda_1 =  -\\lambda_4\n\\lambda_1 =  -\\lambda_4\n).\n\n\nThe function provided to calculate the FTLS is\n\n\nlyapunovspectrum!\n(\np\n::\nParticle\n,\n \nbt\n::\nVector\n{\nObstacle\n},\n \nt\n)\n\n\n\n\n\n\nand it returns an array with the 4 lyapunov exponents. Currently it is available only for \nParticle\n.\n\n\nHere its basic use is illustrated\n\n\nusing\n \nDynamicalBilliards\n\n\n\nradius\n \n=\n \n1.0\n\n\nl\n \n=\n \n2.0\n\n\n\nbt\n \n=\n \nbilliard_polygon\n(\n6\n,\n \nl\n;\n \nsetting\n \n=\n \nperiodic\n)\n\n\ndisc\n \n=\n \nDisk\n([\n0.\n,\n \n0.\n],\n \nradius\n)\n\n\npush!\n(\nbt\n,\n \ndisc\n)\n\n\n\np\n \n=\n \nrandominside\n(\nbt\n)\n\n\nt\n \n=\n \n1000.0\n\n\n\nexps\n \n=\n \nlyapunovspectrum\n(\np\n,\n \nbt\n,\n \nt\n)\n\n\n\n\n\n\nThe following code is for a family of polygonal billiards (hexagonal unit cell) parameterized by the space between the disks.\n\n\nusing\n \nDynamicalBilliards\n\n\nusing\n \nPyPlot\n\n\n\nt\n \n=\n \n5000.0\n\n\nradius\n \n=\n \n1.0\n\n\n\nspaces\n \n=\n \n2.0\n:\n0.1\n:\n4.4\n \n#Distances between adjacent disks\n\n\nlyap_time\n \n=\n \nzeros\n(\nspaces\n)\n \n#Array where the exponents will be stored\n\n\n\ni\n \n=\n \n1\n\n\nfor\n \nspace\n \nin\n \nspaces\n\n    \nbt\n \n=\n \nbilliard_polygon\n(\n6\n,\n \nspace\n/\n(\nsqrt\n(\n3\n));\n \nsetting\n \n=\n \nperiodic\n)\n\n    \ndisc\n \n=\n \nDisk\n([\n0.\n,\n \n0.\n],\n \nradius\n)\n\n    \npush!\n(\nbt\n,\n \ndisc\n)\n\n    \np\n \n=\n \nrandominside\n(\nbt\n)\n\n    \nexps\n \n=\n \nlyapunovspectrum\n(\np\n,\n \nbt\n,\n \nt\n)\n\n    \nlyap_time\n[\ni\n]\n \n=\n \nexps\n[\n1\n]\n\n    \ni\n+=\n1\n\n\nend\n\n\n\nplot\n(\nspaces\n,\n \nlyap_time\n,\n \n*-\n)\n\n\n\n\n\n\nThe plot of the maximum exponent is displayed below and it can be compared with the results reported by \nGaspard et. al\n (see figure 7, also displayed below) for the average over an ensemble.", 
            "title": "Lyapunov Exponents"
        }
    ]
}