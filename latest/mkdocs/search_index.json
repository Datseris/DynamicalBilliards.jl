{
    "docs": [
        {
            "location": "/", 
            "text": "DynamicalBilliards.jl\n is an easy-to-use, modular and extendable Julia package for Dynamical Billiard systems in two dimensions.\n\n\n\n\nLogo billiard\n\n\nCheckout the \nJulia billiard animation\n code to see how to create the animated billiard of our logo.\n\n\n\n\nA dynamical billiard is a system where a particle is propagating as a straight line from obstacle to obstacle, performing specular reflection at the boundary of the obstacles. Billiard systems have been used extensively in mathematics, nonlinear dynamics and chaos and played an important role in the development of nonlinear science.\n\n\nThe above will be referred to as the \"standard\" billiard. The \nwikipedia page\n has many examples of different types of billiards. Also, the \nscholarpedia\n entry is a good read on the subject. In general, the standard billiard can be extended in many ways.\n\n\nThe types that are currently offered by this package, besides the standard one, are magnetic and ray-splitting billiards. In a magnetic billiard the particle's orbit is a circle (like electrons in a perpendicular magnetic field). In ray-splitting (a.k.a. semiclassical) billiards the particle may propagate \nthrough\n an obstacle, given some arbitrary transmission and refraction law.\n\n\nThis package does not support finite-sized particles and, as a result, there is also no support for collision between particles.\n\n\n\n\n\n\nInstallation\n\n\nThis package is registered, simply use \nPkg.add(\nDynamicalBilliards\n)\n to install it. The \nstable documentation\n accompanies the version installed with \nPkg.add()\n.\n\n\n\n\nPlotting\n\n\nPlotting in \nDynamicalBilliards\n is done through \nPyPlot\n and it is available on-demand only. Simply use the function \nDynamicalBilliards.enableplotting()\n and it will define and bring into scope all the relevant names. Notice that you must be able to \nusing PyPlot\n for plotting to work. If you are not sure about how to install PyPlot, simply run the commands: \nENV[\nPYTHON\n]=\n; Pkg.add(\nPyCall\n); Pkg.add(\nPyPlot\n); using PyPlot;\n\n\n\n\nAfter the first installation, it is advised to run the tests to be sure that everything works as expected.\n\n\nusing\n \nDynamicalBilliards\n\n\nDynamicalBilliards\n.\ntest_options\n(\nprint_info\n \n=\n \ntrue\n,\n \nlong_tests\n \n=\n \ntrue\n)\n\n\nPkg\n.\ntest\n(\nDynamicalBilliards\n)\n\n\n\n\n\n\nThe long tests take on average 4 minutes to complete, while the shorts need some seconds.\n\n\n\n\n\n\nUsage\n\n\nIt is highly suggested to first visit the \nBasic Usage\n section, for a general overview of how to use \nDynamicalBilliards.jl\n. The very important discussion about \nnumerical precision\n is done in the \nPhysics\n page.\n\n\nThe following tutorials offer detailed descriptions for various aspects of \nDynamicalBilliards.jl\n:\n\n\n\n\nHow to define your custom Billiard Table\n\n\nUsing Ray-Splitting billiards\n\n\nVisualizing the billiard table and animating the particle's evolution\n\n\nCreating your own Obstacle Type\n\n\nExamples page\n\n\n\n\nThe \nLibrary\n section has the docstrings of all exported names in convenient groups and the \nPhysics\n briefly discusses physical aspects of billiard systems as well as inner workings of the package.\n\n\n\n\n\n\nContributing\n\n\nEveryone is welcomed to contribute to \nDynamicalBilliards.jl\n! If you have some new algorithm, types of Obstacles or anything new to add, do not hesitate!\n\n\nIf you would like to help but do not have anything new to contribute, please go ahead and take a look at the \nGitHub issues page\n of the package. Most of the issues are easy to solve and are there specifically for people that would like to contribute.\n\n\n\n\n\n\nJulia Billiard Animation\n\n\nThe animation of a particle inside a \"Julia\" billiard was generated with the code:\n\n\nusing\n \nDynamicalBilliards\n\n\nDynamicalBilliards\n.\nenableplotting\n()\n\n\n\nbt\n \n=\n \nbilliard_julia\n(\nplotit\n \n=\n \ntrue\n)\n\n\np\n \n=\n \nrandominside\n(\nbt\n)\n\n\n\ndarkblue\n \n=\n \n(\n64\n/\n255\n,\n \n99\n/\n255\n,\n \n216\n/\n255\n)\n\n\nlightblue\n \n=\n \n(\n102\n/\n255\n,\n \n130\n/\n255\n,\n \n223\n/\n255\n)\n\n\nokwargs\n \n=\n \nDict\n(\n:\nlinewidth\n \n=\n \n2.0\n,\n \n:\ncolor\n \n=\n \nlightblue\n)\n\n\npkwargs\n \n=\n \nDict\n(\n:\ncolor\n \n=\n \ndarkblue\n,\n \n:\ns\n \n=\n \n150.0\n)\n\n\n\nsname\n \n=\n \nC:\n\\\\\n****\n\\\\\nanim\n\n\n\nanimate_evolution\n(\np\n,\n \nbt\n,\n \n200\n;\n \ncol_to_plot\n \n=\n \n7\n,\n\n\nparticle_kwargs\n \n=\n \npkwargs\n,\n \norbit_kwargs\n \n=\n \nokwargs\n,\n\n\nsavefigs\n \n=\n \ntrue\n,\n \nsavename\n \n=\n \nsname\n)\n\n\n\n# use gifmaker.me to merge all figures into one .gif\n\n\n# in a future update, automatic support will be added!", 
            "title": "Introduction"
        }, 
        {
            "location": "/#installation", 
            "text": "This package is registered, simply use  Pkg.add( DynamicalBilliards )  to install it. The  stable documentation  accompanies the version installed with  Pkg.add() .   Plotting  Plotting in  DynamicalBilliards  is done through  PyPlot  and it is available on-demand only. Simply use the function  DynamicalBilliards.enableplotting()  and it will define and bring into scope all the relevant names. Notice that you must be able to  using PyPlot  for plotting to work. If you are not sure about how to install PyPlot, simply run the commands:  ENV[ PYTHON ]= ; Pkg.add( PyCall ); Pkg.add( PyPlot ); using PyPlot;   After the first installation, it is advised to run the tests to be sure that everything works as expected.  using   DynamicalBilliards  DynamicalBilliards . test_options ( print_info   =   true ,   long_tests   =   true )  Pkg . test ( DynamicalBilliards )   The long tests take on average 4 minutes to complete, while the shorts need some seconds.", 
            "title": "Installation"
        }, 
        {
            "location": "/#usage", 
            "text": "It is highly suggested to first visit the  Basic Usage  section, for a general overview of how to use  DynamicalBilliards.jl . The very important discussion about  numerical precision  is done in the  Physics  page.  The following tutorials offer detailed descriptions for various aspects of  DynamicalBilliards.jl :   How to define your custom Billiard Table  Using Ray-Splitting billiards  Visualizing the billiard table and animating the particle's evolution  Creating your own Obstacle Type  Examples page   The  Library  section has the docstrings of all exported names in convenient groups and the  Physics  briefly discusses physical aspects of billiard systems as well as inner workings of the package.", 
            "title": "Usage"
        }, 
        {
            "location": "/#contributing", 
            "text": "Everyone is welcomed to contribute to  DynamicalBilliards.jl ! If you have some new algorithm, types of Obstacles or anything new to add, do not hesitate!  If you would like to help but do not have anything new to contribute, please go ahead and take a look at the  GitHub issues page  of the package. Most of the issues are easy to solve and are there specifically for people that would like to contribute.", 
            "title": "Contributing"
        }, 
        {
            "location": "/#julia-billiard-animation", 
            "text": "The animation of a particle inside a \"Julia\" billiard was generated with the code:  using   DynamicalBilliards  DynamicalBilliards . enableplotting ()  bt   =   billiard_julia ( plotit   =   true )  p   =   randominside ( bt )  darkblue   =   ( 64 / 255 ,   99 / 255 ,   216 / 255 )  lightblue   =   ( 102 / 255 ,   130 / 255 ,   223 / 255 )  okwargs   =   Dict ( : linewidth   =   2.0 ,   : color   =   lightblue )  pkwargs   =   Dict ( : color   =   darkblue ,   : s   =   150.0 )  sname   =   C: \\\\ **** \\\\ anim  animate_evolution ( p ,   bt ,   200 ;   col_to_plot   =   7 ,  particle_kwargs   =   pkwargs ,   orbit_kwargs   =   okwargs ,  savefigs   =   true ,   savename   =   sname )  # use gifmaker.me to merge all figures into one .gif  # in a future update, automatic support will be added!", 
            "title": "Julia Billiard Animation"
        }, 
        {
            "location": "/basic/basic_usage/", 
            "text": "Basic Usage\n\n\nDynamicalBilliards.jl\n was created with easy-of-use as its main cornerstone. With 3 simple steps, the user can fully initalize, evolve, and get the output of the propagation of a particle in a billiard system.\n\n\nIn general, the workflow of \nDynamicalBilliards.jl\n follows these simple steps:\n\n\n\n\nCreate a billiard table, a \nVector{Obstacle}\n.\n\n\nCreate a particle inside that billiard table.\n\n\nGet the output by evolving the particle.\n\n\n\n\nAdding more complexity in your billiard table does not add complexity in your code. For example, to implement a ray-splitting billiard you only need to define one additional variable, a dictionary \nDict{Int, Vector{Function}}\n. After reading through this basic usage page, you will be able to use all aspects of \nDynamicalBilliards.jl\n with minimal effort.\n\n\n\n\n\n\nStraight Propagation\n\n\nThe usage of this package revolves around a single function:\n\n\nevolve!\n(\np\n::\nAbstractParticle\n,\n \nbt\n::\nVector\n{\nObstacle\n},\n \nt\n::\nUnion\n{\nInt\n,\n \nFloat\n})\n\n\n\n\n\n\nwhich evolves a particle \np\n inside a billiard table \nbt\n. If the given \nt\n is of type \nAbstractFloat\n, the evolution happens for \nt\n amount of time. If however \nt\n is of type \nInt\n, the evolution happens for \nt\n number of collisions (other types are not supported).\n\n\nThe first step is to define the billiard table \nbt\n, which is the system the particle \np\n will propagate in. A billiard table is simply a collection (\nVector\n) of \nObstacle\ns. The most convenient way is to use one of the pre-defined billiard tables offered by the package. For example, let's create a periodic Sinai billiard with disk radius of 0.3 and with one side of length 2 and one of length 1:\n\n\nusing\n \nDynamicalBilliards\n\n\nbt\n \n=\n \nbilliard_sinai\n(\n0.3\n,\n \n2.0\n,\n \n1.0\n;\n \nsetting\n \n=\n \nperiodic\n)\n\n\n\n\n\n\nFor more information about defining billiard tables visit the \ntutorial on defining your own billiard table\n). You should definitely look up that page if you want to customly define a table instead of using the \npredefined ones\n.\n\n\nAfterwards, you want to create a particle inside that billiard system. For that, the function \nrandominside(bt::Vector{Obstacle})\n is provided, which returns a particle with random initial conditions inside the billiard table.\n\n\np\n \n=\n \nrandominside\n(\nbt\n)\n\n\n\n\n\n\nIf you want to specify the initial conditions yourself, simply pass them to the \nParticle\n constructor, like \np = Particle(x0, y0, \u03c60)\n. Now you are ready to evolve this particle:\n\n\nt\n \n=\n \n1000.0\n \n# subtype of AbstractFloat\n\n\nct\n,\n \nposs\n,\n \nvels\n \n=\n \nevolve!\n(\np\n,\n \nbt\n,\n \n1000.0\n)\n\n\n\n\n\n\n\n\nType of \nt\n\n\nThe behavior of \nevolve!\n depends on the type of the third argument, which represents total amount. If it is \nAbstractFloat\n, it represents total amount of time, but if it is \nInt\n it represents total numnber of collisions.\n\n\n\n\nThe return values of the \nevolve!()\n function need some brief explaining: As noted by the \"!\" at the end of the function, it changes its argument \np\n. Most importantly however, this function also returns the main output expected by a billiard system. This output is a tuple of three vectors:\n\n\n\n\nct::Vector{T}\n : Collision times.\n\n\nposs::Vector{SVector{2,T}}\n : Positions during collisions.\n\n\nvels::Vector{SVector{2,T}}\n : Velocities \nexactly after\n the collisions (e.g. after reflection).\n\n\n\n\nwith \nT\n:AbstractFloat\n (more on that on the \nNumerical Precision\n section). The time \nct[i]\n is the time necessary to reach state \nposs[i], vels[i]\n starting from the state \nposs[i-1], vels[i-1]\n. That is why \nct[1]\n is always 0 since \nposs[1], vels[1]\n are the initial conditions.\n\n\nIf this output is not convenient for you, the function \nconstruct(ct, poss, vels)\n is provided, which constructs the (continuous) timeseries of the position and velocity, as well as the time-vector, when given the main output of \nevolve!()\n:\n\n\nxt\n,\n \nyt\n,\n \nvxt\n,\n \nvyt\n,\n \nts\n \n=\n \nconstruct\n(\nct\n,\n \nposs\n,\n \nvels\n)\n\n\n\n\n\n\nor, by taking advantage of the awesome ellipsis operator, you can do:\n\n\nxt\n,\n \nyt\n,\n \nvxt\n,\n \nvyt\n,\n \nts\n \n=\n \nconstruct\n(\nevolve!\n(\np\n,\n \nbt\n,\n \n100.0\n)\n...\n)\n\n\n\n\n\n\n\n\n\n\nMagnetic Propagation\n\n\nThe are only two differences between magnetic and straight propagation. Firstly, the particle type is not \nParticle\n anymore, but \nMagneticParticle\n. The latter has an extra field called \nomega\n which is the cyclic frequency of rotation (equivalently, the angular velocity). In order to create a \nMagneticParticle\n (without using the constructors), you simply provide this extra information to the \nrandominside()\n function:\n\n\n\u03c9\n \n=\n \n0.5\n\n\np\n \n=\n \nrandominside\n(\nbt\n,\n \n\u03c9\n)\n\n\ntypeof\n(\np\n)\n \n# MagneticParticle{Float64}\n\n\np\n.\nomega\n   \n# 0.5\n\n\n\n\n\n\nTo propagate the particle you use the same functions:\n\n\nct\n,\n \nposs\n,\n \nvels\n,\n \n\u03c9\n \n=\n \nevolve!\n(\np\n,\n \nbt\n,\n \n1000.0\n)\n  \n#evolve for magnetic also returns \u03c9\n\n\nxt\n,\n \nyt\n,\n \nvxt\n,\n \nvyt\n,\n \nts\n \n=\n \nconstruct\n(\nct\n,\n \nposs\n,\n \nvels\n,\n \n\u03c9\n,\n \ndt\n)\n\n\n# or equivalently:\n\n\nxt\n,\n \nyt\n,\n \nvxt\n,\n \nvyt\n,\n \nts\n \n=\n \nconstruct\n(\nevolve!\n(\np\n,\n \nbt\n,\n \n1000.0\n)\n...\n,\n \ndt\n)\n\n\n\n\n\n\nAs you can see, the second difference is that the additional argument of the angular velocity must also be provided to the \nconstruct()\n function, in order for it to construct circular motion instead of straight motion between collisions. (Note: \nevolve!()\n returns 4 arguments for magnetic propagation, making the ellipsis syntax extremely useful!).\n\n\nThe final \noptional argument\n \ndt\n is the time-step at which the timeseries are constructed (since they are made up of sines and cosines).\n\n\n\n\n\n\nRay-Splitting\n\n\nNo matter how complex ray-splitting processes you want, and irrespectively of how many obstacles in the billiard table can perform ray-splitting, there is only a single difference on the main function call: The \nevolve!()\n function is supplemented with a fourth argument, called \"ray_splitter\":\n\n\nray_splitter\n::\nDict\n{\nInt\n,\n \nAny\n}\n\n\n\n\n\n\nThis argument is simply a dictionary which handles all ray-splitting processes in the billiard system. It is a map of the Obstacle index within the billiard table a container of the ray-splitting functions: (\u03c6 is the angle of incidence)\n\n\n\n\nT(\u03c6, pflag, \u03c9) : Transmission probability.\n\n\n\u03b8(\u03c6, pflag, \u03c9) : Transmission (aka diffraction) angle.\n\n\nnew_\u03c9(\u03c9, pflag) : Angular velocity after transmission.\n\n\n\n\nAssuming you have defined a billiard table and a ray-splitter dictionary, the implementation is exactly the same as in the two previous cases: the ray-splitting dictionary is passed to \nevolve!()\n as a fourth argument.\n\n\nray_splitter\n \n=\n \nDict\n(\n5\n \n=\n \n(\nfoo\n,\n \nbar\n,\n \nbaz\n))\n\n\np\n \n=\n \nrandominside\n(\nbt\n,\n \n4.0\n)\n\n\nxt\n,\n \nyt\n,\n \nvxt\n,\n \nvyt\n,\n \nts\n \n=\n \nconstruct\n(\nevolve!\n(\np\n,\n \nbt\n,\n \n100.0\n,\n \nray_splitter\n)\n...\n,\n \n0.01\n)\n\n\n\n\n\n\nFor more information and instructions on defining the \"ray_splitter\" dictionary visit the \nRay-Splitting tutorial here\n.\n\n\n\n\n\n\nVisualizing\n\n\nThe functions \nplot_obstacle\n(\nobst\n::\nObstacle\n;\n \nkwargs\n...)\n, \nplot_billiard(bt::Vector{Obstacle})\n and \nplot_particle\n(\np\n::\nAbstractParticle\n;\n \nkwargs\n...)\n are provided in order to plot the respective elements \non the current PyPlot figure\n. The \nkwargs...\n are keywords passed directly into \nPyPlot\n's constructors (like e.g. \nlinewidth = 2.0\n).\n\n\nThe tutorial on visualizing\n has step-by-step descriptions on how to handle all plotting offered by \nDynamicalBilliards.jl\n.\n\n\n\n\nIntroduction animation\n\n\nThe example .gif shown in the introduction, was generated simply with the code:\n\n\nusing\n \nDynamicalBilliards\n,\n \nPyPlot\n\n\n\nbt\n \n=\n \nbilliard_rectangle\n(\n1.5\n,\n \n1.0\n)\n\n\nd1\n \n=\n \nDisk\n([\n0.45\n,\n \n0.6\n],\n \n0.3\n,\n \nUpper-left Disk\n)\n\n\nd2\n \n=\n \nDisk\n([\n1.1\n,\n \n0.3\n],\n \n0.15\n,\n \nLower-right Disk\n)\n\n\nd3\n \n=\n \nDisk\n([\n1.2\n,\n \n0.8\n],\n \n0.1\n,\n \nSmall Disk\n)\n\n\nw1\n \n=\n \nFiniteWall\n([\n0.0\n,\n \n0.4\n],\n \n[\n0.6\n,\n0.0\n],\n \n[\n0.4\n,\n0.6\n],\n \nDiagonal\n)\n\n\npush!\n(\nbt\n,\n \nd1\n,\n \nd2\n,\n \nd3\n,\n \nw1\n)\n\n\n\u03c9\n \n=\n \n2.0\n\n\np\n \n=\n \nrandominside\n(\nbt\n,\n \n\u03c9\n)\n\n\n\nDynamicalBilliards\n.\nenableplotting\n()\n\n\nplot_billiard\n(\nbt\n)\n\n\naxis\n(\noff\n)\n\n\ntight_layout\n()\n\n\n\nsname\n \n=\n \nC:\n\\\\\n***\n\\\\\nexample\n\n\nanimate_evolution\n(\np\n,\n \nbt\n,\n \n200\n;\n\n\ncol_to_plot\n \n=\n \n4\n,\n \nsavefigs\n \n=\n \ntrue\n,\n \nsavename\n \n=\n \nsname\n)\n\n\n\n\n\n\nAfterwards the outputed .png files where merged into a single .gif externally using for example the website gifmaker.me.", 
            "title": "Basic Usage"
        }, 
        {
            "location": "/basic/basic_usage/#basic-usage", 
            "text": "DynamicalBilliards.jl  was created with easy-of-use as its main cornerstone. With 3 simple steps, the user can fully initalize, evolve, and get the output of the propagation of a particle in a billiard system.  In general, the workflow of  DynamicalBilliards.jl  follows these simple steps:   Create a billiard table, a  Vector{Obstacle} .  Create a particle inside that billiard table.  Get the output by evolving the particle.   Adding more complexity in your billiard table does not add complexity in your code. For example, to implement a ray-splitting billiard you only need to define one additional variable, a dictionary  Dict{Int, Vector{Function}} . After reading through this basic usage page, you will be able to use all aspects of  DynamicalBilliards.jl  with minimal effort.", 
            "title": "Basic Usage"
        }, 
        {
            "location": "/basic/basic_usage/#straight-propagation", 
            "text": "The usage of this package revolves around a single function:  evolve! ( p :: AbstractParticle ,   bt :: Vector { Obstacle },   t :: Union { Int ,   Float })   which evolves a particle  p  inside a billiard table  bt . If the given  t  is of type  AbstractFloat , the evolution happens for  t  amount of time. If however  t  is of type  Int , the evolution happens for  t  number of collisions (other types are not supported).  The first step is to define the billiard table  bt , which is the system the particle  p  will propagate in. A billiard table is simply a collection ( Vector ) of  Obstacle s. The most convenient way is to use one of the pre-defined billiard tables offered by the package. For example, let's create a periodic Sinai billiard with disk radius of 0.3 and with one side of length 2 and one of length 1:  using   DynamicalBilliards  bt   =   billiard_sinai ( 0.3 ,   2.0 ,   1.0 ;   setting   =   periodic )   For more information about defining billiard tables visit the  tutorial on defining your own billiard table ). You should definitely look up that page if you want to customly define a table instead of using the  predefined ones .  Afterwards, you want to create a particle inside that billiard system. For that, the function  randominside(bt::Vector{Obstacle})  is provided, which returns a particle with random initial conditions inside the billiard table.  p   =   randominside ( bt )   If you want to specify the initial conditions yourself, simply pass them to the  Particle  constructor, like  p = Particle(x0, y0, \u03c60) . Now you are ready to evolve this particle:  t   =   1000.0   # subtype of AbstractFloat  ct ,   poss ,   vels   =   evolve! ( p ,   bt ,   1000.0 )    Type of  t  The behavior of  evolve!  depends on the type of the third argument, which represents total amount. If it is  AbstractFloat , it represents total amount of time, but if it is  Int  it represents total numnber of collisions.   The return values of the  evolve!()  function need some brief explaining: As noted by the \"!\" at the end of the function, it changes its argument  p . Most importantly however, this function also returns the main output expected by a billiard system. This output is a tuple of three vectors:   ct::Vector{T}  : Collision times.  poss::Vector{SVector{2,T}}  : Positions during collisions.  vels::Vector{SVector{2,T}}  : Velocities  exactly after  the collisions (e.g. after reflection).   with  T :AbstractFloat  (more on that on the  Numerical Precision  section). The time  ct[i]  is the time necessary to reach state  poss[i], vels[i]  starting from the state  poss[i-1], vels[i-1] . That is why  ct[1]  is always 0 since  poss[1], vels[1]  are the initial conditions.  If this output is not convenient for you, the function  construct(ct, poss, vels)  is provided, which constructs the (continuous) timeseries of the position and velocity, as well as the time-vector, when given the main output of  evolve!() :  xt ,   yt ,   vxt ,   vyt ,   ts   =   construct ( ct ,   poss ,   vels )   or, by taking advantage of the awesome ellipsis operator, you can do:  xt ,   yt ,   vxt ,   vyt ,   ts   =   construct ( evolve! ( p ,   bt ,   100.0 ) ... )", 
            "title": "Straight Propagation"
        }, 
        {
            "location": "/basic/basic_usage/#magnetic-propagation", 
            "text": "The are only two differences between magnetic and straight propagation. Firstly, the particle type is not  Particle  anymore, but  MagneticParticle . The latter has an extra field called  omega  which is the cyclic frequency of rotation (equivalently, the angular velocity). In order to create a  MagneticParticle  (without using the constructors), you simply provide this extra information to the  randominside()  function:  \u03c9   =   0.5  p   =   randominside ( bt ,   \u03c9 )  typeof ( p )   # MagneticParticle{Float64}  p . omega     # 0.5   To propagate the particle you use the same functions:  ct ,   poss ,   vels ,   \u03c9   =   evolve! ( p ,   bt ,   1000.0 )    #evolve for magnetic also returns \u03c9  xt ,   yt ,   vxt ,   vyt ,   ts   =   construct ( ct ,   poss ,   vels ,   \u03c9 ,   dt )  # or equivalently:  xt ,   yt ,   vxt ,   vyt ,   ts   =   construct ( evolve! ( p ,   bt ,   1000.0 ) ... ,   dt )   As you can see, the second difference is that the additional argument of the angular velocity must also be provided to the  construct()  function, in order for it to construct circular motion instead of straight motion between collisions. (Note:  evolve!()  returns 4 arguments for magnetic propagation, making the ellipsis syntax extremely useful!).  The final  optional argument   dt  is the time-step at which the timeseries are constructed (since they are made up of sines and cosines).", 
            "title": "Magnetic Propagation"
        }, 
        {
            "location": "/basic/basic_usage/#ray-splitting", 
            "text": "No matter how complex ray-splitting processes you want, and irrespectively of how many obstacles in the billiard table can perform ray-splitting, there is only a single difference on the main function call: The  evolve!()  function is supplemented with a fourth argument, called \"ray_splitter\":  ray_splitter :: Dict { Int ,   Any }   This argument is simply a dictionary which handles all ray-splitting processes in the billiard system. It is a map of the Obstacle index within the billiard table a container of the ray-splitting functions: (\u03c6 is the angle of incidence)   T(\u03c6, pflag, \u03c9) : Transmission probability.  \u03b8(\u03c6, pflag, \u03c9) : Transmission (aka diffraction) angle.  new_\u03c9(\u03c9, pflag) : Angular velocity after transmission.   Assuming you have defined a billiard table and a ray-splitter dictionary, the implementation is exactly the same as in the two previous cases: the ray-splitting dictionary is passed to  evolve!()  as a fourth argument.  ray_splitter   =   Dict ( 5   =   ( foo ,   bar ,   baz ))  p   =   randominside ( bt ,   4.0 )  xt ,   yt ,   vxt ,   vyt ,   ts   =   construct ( evolve! ( p ,   bt ,   100.0 ,   ray_splitter ) ... ,   0.01 )   For more information and instructions on defining the \"ray_splitter\" dictionary visit the  Ray-Splitting tutorial here .", 
            "title": "Ray-Splitting"
        }, 
        {
            "location": "/basic/basic_usage/#visualizing", 
            "text": "The functions  plot_obstacle ( obst :: Obstacle ;   kwargs ...) ,  plot_billiard(bt::Vector{Obstacle})  and  plot_particle ( p :: AbstractParticle ;   kwargs ...)  are provided in order to plot the respective elements  on the current PyPlot figure . The  kwargs...  are keywords passed directly into  PyPlot 's constructors (like e.g.  linewidth = 2.0 ).  The tutorial on visualizing  has step-by-step descriptions on how to handle all plotting offered by  DynamicalBilliards.jl .", 
            "title": "Visualizing"
        }, 
        {
            "location": "/basic/basic_usage/#introduction-animation", 
            "text": "The example .gif shown in the introduction, was generated simply with the code:  using   DynamicalBilliards ,   PyPlot  bt   =   billiard_rectangle ( 1.5 ,   1.0 )  d1   =   Disk ([ 0.45 ,   0.6 ],   0.3 ,   Upper-left Disk )  d2   =   Disk ([ 1.1 ,   0.3 ],   0.15 ,   Lower-right Disk )  d3   =   Disk ([ 1.2 ,   0.8 ],   0.1 ,   Small Disk )  w1   =   FiniteWall ([ 0.0 ,   0.4 ],   [ 0.6 , 0.0 ],   [ 0.4 , 0.6 ],   Diagonal )  push! ( bt ,   d1 ,   d2 ,   d3 ,   w1 )  \u03c9   =   2.0  p   =   randominside ( bt ,   \u03c9 )  DynamicalBilliards . enableplotting ()  plot_billiard ( bt )  axis ( off )  tight_layout ()  sname   =   C: \\\\ *** \\\\ example  animate_evolution ( p ,   bt ,   200 ;  col_to_plot   =   4 ,   savefigs   =   true ,   savename   =   sname )   Afterwards the outputed .png files where merged into a single .gif externally using for example the website gifmaker.me.", 
            "title": "Introduction animation"
        }, 
        {
            "location": "/tutorials/billiard_table/", 
            "text": "A billiard table \nbt\n is a vector of Obstacles: \nbt::Vector{Obstacle{T}} where {T\n:AbstractFloat}\n. The abstract Type \nObstacle{T}\n is the supertype of all objects that a particle may collide with, with global billiard precision of type \nT\n.\n\n\nThere are many premade functions that construct well-known billiards, like the periodic Sinai billiard. You can find all of them at the \nStandard Billiards page\n.\n\n\nTo create a custom billiard, you start with an empty Vector:\n\n\nbt = Obstacle{T}[]\n\n\n\n\n\nand then you create your obstacles one by one and add them to it. All obstacles that are already defined in the package can be found at the \nObstacles page\n of the library. The function \nbilliard_polygon\n creates a polygonal billiard table. However, for the example of this page, we will create a hexagonal billiard with a disk in the middle step-by-step.\n\n\nThe first step is to define the six walls of the billiard table. A \nFiniteWall\n object needs to be supplemented with a start point, an end point, a normal vector and, optionally, a name.\n\n\n\n\nConvex Polygons\n\n\nNotice that even though all walls are \"finite\" (e.g. \nFiniteWall\n), they are considered infinite when calculating the collision time. This means that the only billiard tables allowed for this package are \nconvex\n polygons\n. \nDo not\n create a non-convex billiard table as it will silently error during evolution.\n\n\n\n\nThe vertex points of a regular hexagon of radius \nr\n are given by the formula:\n\n\n\\[\n(x,y) = \\left( r\\cos\\left(\\frac{2\\pi i}{6}\\right), r\\cos\\left(\\frac{2\\pi i}{6}\\right) \\right)\\,, \\quad \\text{for i $\\in$ \\{1,...,6\\}}\n\\]\nTo create each wall object, we will implement the following loop, choosing a size of 2.0:\n\n\nusing\n \nDynamicalBilliards\n\n\nhexagon_vertex\n \n=\n \n(\nr\n)\n \n-\n \n[\n \n[\nr\n*\ncos\n(\n2\n\u03c0\n*\ni\n/\n6\n),\n \nr\n*\nsin\n(\n2\n\u03c0\n*\ni\n/\n6\n)]\n \nfor\n \ni\n \nin\n \n1\n:\n6\n]\n\n\nhexver\n \n=\n \nhexagon_vertex\n(\n2.0\n)\n\n\n\nfor\n \ni\n \nin\n \neachindex\n(\nhexver\n)\n\n  \nstarting\n \n=\n \nhexver\n[\ni\n]\n\n  \nending\n \n=\n \nhexver\n[\nmod1\n(\ni\n+\n1\n,\n \nlength\n(\nhexver\n))]\n\n  \nw\n \n=\n \nending\n \n-\n \nstarting\n\n  \nnormal\n \n=\n \n[\n-\nw\n[\n2\n],\n \nw\n[\n1\n]]\n\n  \nwall\n \n=\n \nFiniteWall\n(\nstarting\n,\n \nending\n,\n \nnormal\n,\n \nwall \n$i\n)\n\n  \npush!\n(\nbt\n,\n \nwall\n)\n\n\nend\n\n\n\n\n\n\nThe \nnormal\n vector of a \nWall\n obstacle is necessary to be supplemented by the user because it must point towards where the particle is expected to come from. If \nw\n is the vector (wall) pointing from start- to end-point then the vector \n[-w[2], w[1]]\n is pointing to the left of \nw\n and the vector \n[w[2], -[w1]]\n is pointing to the right. Both are normal to \nw\n, but you have to know which one to pick. In this case this is very easy, since the normal has to simply point towards the origin.\n\n\nWe add a disk by specifying a center and radius (and optionally a name):\n\n\nd\n \n=\n \nDisk\n([\n0\n,\n0\n],\n \n0.8\n)\n\n\npush!\n(\nbt\n,\n \nd\n)\n\n\n\n\n\n\nTo make sure the billiard looks as you would expect, use the function \nplot_billiard(bt)\n. Create a particle inside that billiard and evolve it:\n\n\nplot_billiard\n(\nbt\n)\n\n\n\u03c9\n \n=\n \n0.5\n\n\np\n \n=\n \nrandominside\n(\np\n,\n \n\u03c9\n)\n\n\nxt\n,\n \nyt\n,\n \nvxt\n,\n \nvyt\n,\n \nt\n \n=\n \nconstruct\n(\nevolve!\n(\np\n,\n \nbt\n,\n \n100\n)\n...\n)\n\n\n\n\n\n\nThe billiard table now works for straight or magnetic propagation. To expand this to ray-splitting you have to use ray-splitting Obstacles (\nsee the tutorial on Ray-Splitting\n). Additional information on how to define your own \nObstacle\n sub-type is given in the tutorial on \nCefining your own Obstacles\n.\n\n\nIf you make any billiard system that you think is common and missing from this package, you are more than welcome to submit a PR extending the \nStandardBilliards.jl\n library with your contribution!", 
            "title": "Defining a Billiard Table"
        }, 
        {
            "location": "/tutorials/ray-splitting/", 
            "text": "Ray-Splitting\n\n\nRay-splitting is a semi-classical approach to the billiard system, giving a wave attribute to the ray traced by the particle. Upon collision a particle may propagate through an obstacle (transmission \n refraction) or be reflected. Following the mindset of this package, implementing a ray-splitting billiard requires only three very simple steps.\n\n\n\n\nRay-Splitting Obstacles\n\n\nFirst, an obstacle that supports ray-splitting is required to be present in your billiard table. The only new feature these obstacles have is an additional Boolean field called \npflag\n (propagation flag). This field notes on which side of the obstacle the particle is currently propagating.\n\n\nThe normal vector as well as the distance from boundary change sign depending on the value of \npflag\n. The obstacles \nAntidot\n and \nSplitterWall\n are the equivalents of disk and wall for ray-splitting.\n\n\nLet's add an \nAntidot\n to a billiard table:\n\n\nusing\n \nDynamicalBilliards\n\n\nbt\n \n=\n \nbilliard_rectangle\n()\n\n\na\n \n=\n \nAntidot\n([\n0.5\n,\n0.5\n],\n \n0.3\n)\n\n\npush!\n(\nbt\n,\n \na\n)\n\n\n\n\n\n\n\n\nRay-Splitting Functions\n\n\nSecondly, for each obstacle in your billiard table that you want to perform ray-splitting, you have to define 3 functions (\u03c6 = angle of incidence, \u03c9 = angular velocity \nbefore\n transmission):\n\n\n\n\nT(\u03c6, \npflag\n, \u03c9) : Transmission probability \u03a4 depending on whether the particle is inside or outside the obstacle (\npflag\n) and optionally depending on \u03c9.\n\n\n\u03b8(\u03c6, \npflag\n, \u03c9) : Transmission (aka refraction) angle \u03b8 depending on whether the particle is inside or outside the obstacle (\npflag\n) and optionally depending on \u03c9.\n\n\n\u03c9_new(\u03c9, \npflag\n) : Angular velocity after transmission.\n\n\n\n\nThe above three functions use the \nsame convention\n: the argument \npflag\n is the one the Obstacle has \nbefore transmission\n. For example, if a particle is outside a disk (let \npflag = true\n here) and is transmitted inside the disk (\npflag\n becomes \nfalse\n here), then all three functions will be given their second argument (the Boolean one) as \ntrue\n!\n\n\n\n\nRay-Splitter Dictionary\n\n\nTo pass the information of the aforementioned functions into the main API a dictionary is required:\n\n\nraysplitter\n::\nDict\n{\nInt\n,\n \nAny\n}\n\n\n\n\n\n\nThis dictionary is a map of the \nobstacle index\n within the billiard table to a \ncontainer of the ray-splitting functions\n. This container could be a \nVector\n or a \nTuple\n and the later is the suggested version.\n\n\nFor example, if we wanted to allocate ray-splitting functions for the \n5th\n obstacle in our billiard table, which could be e.g. an \nAntidot\n, we would write something like:\n\n\nsa\n \n=\n \n(\n\u03b8\n,\n \npflag\n,\n \n\u03c9\n)\n \n-\n \npflag\n \n?\n \n2\n\u03b8\n \n:\n \n0.5\n\u03b8\n  \n# refraction (scatter) angle\n\n\nT\n \n=\n \n(\n\u03b8\n,\n \npflag\n,\n \n\u03c9\n)\n \n-\n \nbegin\n   \n# Transmission probability\n\n  \nif\n \npflag\n\n    \nabs\n(\n\u03b8\n)\n \n \n\u03c0\n/\n4\n \n?\n \n0.5\nexp\n(\n-\n(\n\u03b8\n)\n^\n2\n/\n2\n(\n\u03c0\n/\n8\n)\n^\n2\n)\n \n:\n \n0.0\n\n  \nelse\n\n    \n0.75\n*\nexp\n(\n-\n(\n\u03b8\n)\n^\n2\n/\n2\n(\n\u03c0\n/\n4\n)\n^\n2\n)\n\n  \nend\n\n\nend\n\n\nnewo\n \n=\n \n(\n\u03c9\n,\n \nbool\n)\n \n-\n \nbool\n \n?\n \n-\n0.5\n\u03c9\n \n:\n \n-\n2\n\u03c9\n   \n# new angular velocity\n\n\nraysplitter\n \n=\n \nDict\n(\n5\n \n=\n \n(\nT\n,\n \nsa\n,\n \nnewo\n))\n  \n# Index maps to container of Functions\n\n\n\n\n\n\n\n\nOrder of Arguments\n\n\nThe functions \nmust accept the specific number of arguments shown in the previous section\n even if some are not used. Also, the functions must be given \nin the specific order: [1. transmission probability, 2. refraction angle, 3. new \u03c9]\n in the vector passed to the dictionary.\n\n\n\n\nThe next step is very simple: the \nraysplitter\n dictionary is directly passed into \nevolve!()\n as a fourth argument. Using the billiard table we defined previously, where its 5th element is a ray-splitting \nAntidot\n, we now do:\n\n\nbt\n \n=\n \nbilliard_rectangle\n()\n\n\na\n \n=\n \nAntidot\n([\n0.5\n,\n \n0.5\n],\n \n0.25\n)\n\n\npush!\n(\nbt\n,\n \na\n)\n\n\n\u03c9\n \n=\n \n1.25\n\n\np\n \n=\n \nrandominside\n(\nbt\n,\n \n\u03c9\n)\n\n\ndt\n \n=\n \n0.05\n\n\nxt\n,\n \nyt\n,\n \nvxt\n,\n \nvyt\n,\n \nts\n \n=\n \nconstruct\n(\nevolve!\n(\np\n,\n \nbt\n,\n \n25.0\n,\n \nraysplitter\n)\n...\n,\n \ndt\n)\n\n\nusing\n \nDynamicalBilliardsPlotting\n,\n \nPyPlot\n\n\nplot_billiard\n(\nbt\n)\n\n\nplot\n(\nxt\n,\n \nyt\n)\n\n\n\n\n\n\nwhich should give a result similar to this:\n\n\n\n\nA final difference to be noted is that in the case of ray-splitting with magnetic fields, the fourth value returned by \nevolve!()\n is not a number, but a vector of angular velocities \nomegas\n. The value \nomegas[i]\n is the angular velocity the particle has while propagating from state \npos[i], vel[i]\n to state \npos[i+1], vel[i+1]\n. The \nconstruct()\n function takes this into account.\n\n\n\n\nNo field \npflag\n error\n\n\nIf you ever encounter the error \nERROR\n:\n \ntype\n \nSomeObstacleType\n \nhas\n \nno\n \nfield\n \npflag\n this means that the index provided by your ray-splitting dictionary points to an object that does not support ray-splitting. Use the functions:\n\n\nacceptable_raysplitter\n(\nraysplitter\n,\n \nbt\n)\n\n\nsupports_raysplitting\n(\nobst\n::\nObstacle\n)\n\n\n\n\n\n\nto find out what you did wrong. Most likely, the index you supplied was incorrect, i.e. the index could be \n5\n instead of \n4\n.\n\n\n\n\nExample Animation\n\n\nIn the [examples page], you can find the code for the following animation, which includes ray-splitting:\n\n\n\n\n\n\nPhysics\n\n\nThe condition for transmission is simply: \nT(\u03c6, pflag, \u03c9) \n rand()\n. If it returns \ntrue\n, transmission (i.e. ray-splitting) will happen. Otherwise just specular reflection will take place. A more detailed discussion is on the ray-splitting section of the \nPhysics\n page.", 
            "title": "Ray-Splitting"
        }, 
        {
            "location": "/tutorials/ray-splitting/#ray-splitting", 
            "text": "Ray-splitting is a semi-classical approach to the billiard system, giving a wave attribute to the ray traced by the particle. Upon collision a particle may propagate through an obstacle (transmission   refraction) or be reflected. Following the mindset of this package, implementing a ray-splitting billiard requires only three very simple steps.", 
            "title": "Ray-Splitting"
        }, 
        {
            "location": "/tutorials/ray-splitting/#ray-splitting-obstacles", 
            "text": "First, an obstacle that supports ray-splitting is required to be present in your billiard table. The only new feature these obstacles have is an additional Boolean field called  pflag  (propagation flag). This field notes on which side of the obstacle the particle is currently propagating.  The normal vector as well as the distance from boundary change sign depending on the value of  pflag . The obstacles  Antidot  and  SplitterWall  are the equivalents of disk and wall for ray-splitting.  Let's add an  Antidot  to a billiard table:  using   DynamicalBilliards  bt   =   billiard_rectangle ()  a   =   Antidot ([ 0.5 , 0.5 ],   0.3 )  push! ( bt ,   a )", 
            "title": "Ray-Splitting Obstacles"
        }, 
        {
            "location": "/tutorials/ray-splitting/#ray-splitting-functions", 
            "text": "Secondly, for each obstacle in your billiard table that you want to perform ray-splitting, you have to define 3 functions (\u03c6 = angle of incidence, \u03c9 = angular velocity  before  transmission):   T(\u03c6,  pflag , \u03c9) : Transmission probability \u03a4 depending on whether the particle is inside or outside the obstacle ( pflag ) and optionally depending on \u03c9.  \u03b8(\u03c6,  pflag , \u03c9) : Transmission (aka refraction) angle \u03b8 depending on whether the particle is inside or outside the obstacle ( pflag ) and optionally depending on \u03c9.  \u03c9_new(\u03c9,  pflag ) : Angular velocity after transmission.   The above three functions use the  same convention : the argument  pflag  is the one the Obstacle has  before transmission . For example, if a particle is outside a disk (let  pflag = true  here) and is transmitted inside the disk ( pflag  becomes  false  here), then all three functions will be given their second argument (the Boolean one) as  true !", 
            "title": "Ray-Splitting Functions"
        }, 
        {
            "location": "/tutorials/ray-splitting/#ray-splitter-dictionary", 
            "text": "To pass the information of the aforementioned functions into the main API a dictionary is required:  raysplitter :: Dict { Int ,   Any }   This dictionary is a map of the  obstacle index  within the billiard table to a  container of the ray-splitting functions . This container could be a  Vector  or a  Tuple  and the later is the suggested version.  For example, if we wanted to allocate ray-splitting functions for the  5th  obstacle in our billiard table, which could be e.g. an  Antidot , we would write something like:  sa   =   ( \u03b8 ,   pflag ,   \u03c9 )   -   pflag   ?   2 \u03b8   :   0.5 \u03b8    # refraction (scatter) angle  T   =   ( \u03b8 ,   pflag ,   \u03c9 )   -   begin     # Transmission probability \n   if   pflag \n     abs ( \u03b8 )     \u03c0 / 4   ?   0.5 exp ( - ( \u03b8 ) ^ 2 / 2 ( \u03c0 / 8 ) ^ 2 )   :   0.0 \n   else \n     0.75 * exp ( - ( \u03b8 ) ^ 2 / 2 ( \u03c0 / 4 ) ^ 2 ) \n   end  end  newo   =   ( \u03c9 ,   bool )   -   bool   ?   - 0.5 \u03c9   :   - 2 \u03c9     # new angular velocity  raysplitter   =   Dict ( 5   =   ( T ,   sa ,   newo ))    # Index maps to container of Functions    Order of Arguments  The functions  must accept the specific number of arguments shown in the previous section  even if some are not used. Also, the functions must be given  in the specific order: [1. transmission probability, 2. refraction angle, 3. new \u03c9]  in the vector passed to the dictionary.   The next step is very simple: the  raysplitter  dictionary is directly passed into  evolve!()  as a fourth argument. Using the billiard table we defined previously, where its 5th element is a ray-splitting  Antidot , we now do:  bt   =   billiard_rectangle ()  a   =   Antidot ([ 0.5 ,   0.5 ],   0.25 )  push! ( bt ,   a )  \u03c9   =   1.25  p   =   randominside ( bt ,   \u03c9 )  dt   =   0.05  xt ,   yt ,   vxt ,   vyt ,   ts   =   construct ( evolve! ( p ,   bt ,   25.0 ,   raysplitter ) ... ,   dt )  using   DynamicalBilliardsPlotting ,   PyPlot  plot_billiard ( bt )  plot ( xt ,   yt )   which should give a result similar to this:   A final difference to be noted is that in the case of ray-splitting with magnetic fields, the fourth value returned by  evolve!()  is not a number, but a vector of angular velocities  omegas . The value  omegas[i]  is the angular velocity the particle has while propagating from state  pos[i], vel[i]  to state  pos[i+1], vel[i+1] . The  construct()  function takes this into account.", 
            "title": "Ray-Splitter Dictionary"
        }, 
        {
            "location": "/tutorials/ray-splitting/#no-field-pflag-error", 
            "text": "If you ever encounter the error  ERROR :   type   SomeObstacleType   has   no   field   pflag  this means that the index provided by your ray-splitting dictionary points to an object that does not support ray-splitting. Use the functions:  acceptable_raysplitter ( raysplitter ,   bt )  supports_raysplitting ( obst :: Obstacle )   to find out what you did wrong. Most likely, the index you supplied was incorrect, i.e. the index could be  5  instead of  4 .", 
            "title": "No field pflag error"
        }, 
        {
            "location": "/tutorials/ray-splitting/#example-animation", 
            "text": "In the [examples page], you can find the code for the following animation, which includes ray-splitting:", 
            "title": "Example Animation"
        }, 
        {
            "location": "/tutorials/ray-splitting/#physics", 
            "text": "The condition for transmission is simply:  T(\u03c6, pflag, \u03c9)   rand() . If it returns  true , transmission (i.e. ray-splitting) will happen. Otherwise just specular reflection will take place. A more detailed discussion is on the ray-splitting section of the  Physics  page.", 
            "title": "Physics"
        }, 
        {
            "location": "/tutorials/visualizing/", 
            "text": "All plotting functionality of \nDynamicalBilliards\n lies within a few well-defined functions that use the \nPyPlot\n package to plot aspects of the system on the current PyPlot figure. These functions are nicely grouped in this \nlibrary section\n.\n\n\nRemember to use\n \nDynamicalBilliards.enableplotting()\n \nto bring the plotting functions into scope!\n\n\n\n\nPlotting the Billiard Table\n\n\nThe function \nplot_obstacle\n(\nobst\n::\nObstacle\n;\n \nkwargs\n...)\n plots the given obstacle on the current PyPlot figure. The \nkwargs...\n are keywords passed directly into \nPyPlot\n's constructors (like e.g. \nlinewidth = 2.0\n). For example:\n\n\nusing\n \nDynamicalBilliards\n,\n \nPyPlot\n\n\nDynamicalBilliards\n.\nenableplotting\n()\n\n\nbt\n \n=\n \nbilliard_sinai\n(\n0.3\n)\n\n\n# Plot disk:\n\n\nplot_obstacle\n(\nbt\n[\n5\n])\n\n\n# Plot left wall:\n\n\nplot_obstacle\n(\nbt\n[\n1\n])\n\n\n# Plot right wall with different settings:\n\n\nplot_obstacle\n(\nbt\n[\n2\n];\n \nlinewidth\n \n=\n \n3.0\n,\n \nlinestyle\n \n=\n \ndashed\n,\n \ncolor\n \n=\n \n(\n1.0\n,\n \n0.5\n,\n \n0.5\n))\n\n\n# Set limits for the purpose of the tutorial\n\n\nxlim\n(\n-\n0.1\n,\n \n1.1\n);\n \nylim\n(\n-\n0.1\n,\n \n1.1\n)\n\n\n\n\n\n\nwill plot something like this:\n\n\n\n\nIf you want to quickly plot the entire billiard table without changing the settings, simply use the function  \nplot_billiard(bt)\n:\n\n\nbt\n \n=\n \nbilliard_polygon\n(\n6\n,\n \n1\n)\n\n\na\n \n=\n \nAntidot\n([\n0.0\n,\n0.0\n],\n \n0.5\n)\n\n\npush!\n(\nbt\n,\n \na\n)\n\n\nplot_billiard\n(\nbt\n)\n\n\n\n\n\n\nwhich will plot something like this:\n\n\n\n\nplot_billiard()\n also sets up the axis to have equal aspect ratio and sets up the axis limits to be just large enough to contain the entire billiard.\n\n\n\n\nPlotting particles\n\n\nFollowing the above example, we create and plot a particle using the function \nplot_particle\n:\n\n\np\n \n=\n \nrandominside\n(\nbt\n)\n\n\nplot_particle\n(\np\n)\n\n\n# Plot one more particle with purple color,\n\n\n# pentagon shape and bigger size (default is s=30):\n\n\np2\n \n=\n \nrandominside\n(\nbt\n)\n\n\nplot_particle\n(\np2\n;\n \ncolor\n=\n(\n0.5\n,\n \n0\n,\n \n0.8\n),\n \nmarker\n=\np\n,\n \ns\n=\n60.0\n)\n\n\n\n\n\n\nwhich should give you something like this (notice that the particle position and direction are random):\n\n\n\n\n\n\nColor conventions\n\n\nThe default plotting settings have been chosen for maximum clarity and consistency. The color conventions followed are:\n\n\n\n\nParticles are black.\n\n\nParticle orbits/trajectories are blue.\n\n\nReflecting obstacles (e.g. \nDisk\n or \nFiniteWall\n) are green.\n\n\nRandomly reflecting obstacles (e.g. \nRandomDisk\n or \nRandomWall\n) are yellow.\n\n\nRay-splitting obstacles are red with dashed linestyle.\n\n\nPeriodicity enforcing obstacles are purple with dotted linestyle (if and when plotted).\n\n\n\n\n\n\nAnimating the motion of a particle\n\n\nThe function \nanimate_evolution\n is provided to animate the evolution of a particle from collision to collision, using the default arguments. Its \ndocumentation string\n contains all the information necessary for its usage.\n\n\nAutomatic output into an animated image (e.g. \".gif\" format) is not yet supported. However, \nanimate_evolution\n gives users the possibility to save each produce figure in order to merge as an animation using an external tool.\n\n\nLet's animate a particle inside a simple pentagon with magnetic field:\n\n\nbt\n \n=\n \nbilliard_polygon\n(\n5\n,\n \n1\n)\n\n\na\n \n=\n \nDisk\n([\n0.0\n,\n0.0\n],\n \n0.4\n)\n\n\npush!\n(\nbt\n,\n \na\n)\n\n\nplot_billiard\n(\nbt\n)\n\n\n\np\n \n=\n \nrandominside\n(\nbt\n,\n \n1.0\n)\n \n# second argument is magnetic field strength\n\n\nsavedir\n \n=\n \nC:\n\\\\\nsome_path\n\\\\\nanim1\n\n\nanimate_evolution\n(\np\n,\n \nbt\n,\n \n50\n;\n \nsavefigs\n \n=\n \ntrue\n,\n \nsavename\n \n=\n \nsavedir\n)\n\n\n\n\n\n\nThis code produced 50 \".png\" images which were later mixed (using e.g. \ngifmaker\n) into a single \".gif\" animation. The output figures have a dpi=60 and therefore take only a dozen kb of space. The animation produced should look like:\n\n\n\n\n\n\nPeriodic Billiards\n\n\nIn order to plot periodic billiards, you have need to call a different method of \nplot_billiard\n, since now you also have to specify the limits of plotting. The methods provided are:\n\n\nplot_billiard\n(\nbt\n,\n \nxmin\n,\n \nymin\n,\n \nxmax\n,\n \nymax\n)\n\n\nplot_billiard\n(\nbt\n,\n \nxt\n::\nVector\n{\nT\n},\n \nyt\n::\nVector\n{\nT\n})\n\n\n\n\n\n\nThe last one conveniently plots the combo of particle-trajectory and periodic-billiard taking care of all the details internally. Give the keyword \nplot_orbit = false\n if you do not want to plot the orbit defined by \n(xt, yt)\n.\n\n\nFor example, the following code\n\n\nusing\n \nDynamicalBilliards\n,\n \nDynamicalBilliardsPlotting\n\n\nr\n \n=\n \n0.25\n\n\nbt\n \n=\n \nbilliard_rectangle\n(\n2\n,\n \n1\n;\n \nsetting\n \n=\n \nperiodic\n)\n\n\nd\n \n=\n \nDisk\n([\n0.5\n,\n \n0.5\n],\n \nr\n)\n\n\nd2\n \n=\n \nDisk\n([\n1.5\n,\n \n0.5\n],\n \nr\n/\n2\n)\n\n\npush!\n(\nbt\n,\n \nd\n,\n \nd2\n)\n\n\np\n \n=\n \nrandominside\n(\nbt\n)\n\n\nxt\n,\n \nyt\n,\n \nvxt\n,\n \nvyt\n,\n \nt\n \n=\n \nconstruct\n(\nevolve!\n(\np\n,\n \nbt\n,\n \n50\n)\n...\n)\n\n\nplot_billiard\n(\nbt\n,\n \nxt\n,\n \nyt\n)\n\n\nplot_particle\n(\np\n)\n\n\n\n\n\n\nwill produce something like this: \n\n\nAnimations for periodic billiards are not supported yet.", 
            "title": "Visualizing"
        }, 
        {
            "location": "/tutorials/visualizing/#plotting-the-billiard-table", 
            "text": "The function  plot_obstacle ( obst :: Obstacle ;   kwargs ...)  plots the given obstacle on the current PyPlot figure. The  kwargs...  are keywords passed directly into  PyPlot 's constructors (like e.g.  linewidth = 2.0 ). For example:  using   DynamicalBilliards ,   PyPlot  DynamicalBilliards . enableplotting ()  bt   =   billiard_sinai ( 0.3 )  # Plot disk:  plot_obstacle ( bt [ 5 ])  # Plot left wall:  plot_obstacle ( bt [ 1 ])  # Plot right wall with different settings:  plot_obstacle ( bt [ 2 ];   linewidth   =   3.0 ,   linestyle   =   dashed ,   color   =   ( 1.0 ,   0.5 ,   0.5 ))  # Set limits for the purpose of the tutorial  xlim ( - 0.1 ,   1.1 );   ylim ( - 0.1 ,   1.1 )   will plot something like this:   If you want to quickly plot the entire billiard table without changing the settings, simply use the function   plot_billiard(bt) :  bt   =   billiard_polygon ( 6 ,   1 )  a   =   Antidot ([ 0.0 , 0.0 ],   0.5 )  push! ( bt ,   a )  plot_billiard ( bt )   which will plot something like this:   plot_billiard()  also sets up the axis to have equal aspect ratio and sets up the axis limits to be just large enough to contain the entire billiard.", 
            "title": "Plotting the Billiard Table"
        }, 
        {
            "location": "/tutorials/visualizing/#plotting-particles", 
            "text": "Following the above example, we create and plot a particle using the function  plot_particle :  p   =   randominside ( bt )  plot_particle ( p )  # Plot one more particle with purple color,  # pentagon shape and bigger size (default is s=30):  p2   =   randominside ( bt )  plot_particle ( p2 ;   color = ( 0.5 ,   0 ,   0.8 ),   marker = p ,   s = 60.0 )   which should give you something like this (notice that the particle position and direction are random):", 
            "title": "Plotting particles"
        }, 
        {
            "location": "/tutorials/visualizing/#color-conventions", 
            "text": "The default plotting settings have been chosen for maximum clarity and consistency. The color conventions followed are:   Particles are black.  Particle orbits/trajectories are blue.  Reflecting obstacles (e.g.  Disk  or  FiniteWall ) are green.  Randomly reflecting obstacles (e.g.  RandomDisk  or  RandomWall ) are yellow.  Ray-splitting obstacles are red with dashed linestyle.  Periodicity enforcing obstacles are purple with dotted linestyle (if and when plotted).", 
            "title": "Color conventions"
        }, 
        {
            "location": "/tutorials/visualizing/#animating-the-motion-of-a-particle", 
            "text": "The function  animate_evolution  is provided to animate the evolution of a particle from collision to collision, using the default arguments. Its  documentation string  contains all the information necessary for its usage.  Automatic output into an animated image (e.g. \".gif\" format) is not yet supported. However,  animate_evolution  gives users the possibility to save each produce figure in order to merge as an animation using an external tool.  Let's animate a particle inside a simple pentagon with magnetic field:  bt   =   billiard_polygon ( 5 ,   1 )  a   =   Disk ([ 0.0 , 0.0 ],   0.4 )  push! ( bt ,   a )  plot_billiard ( bt )  p   =   randominside ( bt ,   1.0 )   # second argument is magnetic field strength  savedir   =   C: \\\\ some_path \\\\ anim1  animate_evolution ( p ,   bt ,   50 ;   savefigs   =   true ,   savename   =   savedir )   This code produced 50 \".png\" images which were later mixed (using e.g.  gifmaker ) into a single \".gif\" animation. The output figures have a dpi=60 and therefore take only a dozen kb of space. The animation produced should look like:", 
            "title": "Animating the motion of a particle"
        }, 
        {
            "location": "/tutorials/visualizing/#periodic-billiards", 
            "text": "In order to plot periodic billiards, you have need to call a different method of  plot_billiard , since now you also have to specify the limits of plotting. The methods provided are:  plot_billiard ( bt ,   xmin ,   ymin ,   xmax ,   ymax )  plot_billiard ( bt ,   xt :: Vector { T },   yt :: Vector { T })   The last one conveniently plots the combo of particle-trajectory and periodic-billiard taking care of all the details internally. Give the keyword  plot_orbit = false  if you do not want to plot the orbit defined by  (xt, yt) .  For example, the following code  using   DynamicalBilliards ,   DynamicalBilliardsPlotting  r   =   0.25  bt   =   billiard_rectangle ( 2 ,   1 ;   setting   =   periodic )  d   =   Disk ([ 0.5 ,   0.5 ],   r )  d2   =   Disk ([ 1.5 ,   0.5 ],   r / 2 )  push! ( bt ,   d ,   d2 )  p   =   randominside ( bt )  xt ,   yt ,   vxt ,   vyt ,   t   =   construct ( evolve! ( p ,   bt ,   50 ) ... )  plot_billiard ( bt ,   xt ,   yt )  plot_particle ( p )   will produce something like this:   Animations for periodic billiards are not supported yet.", 
            "title": "Periodic Billiards"
        }, 
        {
            "location": "/tutorials/own_obstacle/", 
            "text": "Creating your own \nObstacle\n Type\n\n\nThis tutorial will be about how to create your own obstacle type.", 
            "title": "Creating your own Obstacle"
        }, 
        {
            "location": "/tutorials/own_obstacle/#creating-your-own-obstacle-type", 
            "text": "This tutorial will be about how to create your own obstacle type.", 
            "title": "Creating your own Obstacle Type"
        }, 
        {
            "location": "/tutorials/examples/", 
            "text": "This section has some examples of usage of \nDynamicalBilliards.jl\n, with some brief comments.\n\n\n\n\nJulia-logo Billiard\n\n\nThe \"Julia-logo\" billiard, accessed by \nbilliard_julia()\n simply wraps this code:\n\n\nusing\n \nDynamicalBilliards\n,\n \nDynamicalBilliardsPlotting\n,\n \nPyPlot\n\n\n\nbt\n \n=\n \nObstacle\n{\nFloat64\n}[]\n\n\nbt\n \n=\n \nbilliard_rectangle\n()\n\n\nfor\n \nw\n \nin\n \nbt\n\n  \nplot_obstacle\n(\nw\n;\n \ncolor\n \n=\n \n(\n0\n,\n0\n,\n0\n,\n \n1\n),\n \nlinewidth\n \n=\n \n3.0\n)\n\n\nend\n\n\n\nr\n \n=\n \n0.165\n\n\newidth\n \n=\n \n6.0\n\n\nredcent\n \n=\n \n[\n0.28\n,\n \n0.32\n]\n\n\nred\n \n=\n \nDisk\n(\nredcent\n,\n \nr\n,\n \nred\n)\n\n\nplot_obstacle\n(\nred\n;\n \nedgecolor\n \n=\n \n(\n203\n/\n255\n,\n \n60\n/\n255\n,\n \n51\n/\n255\n),\n\n\nfacecolor\n \n=\n \n(\n213\n/\n255\n,\n \n99\n/\n255\n,\n \n92\n/\n255\n),\n \nlinewidth\n \n=\n \newidth\n)\n\n\n\npurple\n \n=\n \nDisk\n([\n1\n \n-\n \nredcent\n[\n1\n],\n \nredcent\n[\n2\n]],\n \nr\n,\n \npurple\n)\n\n\nplot_obstacle\n(\npurple\n;\n \nedgecolor\n \n=\n \n(\n149\n/\n255\n,\n \n88\n/\n255\n,\n \n178\n/\n255\n),\n\n\nfacecolor\n \n=\n \n(\n170\n/\n255\n,\n \n121\n/\n255\n,\n \n193\n/\n255\n),\n \nlinewidth\n \n=\n \newidth\n)\n\n\n\ngreen\n \n=\n \nDisk\n([\n0.5\n,\n \n1\n \n-\n \nredcent\n[\n2\n]],\n \nr\n,\n \ngreen\n)\n\n\nplot_obstacle\n(\ngreen\n,\n \nedgecolor\n \n=\n \n(\n56\n/\n255\n,\n \n152\n/\n255\n,\n \n38\n/\n255\n),\n\n\nfacecolor\n \n=\n \n(\n96\n/\n255\n,\n \n173\n/\n255\n,\n \n81\n/\n255\n),\n \nlinewidth\n \n=\n \newidth\n)\n\n\n\npush!\n(\nbt\n,\n \nred\n,\n \npurple\n,\n \ngreen\n)\n\n\n# particle colors\n\n\ndarkblue\n \n=\n \n(\n64\n/\n255\n,\n \n99\n/\n255\n,\n \n216\n/\n255\n)\n\n\nlightblue\n \n=\n \n(\n102\n/\n255\n,\n \n130\n/\n255\n,\n \n223\n/\n255\n)\n\n\n\np\n \n=\n \nrandominside\n(\nbt\n,\n \n2.0\n)\n\n\n\nPyPlot\n.\naxis\n(\noff\n)\n\n\nPyPlot\n.\ntight_layout\n()\n\n\nPyPlot\n.\ngca\n()[\n:\nset_aspect\n](\nequal\n)\n\n\nPyPlot\n.\nxlim\n(\n-\n0.1\n,\n1.1\n)\n\n\nPyPlot\n.\nylim\n(\n-\n0.1\n,\n1.1\n)\n\n\n\nokwargs\n \n=\n \nDict\n(\n:\nlinewidth\n \n=\n \n2.0\n,\n \n:\ncolor\n \n=\n \nlightblue\n)\n\n\npkwargs\n \n=\n \nDict\n(\n:\ncolor\n \n=\n \ndarkblue\n,\n \n:\ns\n \n=\n \n150.0\n)\n\n\n\n# create and save the animation:\n\n\nsname\n \n=\n \nC:\n\\\\\n***\n\\\\\nanim\n\n\nanimate_evolution\n(\np\n,\n \nbt\n,\n \n200\n;\n \ncol_to_plot\n \n=\n \n7\n,\n\n\nparticle_kwargs\n \n=\n \npkwargs\n,\n \norbit_kwargs\n \n=\n \nokwargs\n,\n\n\nsavefigs\n \n=\n \ntrue\n,\n \nsavename\n \n=\n \nsname\n)\n\n\n\n\n\n\nand produces:\n\n\n\n\n\n\nMean Free Path of the Lorentz Gas\n\n\nusing\n \nDynamicalBilliards\n\n\nbt\n \n=\n \nbilliard_lorentz\n(\n0.2\n)\n \n#alias for billiard_sinai(setting = \nperiodic\n)\n\n\nmfp\n \n=\n \n0.0\n\n\nfor\n \ni\n \nin\n \n1\n:\n1000\n\n  \np\n \n=\n \nrandominside\n(\nbt\n)\n\n  \nct\n,\n \nposs\n,\n \nvels\n \n=\n \nevolve!\n(\np\n,\n \nbt\n,\n \n10000.0\n)\n\n  \n#skip first two entries because they are not \nfull\n collisions:\n\n  \nmfp\n \n+=\n \nmean\n(\nct\n[\n3\n:\nend\n])\n\n\nend\n\n\nmfp\n \n/=\n \n1000\n\n\n\n\n\n\ngives the value of \n2.1899...\n which is very close to the analytic result:\n\n\n\\(\\text{m.f.p.} =  \\frac{1-\\pi r^2 }{2r} \\stackrel{r=0.2}{=} 2.18584\\)\n\n\nwhich you can find for example \nhere\n.\n\n\n\n\nSemi-Periodic Billiard\n\n\nDynamicalBilliards.jl\n allows for your system to be periodic in only some specific directions. For example, the following code produces a billiard that is periodic in only the x-direction:\n\n\nusing\n \nDynamicalBilliards\n\n\no\n \n=\n \n0.0\n;\n \nx\n \n=\n \n2.0\n;\n \ny\n=\n1.0\n\n\nbt\n \n=\n \nObstacle\n{\nFloat64\n}[]\n\n\n\nsp\n \n=\n \n[\no\n,\no\n];\n \nep\n \n=\n \n[\no\n,\n \ny\n];\n \nn\n \n=\n \n[\nx\n,\no\n]\n\n\nleftw\n \n=\n \nPeriodicWall\n(\nsp\n,\n \nep\n,\n \nn\n,\n \nLeft periodic boundary\n)\n\n\nsp\n \n=\n \n[\nx\n,\no\n];\n \nep\n \n=\n \n[\nx\n,\n \ny\n];\n \nn\n \n=\n \n[\n-\nx\n,\no\n]\n\n\nrightw\n \n=\n \nPeriodicWall\n(\nsp\n,\n \nep\n,\n \nn\n,\n \nRight periodic boundary\n)\n\n\n\nsp\n \n=\n \n[\no\n,\ny\n];\n \nep\n \n=\n \n[\nx\n,\n \ny\n];\n \nn\n \n=\n \n[\no\n,\n-\ny\n]\n\n\ntopw2\n \n=\n \nFiniteWall\n(\nsp\n,\n \nep\n,\n \nn\n,\n \nTop wall\n)\n\n\nsp\n \n=\n \n[\no\n,\no\n];\n \nep\n \n=\n \n[\nx\n,\n \no\n];\n \nn\n \n=\n \n[\no\n,\ny\n]\n\n\nbotw2\n \n=\n \nFiniteWall\n(\nsp\n,\n \nep\n,\n \nn\n,\n \nBottom wall\n)\n\n\npush!\n(\nbt\n,\n \nleftw\n,\n \nrightw\n,\n \ntopw2\n,\n \nbotw2\n)\n\n\n\nr\n \n=\n \n0.25\n\n\nd\n \n=\n \nDisk\n([\n0.5\n,\n \n0.5\n],\n \nr\n)\n\n\nd2\n \n=\n \nDisk\n([\n1.5\n,\n \n0.5\n],\n \nr\n/\n2\n)\n\n\npush!\n(\nbt\n,\n \nd\n,\n \nd2\n)\n\n\n\np\n \n=\n \nrandominside\n(\nbt\n,\n \n0.5\n)\n\n\nxt\n,\n \nyt\n,\n \nvxt\n,\n \nvyt\n,\n \nt\n \n=\n \nconstruct\n(\nevolve!\n(\np\n,\n \nbt\n,\n \n25\n)\n...\n)\n\n\nplot_billiard\n(\nbt\n,\n \nxt\n,\n \nyt\n)\n\n\nplot_particle\n(\np\n)\n\n\n\n\n\n\nResult:\n\n\n\n\n\n\nRay-Splitting\n\n\nThe following code produces an animation of a Ray-Splitting billiard:\n\n\nusing\n \nDynamicalBilliards\n,\n \nPyPlot\n\n\n\nbt\n \n=\n \nbilliard_rectangle\n(\n2\n,\n \n1\n)\n\n\nsw\n \n=\n \nSplitterWall\n([\n1.0\n,\n \n0.0\n],\n \n[\n1\n,\n1\n],\n \n[\n-\n1\n,\n0\n],\n \ntrue\n)\n\n\npush!\n(\nbt\n,\n \nsw\n)\n\n\na1\n \n=\n \nAntidot\n([\n0.5\n,\n \n0.5\n],\n \n0.3\n)\n\n\npush!\n(\nbt\n,\n \na1\n)\n\n\na2\n \n=\n \nAntidot\n([\n1.5\n,\n \n0.5\n],\n \n0.2\n)\n\n\npush!\n(\nbt\n,\n \na2\n)\n\n\n\nsa\n \n=\n \n(\n\u03b8\n,\n \nwhere\n,\n \n\u03c9\n)\n \n-\n \nwhere\n \n?\n \n1.25\n*\n\u03b8\n \n:\n \n0.8\n*\n\u03b8\n\n\nTp\n \n=\n \n(\np\n)\n \n-\n \n(\n\u03b8\n,\n \nwhere\n,\n \n\u03c9\n)\n \n-\n \nbegin\n\n  \nif\n \nwhere\n\n    \nabs\n(\n\u03b8\n)\n \n \n\u03c0\n/\n2\n/\n1.25\n \n?\n \np\n*\nexp\n(\n-\n(\n\u03b8\n)\n^\n2\n/\n2\n(\n\u03c0\n/\n8\n)\n^\n2\n)\n \n:\n \n0.0\n\n  \nelse\n\n    \n(\np\n)\n*\nexp\n(\n-\n(\n\u03b8\n)\n^\n2\n/\n2\n(\n\u03c0\n/\n4\n)\n^\n2\n)\n\n  \nend\n\n\nend\n\n\nnewo\n \n=\n \n((\nx\n,\n \nbool\n)\n \n-\n \nbool\n \n?\n \n-\n2.0\nx\n \n:\n \n-\n0.5\nx\n)\n\n\nnewo2\n \n=\n \n((\nx\n,\n \nbool\n)\n \n-\n \nbool\n \n?\n \n-\nx\n \n:\n \n-\nx\n)\n\n\nrayspl\n \n=\n \nDict\n(\n\n\n5\n \n=\n \n(\nTp\n(\n0.9\n),\n \nsa\n,\n \nnewo2\n),\n\n\n6\n \n=\n \n(\nTp\n(\n0.7\n),\n \nsa\n,\n \nnewo\n),\n\n\n7\n \n=\n \n(\nTp\n(\n0.65\n),\n \nsa\n,\n \nnewo\n))\n\n\n\np\n \n=\n \nrandominside\n(\nbt\n,\n \n1.0\n)\n\n\nplot_billiard\n(\nbt\n)\n\n\n\nsavedir\n \n=\n \nC:\n\\\\\n***\n\\\\\nanim\n\n\nanimate_evolution\n(\np\n,\n \nbt\n,\n \n200\n,\n \nrayspl\n,\n \nsavefigs\n \n=\n \ntrue\n,\n \nsavename\n \n=\n \nsavedir\n)\n\n\n\n\n\n\nresult:", 
            "title": "Examples"
        }, 
        {
            "location": "/tutorials/examples/#julia-logo-billiard", 
            "text": "The \"Julia-logo\" billiard, accessed by  billiard_julia()  simply wraps this code:  using   DynamicalBilliards ,   DynamicalBilliardsPlotting ,   PyPlot  bt   =   Obstacle { Float64 }[]  bt   =   billiard_rectangle ()  for   w   in   bt \n   plot_obstacle ( w ;   color   =   ( 0 , 0 , 0 ,   1 ),   linewidth   =   3.0 )  end  r   =   0.165  ewidth   =   6.0  redcent   =   [ 0.28 ,   0.32 ]  red   =   Disk ( redcent ,   r ,   red )  plot_obstacle ( red ;   edgecolor   =   ( 203 / 255 ,   60 / 255 ,   51 / 255 ),  facecolor   =   ( 213 / 255 ,   99 / 255 ,   92 / 255 ),   linewidth   =   ewidth )  purple   =   Disk ([ 1   -   redcent [ 1 ],   redcent [ 2 ]],   r ,   purple )  plot_obstacle ( purple ;   edgecolor   =   ( 149 / 255 ,   88 / 255 ,   178 / 255 ),  facecolor   =   ( 170 / 255 ,   121 / 255 ,   193 / 255 ),   linewidth   =   ewidth )  green   =   Disk ([ 0.5 ,   1   -   redcent [ 2 ]],   r ,   green )  plot_obstacle ( green ,   edgecolor   =   ( 56 / 255 ,   152 / 255 ,   38 / 255 ),  facecolor   =   ( 96 / 255 ,   173 / 255 ,   81 / 255 ),   linewidth   =   ewidth )  push! ( bt ,   red ,   purple ,   green )  # particle colors  darkblue   =   ( 64 / 255 ,   99 / 255 ,   216 / 255 )  lightblue   =   ( 102 / 255 ,   130 / 255 ,   223 / 255 )  p   =   randominside ( bt ,   2.0 )  PyPlot . axis ( off )  PyPlot . tight_layout ()  PyPlot . gca ()[ : set_aspect ]( equal )  PyPlot . xlim ( - 0.1 , 1.1 )  PyPlot . ylim ( - 0.1 , 1.1 )  okwargs   =   Dict ( : linewidth   =   2.0 ,   : color   =   lightblue )  pkwargs   =   Dict ( : color   =   darkblue ,   : s   =   150.0 )  # create and save the animation:  sname   =   C: \\\\ *** \\\\ anim  animate_evolution ( p ,   bt ,   200 ;   col_to_plot   =   7 ,  particle_kwargs   =   pkwargs ,   orbit_kwargs   =   okwargs ,  savefigs   =   true ,   savename   =   sname )   and produces:", 
            "title": "Julia-logo Billiard"
        }, 
        {
            "location": "/tutorials/examples/#mean-free-path-of-the-lorentz-gas", 
            "text": "using   DynamicalBilliards  bt   =   billiard_lorentz ( 0.2 )   #alias for billiard_sinai(setting =  periodic )  mfp   =   0.0  for   i   in   1 : 1000 \n   p   =   randominside ( bt ) \n   ct ,   poss ,   vels   =   evolve! ( p ,   bt ,   10000.0 ) \n   #skip first two entries because they are not  full  collisions: \n   mfp   +=   mean ( ct [ 3 : end ])  end  mfp   /=   1000   gives the value of  2.1899...  which is very close to the analytic result:  \\(\\text{m.f.p.} =  \\frac{1-\\pi r^2 }{2r} \\stackrel{r=0.2}{=} 2.18584\\)  which you can find for example  here .", 
            "title": "Mean Free Path of the Lorentz Gas"
        }, 
        {
            "location": "/tutorials/examples/#semi-periodic-billiard", 
            "text": "DynamicalBilliards.jl  allows for your system to be periodic in only some specific directions. For example, the following code produces a billiard that is periodic in only the x-direction:  using   DynamicalBilliards  o   =   0.0 ;   x   =   2.0 ;   y = 1.0  bt   =   Obstacle { Float64 }[]  sp   =   [ o , o ];   ep   =   [ o ,   y ];   n   =   [ x , o ]  leftw   =   PeriodicWall ( sp ,   ep ,   n ,   Left periodic boundary )  sp   =   [ x , o ];   ep   =   [ x ,   y ];   n   =   [ - x , o ]  rightw   =   PeriodicWall ( sp ,   ep ,   n ,   Right periodic boundary )  sp   =   [ o , y ];   ep   =   [ x ,   y ];   n   =   [ o , - y ]  topw2   =   FiniteWall ( sp ,   ep ,   n ,   Top wall )  sp   =   [ o , o ];   ep   =   [ x ,   o ];   n   =   [ o , y ]  botw2   =   FiniteWall ( sp ,   ep ,   n ,   Bottom wall )  push! ( bt ,   leftw ,   rightw ,   topw2 ,   botw2 )  r   =   0.25  d   =   Disk ([ 0.5 ,   0.5 ],   r )  d2   =   Disk ([ 1.5 ,   0.5 ],   r / 2 )  push! ( bt ,   d ,   d2 )  p   =   randominside ( bt ,   0.5 )  xt ,   yt ,   vxt ,   vyt ,   t   =   construct ( evolve! ( p ,   bt ,   25 ) ... )  plot_billiard ( bt ,   xt ,   yt )  plot_particle ( p )   Result:", 
            "title": "Semi-Periodic Billiard"
        }, 
        {
            "location": "/tutorials/examples/#ray-splitting", 
            "text": "The following code produces an animation of a Ray-Splitting billiard:  using   DynamicalBilliards ,   PyPlot  bt   =   billiard_rectangle ( 2 ,   1 )  sw   =   SplitterWall ([ 1.0 ,   0.0 ],   [ 1 , 1 ],   [ - 1 , 0 ],   true )  push! ( bt ,   sw )  a1   =   Antidot ([ 0.5 ,   0.5 ],   0.3 )  push! ( bt ,   a1 )  a2   =   Antidot ([ 1.5 ,   0.5 ],   0.2 )  push! ( bt ,   a2 )  sa   =   ( \u03b8 ,   where ,   \u03c9 )   -   where   ?   1.25 * \u03b8   :   0.8 * \u03b8  Tp   =   ( p )   -   ( \u03b8 ,   where ,   \u03c9 )   -   begin \n   if   where \n     abs ( \u03b8 )     \u03c0 / 2 / 1.25   ?   p * exp ( - ( \u03b8 ) ^ 2 / 2 ( \u03c0 / 8 ) ^ 2 )   :   0.0 \n   else \n     ( p ) * exp ( - ( \u03b8 ) ^ 2 / 2 ( \u03c0 / 4 ) ^ 2 ) \n   end  end  newo   =   (( x ,   bool )   -   bool   ?   - 2.0 x   :   - 0.5 x )  newo2   =   (( x ,   bool )   -   bool   ?   - x   :   - x )  rayspl   =   Dict (  5   =   ( Tp ( 0.9 ),   sa ,   newo2 ),  6   =   ( Tp ( 0.7 ),   sa ,   newo ),  7   =   ( Tp ( 0.65 ),   sa ,   newo ))  p   =   randominside ( bt ,   1.0 )  plot_billiard ( bt )  savedir   =   C: \\\\ *** \\\\ anim  animate_evolution ( p ,   bt ,   200 ,   rayspl ,   savefigs   =   true ,   savename   =   savedir )   result:", 
            "title": "Ray-Splitting"
        }, 
        {
            "location": "/physics/", 
            "text": "This page briefly discusses physical aspects of billiard systems.\n\n\n\n\nImplementation\n\n\nFirstly one defines a billiard table and (if desired) the \nray-splitting dictionary\n. Then one creates a particle inside the defined billiard table. The algorithm followed for the propagation of a particle is the following:\n\n\n\n\nCalculate the \ncollisiontime()\n for \nall\n obstacles in the billiard table.\n\n\nFind the smallest time, and the obstacle corresponding to that.\n\n\nrelocate!()\n the particle, so that it is on the correct side of the obstacle to-be-collided with.\n\n\nCheck whether there is transmission or not (only for ray-splitting): \nT(\u03c6) \n rand()\n\n\n\n\nresolvecollision!()\n between the particle and obstacle:\n\n\n\n\nIf transmission happens, once again \nrelocate!()\n the particle accordingly and implement the ray-splitting algorithm (not discussed here).\n\n\nFor no transmission (or no ray-splitting), perform \nspecular!()\n reflection or \nperiodicity!()\n conditions based on the colliding obstacle.\n\n\nContinue this loop for a given amount of time.\n\n\n\n\n\n\n\n\nIn the standard billiard case, one can always exclude the collision with the previous obstacle. However, in both magnetic or ray-splitting cases this is not true anymore. Therefore the same algorithm is applied on all 3 cases for the sake of simplicity.\n\n\nNotice that the \nrelocate!()\n step is \nvery\n important because it takes care that there is not particle \"leakage\": particles being outside the billiard table due to the finite precision of floating numbers.\n\n\n\n\n\n\nNumerical Precision\n\n\nAll core types of \nDynamicalBilliards.jl\n are parametrically constructed, with parameter \nT\n:\nAbstractFloat\n. This means that the fields of all particles are obstacles contain numbers strictly of type \nT\n.\n\n\nThe main concerns during evolution are:\n\n\n\n\nThe particle must neve leaks out of the billiard table. This is simply translated to the \ndistance()\n function being \nalways\n positive \nafter\n any collision.\n\n\nThe collision time is never infinite, besides the cases of \npinned particles\n in a magnetic billiard.\n\n\nThe \nrelocate!()\n process is always finite (and very swift!).\n\n\n\n\nThese are solved with the following approach: after the minimum collision time has been calculated, a \"test propagation\" is done on the position of the particle. If the \ndistance\n(\np\n,\n \nobst\n)\n with the colliding obstacle is found to be \"wrong\", the collision time is reduced by the \nDynamicalBilliards\n.\ntimeprec\n(\nT\n)\n function, with \nT\n being the parametric type of both the particle and the obstacle. For the case of magnetic propagation, the function \ntimeprec_severe(T)\n is used instead. This process is repeated until the \ndistance()\n is \"correct\", which is followed by the real propagation of the particle for the adjusted time.\n\n\n\n\nDefinition of time-precision functions\n\n\nFor \nT\n:AbstractFloat\n, \ntimeprec(T) = eps(T)^(4/5)\n and \ntimeprec_severe(T) = sqrt(eps(T))\n\n\n\n\nThis means that the precision of evolution cannot be greater than the respective precision functions. The current values have been chosen such that the time-adjusting loop happens only once for almost all cases.\n\n\nAdjusting the global accuracy of \nDynamicalBilliards\n is very easy and can be done in two ways:\n\n\n\n\nChoose the floating precision you would like, by initializing your billiard table with parametric type \nT\n, e.g. \nbt = billiard_sinai(Float16(0.3))\n. This choice will propagate to the entire \nbt\n, all particles resulting from \nrandominside()\n, \nas well as the entire evolution process\n.\n\n\nRe-define the functions \ntimeprec(T)\n and \ntimeprec_severe(T)\n. Decreasing their values will make the evolution process slower, but the resulting numbers given by \nevolve!()\n will be more precise.\n\n\n\n\n\n\nLimits of numerical precision\n\n\nIt is not advisable to lower \ntimeprec(T)\n to \n10eps(T)\n or less, or lower \ntimeprec_severe(T)\n to \neps(T)^(3/4)\n or less, as these choice tend to make the package very slow.\n\n\n\n\n\n\n\n\nRay-Splitting Functions\n\n\nIf \nT\n is the transmission probability function, then the condition for transmission is simply: \nT(\u03c6, pflag, \u03c9) \n rand()\n. If it returns \ntrue\n, transmission (i.e. ray-splitting) will happen. As it has already been discussed in the \nRay-Splitting tutorial\n, the condition of total internal reflection must be taken care of by the user.\n\n\nThe \nthree key functions\n given to the \nray-splitter\n dictionary must have some properties in order to have physical meaning, like for example that the scattering probability function is even towards \u03c6. One of these properties is absolutely \nmandatory\n for this package to work properly. This is the property of total internal reflection, i.e. if the refraction angle is calculated to be greater/equal than \u03c0/2, no transmission can happen. \nThis condition is not assured internally\n and therefore you must be sure that your transmission probability function satisfies it. In the above example, the function \nT\n makes sure to return 0 in that case.\n\n\nIn order to test if the \nraysplitter\n dictionary you have defined has physical meaning, the function \nisphysical()\n is provided:\n\n\nisphysical\n(\nraysplitter\n::\nDict\n{\nInt\n,\n \nAny\n};\n \nonly_mandatory\n \n=\n \nfalse\n)\n\n\n\n\n\n\nReturn \ntrue\n if the given ray-splitting dictionary has physically plausible properties.\n\n\nSpecifically, check if (\u03c6 is the incidence angle, \u03b8 the refraction angle):\n\n\n\n\nCritical angle means total reflection: If \u03b8(\u03c6) \u2265 \u03c0/2 then T(\u03c6) = 0\n\n\nTransmission probability is even function: T(\u03c6) \u2248 T(-\u03c6) at \u03c9 = 0\n\n\nRefraction angle is odd function: \u03b8(\u03c6) \u2248 -\u03b8(-\u03c6) at \u03c9 = 0\n\n\nRay reversal is true: \u03b8(\u03b8(\u03c6, pflag, \u03c9), !pflag, \u03c9) \u2248 \u03c6\n\n\nMagnetic conservation is true: (\u03c9_new(\u03c9_new(\u03c9, pflag), !pflag) \u2248 \u03c9\n\n\n\n\nThe first property is mandatory and must hold for correct propagation. The above tests are done for all possible combinations of arguments.\n\n\nThey keyword \nonly_mandatory\n notes whether the rest of the properties should be tested or not.\n\n\n\n\n\n\nPinned Particles\n\n\nIn the case of propagation with magnetic field, a particle may be \"pinned\" (collision-less): There are no possible collisions that take place and the particle will revolve in circles forever. This can happen for specific initial conditions depending on your billiard table and the angular velocity \u03c9.\n\n\nIn such event, the convention followed by \nDynamicalBilliards.jl\n is the following: \nevolve!()\n returns the expected output, however all returned vectors have only 2 entries. The collision times always have the entries \n0.0, Inf\n. All other returned vectors have the initial conditions, repeated once.\n\n\nevolve!()\n can be given an additional \nwarning\n keyword argument in the case of magnetic propagation, e.g. \nwarning = true\n. This optional argument throws a \nwarn()\n message whenever a pinned particle is evolved.\n\n\n\n\nUsing \nconstruct()\n\n\nWhen using the syntax \nconstruct(evolve!(p, bt, t)...)\n be sure that there aren't any pinned particles given to evolve. If there are any, construct will result in an error.\n\n\n\n\n\n\n\n\nVelocity measure\n\n\nBoth \nParticle\n and \nMagneticParticle\n are assumed to \nalways\n have a velocity vector of measure 1 during evolution. This simplifies the formulas used internally to a significant amount.\n\n\nHowever, during ray-splitting, the a \nMagneticParticle\n may be in areas with different angular velocities (result of the \n\u03c9_new\n function). Physically, in such a situation, the velocity measure of the particle could also change. This change depends on the forces acting on the particle (e.g. magnetic field) as well as the relation of the momentum with the velocity (functional type of kinetic energy).\n\n\nIn any case, such a change is not accounted for internally by \nDynamicalBilliards\n. However it is very easy to implement this by \"re-normalizing\" the angular velocities you use. Since the \"code\" velocity has measure one, the rotation radius is given by\n\n\n\\[\nr = \\frac{1}{\\omega_\\text{code}} = \\frac{v_\\text{real}}{\\omega_\\text{real}}\n\\]\nthen one simply has to adjust the values of \n\u03c9\n given in the code with\n\n\n\\[\n\\omega_\\text{code} = \\frac{\\omega_\\text{real}}{v_\\text{real}}\n\\]\nAfter getting the timeseries from \nconstruct()\n:\n\n\n# These are the \ncode\n-data. |v| = 1 always\n\n\nct\n,\n \nposs\n,\n \nvels\n,\n \nomegas\n \n=\n \nevolve!\n(\np\n,\n \nbt\n,\n \nttotal\n,\n \nray_splt\n)\n\n\nxt\n,\n \nyt\n,\n \nvxt\n,\n \nvyt\n,\n \nt\n \n=\n \nconstruct\n(\nct\n,\n \nposs\n,\n \nvels\n,\n \nomegas\n)\n\n\n\n\n\n\nyou only need to make some final adjustment on the \nvxt, vyt\n. The position and time data are completely unaffected.\n\n\nomegas_code\n \n=\n \nomegas\n\n\n# real angular velocities:\n\n\nomegas_real\n \n=\n \nsupplied_by_user\n\n\n# or with some user provided function:\n\n\nf\n \n=\n \no\n \n-\n \n(\no\n \n==\n \n0.5\n \n?\n \n2\no\n \n:\n \no\n*\u221a\n2\n)\n\n\nomegas_real\n \n=\n \nf\n.\n(\nomegas_code\n)\n\n\n# real velocity measure:\n\n\nvels_real\n \n=\n \nabs\n.\n(\nomegas_real\n \n./\n \nomegas_code\n)\n\n\n\ncontt\n \n=\n \ncumsum\n(\nct\n)\n\n\nomega_t\n \n=\n \nzeros\n(\nt\n)\n\n\nvxtreal\n \n=\n \ncopy\n(\nvxt\n)\n\n\nvytreal\n \n=\n \ncopy\n(\nvyt\n)\n\n\nj\n \n=\n \n1\n\n\nfor\n \ni\n \nin\n \neachindex\n(\nt\n)\n\n  \nvxtreal\n[\ni\n]\n \n*=\n \nvels_real\n[\nj\n]\n\n  \nvytreal\n[\ni\n]\n \n*=\n \nvels_real\n[\nj\n]\n\n  \nomega_t\n[\ni\n]\n \n=\n \nomegas_real\n[\nj\n]\n\n\n  \nif\n \nt\n[\ni\n]\n \n=\n  \ncontt\n[\nj\n]\n\n    \nj\n \n+=\n \n1\n\n  \nend\n\n\nend\n\n\n\n\n\n\nNow you can be sure that the particle at time \nt[i]\n had real velocity \n[vxtreal[i], vytreal[i]]\n and was propagating with real angular velocity \nomega_t[i]\n.", 
            "title": "Physics"
        }, 
        {
            "location": "/physics/#implementation", 
            "text": "Firstly one defines a billiard table and (if desired) the  ray-splitting dictionary . Then one creates a particle inside the defined billiard table. The algorithm followed for the propagation of a particle is the following:   Calculate the  collisiontime()  for  all  obstacles in the billiard table.  Find the smallest time, and the obstacle corresponding to that.  relocate!()  the particle, so that it is on the correct side of the obstacle to-be-collided with.  Check whether there is transmission or not (only for ray-splitting):  T(\u03c6)   rand()   resolvecollision!()  between the particle and obstacle:   If transmission happens, once again  relocate!()  the particle accordingly and implement the ray-splitting algorithm (not discussed here).  For no transmission (or no ray-splitting), perform  specular!()  reflection or  periodicity!()  conditions based on the colliding obstacle.  Continue this loop for a given amount of time.     In the standard billiard case, one can always exclude the collision with the previous obstacle. However, in both magnetic or ray-splitting cases this is not true anymore. Therefore the same algorithm is applied on all 3 cases for the sake of simplicity.  Notice that the  relocate!()  step is  very  important because it takes care that there is not particle \"leakage\": particles being outside the billiard table due to the finite precision of floating numbers.", 
            "title": "Implementation"
        }, 
        {
            "location": "/physics/#numerical-precision", 
            "text": "All core types of  DynamicalBilliards.jl  are parametrically constructed, with parameter  T : AbstractFloat . This means that the fields of all particles are obstacles contain numbers strictly of type  T .  The main concerns during evolution are:   The particle must neve leaks out of the billiard table. This is simply translated to the  distance()  function being  always  positive  after  any collision.  The collision time is never infinite, besides the cases of  pinned particles  in a magnetic billiard.  The  relocate!()  process is always finite (and very swift!).   These are solved with the following approach: after the minimum collision time has been calculated, a \"test propagation\" is done on the position of the particle. If the  distance ( p ,   obst )  with the colliding obstacle is found to be \"wrong\", the collision time is reduced by the  DynamicalBilliards . timeprec ( T )  function, with  T  being the parametric type of both the particle and the obstacle. For the case of magnetic propagation, the function  timeprec_severe(T)  is used instead. This process is repeated until the  distance()  is \"correct\", which is followed by the real propagation of the particle for the adjusted time.   Definition of time-precision functions  For  T :AbstractFloat ,  timeprec(T) = eps(T)^(4/5)  and  timeprec_severe(T) = sqrt(eps(T))   This means that the precision of evolution cannot be greater than the respective precision functions. The current values have been chosen such that the time-adjusting loop happens only once for almost all cases.  Adjusting the global accuracy of  DynamicalBilliards  is very easy and can be done in two ways:   Choose the floating precision you would like, by initializing your billiard table with parametric type  T , e.g.  bt = billiard_sinai(Float16(0.3)) . This choice will propagate to the entire  bt , all particles resulting from  randominside() ,  as well as the entire evolution process .  Re-define the functions  timeprec(T)  and  timeprec_severe(T) . Decreasing their values will make the evolution process slower, but the resulting numbers given by  evolve!()  will be more precise.    Limits of numerical precision  It is not advisable to lower  timeprec(T)  to  10eps(T)  or less, or lower  timeprec_severe(T)  to  eps(T)^(3/4)  or less, as these choice tend to make the package very slow.", 
            "title": "Numerical Precision"
        }, 
        {
            "location": "/physics/#ray-splitting-functions", 
            "text": "If  T  is the transmission probability function, then the condition for transmission is simply:  T(\u03c6, pflag, \u03c9)   rand() . If it returns  true , transmission (i.e. ray-splitting) will happen. As it has already been discussed in the  Ray-Splitting tutorial , the condition of total internal reflection must be taken care of by the user.  The  three key functions  given to the  ray-splitter  dictionary must have some properties in order to have physical meaning, like for example that the scattering probability function is even towards \u03c6. One of these properties is absolutely  mandatory  for this package to work properly. This is the property of total internal reflection, i.e. if the refraction angle is calculated to be greater/equal than \u03c0/2, no transmission can happen.  This condition is not assured internally  and therefore you must be sure that your transmission probability function satisfies it. In the above example, the function  T  makes sure to return 0 in that case.  In order to test if the  raysplitter  dictionary you have defined has physical meaning, the function  isphysical()  is provided:  isphysical ( raysplitter :: Dict { Int ,   Any };   only_mandatory   =   false )   Return  true  if the given ray-splitting dictionary has physically plausible properties.  Specifically, check if (\u03c6 is the incidence angle, \u03b8 the refraction angle):   Critical angle means total reflection: If \u03b8(\u03c6) \u2265 \u03c0/2 then T(\u03c6) = 0  Transmission probability is even function: T(\u03c6) \u2248 T(-\u03c6) at \u03c9 = 0  Refraction angle is odd function: \u03b8(\u03c6) \u2248 -\u03b8(-\u03c6) at \u03c9 = 0  Ray reversal is true: \u03b8(\u03b8(\u03c6, pflag, \u03c9), !pflag, \u03c9) \u2248 \u03c6  Magnetic conservation is true: (\u03c9_new(\u03c9_new(\u03c9, pflag), !pflag) \u2248 \u03c9   The first property is mandatory and must hold for correct propagation. The above tests are done for all possible combinations of arguments.  They keyword  only_mandatory  notes whether the rest of the properties should be tested or not.", 
            "title": "Ray-Splitting Functions"
        }, 
        {
            "location": "/physics/#pinned-particles", 
            "text": "In the case of propagation with magnetic field, a particle may be \"pinned\" (collision-less): There are no possible collisions that take place and the particle will revolve in circles forever. This can happen for specific initial conditions depending on your billiard table and the angular velocity \u03c9.  In such event, the convention followed by  DynamicalBilliards.jl  is the following:  evolve!()  returns the expected output, however all returned vectors have only 2 entries. The collision times always have the entries  0.0, Inf . All other returned vectors have the initial conditions, repeated once.  evolve!()  can be given an additional  warning  keyword argument in the case of magnetic propagation, e.g.  warning = true . This optional argument throws a  warn()  message whenever a pinned particle is evolved.   Using  construct()  When using the syntax  construct(evolve!(p, bt, t)...)  be sure that there aren't any pinned particles given to evolve. If there are any, construct will result in an error.", 
            "title": "Pinned Particles"
        }, 
        {
            "location": "/physics/#velocity-measure", 
            "text": "Both  Particle  and  MagneticParticle  are assumed to  always  have a velocity vector of measure 1 during evolution. This simplifies the formulas used internally to a significant amount.  However, during ray-splitting, the a  MagneticParticle  may be in areas with different angular velocities (result of the  \u03c9_new  function). Physically, in such a situation, the velocity measure of the particle could also change. This change depends on the forces acting on the particle (e.g. magnetic field) as well as the relation of the momentum with the velocity (functional type of kinetic energy).  In any case, such a change is not accounted for internally by  DynamicalBilliards . However it is very easy to implement this by \"re-normalizing\" the angular velocities you use. Since the \"code\" velocity has measure one, the rotation radius is given by  \\[\nr = \\frac{1}{\\omega_\\text{code}} = \\frac{v_\\text{real}}{\\omega_\\text{real}}\n\\] then one simply has to adjust the values of  \u03c9  given in the code with  \\[\n\\omega_\\text{code} = \\frac{\\omega_\\text{real}}{v_\\text{real}}\n\\] After getting the timeseries from  construct() :  # These are the  code -data. |v| = 1 always  ct ,   poss ,   vels ,   omegas   =   evolve! ( p ,   bt ,   ttotal ,   ray_splt )  xt ,   yt ,   vxt ,   vyt ,   t   =   construct ( ct ,   poss ,   vels ,   omegas )   you only need to make some final adjustment on the  vxt, vyt . The position and time data are completely unaffected.  omegas_code   =   omegas  # real angular velocities:  omegas_real   =   supplied_by_user  # or with some user provided function:  f   =   o   -   ( o   ==   0.5   ?   2 o   :   o *\u221a 2 )  omegas_real   =   f . ( omegas_code )  # real velocity measure:  vels_real   =   abs . ( omegas_real   ./   omegas_code )  contt   =   cumsum ( ct )  omega_t   =   zeros ( t )  vxtreal   =   copy ( vxt )  vytreal   =   copy ( vyt )  j   =   1  for   i   in   eachindex ( t ) \n   vxtreal [ i ]   *=   vels_real [ j ] \n   vytreal [ i ]   *=   vels_real [ j ] \n   omega_t [ i ]   =   omegas_real [ j ] \n\n   if   t [ i ]   =    contt [ j ] \n     j   +=   1 \n   end  end   Now you can be sure that the particle at time  t[i]  had real velocity  [vxtreal[i], vytreal[i]]  and was propagating with real angular velocity  omega_t[i] .", 
            "title": "Velocity measure"
        }, 
        {
            "location": "/basic/library/", 
            "text": "Below you find all the docstrings of all exported names of \nDynamicalBilliards.jl\n in convenient groups.\n\n\n\n\nParticles\n\n\n#\n\n\nDynamicalBilliards.Particle\n \n \nType\n.\n\n\nParticle{T\n:AbstractFloat} \n: AbstractParticle{T}\n\n\n\n\n\nTwo-dimensional particle in a billiard table (mutable type).\n\n\nFields:\n\n\n\n\npos::SVector{2,T}\n : Current position vector.\n\n\nvel::SVector{2,T}\n : Current velocity vector (always of measure 1).\n\n\ncurrent_cell::SVector{2,T}\n : Current \"cell\" the particle is located at. (Used only in periodic billiards)\n\n\n\n\nAdditional constructors:\n\n\nParticle\n(\nic\n::\nVector\n{\nT\n})\n \n#where ic = [x0, y0, \u03c60]\n\n\nParticle\n(\nx\n,\n \ny\n,\n \n\u03c6\n)\n\n\nParticle\n()\n \n=\n \nParticle\n(\nrand\n(),\n \nrand\n(),\n \nrand\n()\n*\n2\n\u03c0\n)\n\n\nParticle\n(\nbt\n::\nVector\n{\n:\nObstacle\n})\n \n=\n \nrandominside\n(\nbt\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.MagneticParticle\n \n \nType\n.\n\n\nMagneticParticle{T\n:AbstractFloat} \n: AbstractParticle{T}\n\n\n\n\n\nTwo-dimensional particle in a billiard table with perpendicular magnetic field (mutable type).\n\n\nFields:\n\n\n\n\npos::SVector{2,T}\n : Current position vector.\n\n\nvel::SVector{2,T}\n : Current velocity vector (always of measure 1).\n\n\ncurrent_cell::SVector{2,T}\n : Current \"cell\" the particle is located at (Used only in periodic billiards).\n\n\nomega::T\n : Angular velocity (cyclic frequency) of rotational motion. Radius of rotation is \nr=1/omega\n.\n\n\n\n\nAdditional constructors:\n\n\nMagneticParticle\n(\nic\n::\nAbstractVector\n{\nT\n},\n \n\u03c9\n::\nReal\n)\n \n#where ic = [x0, y0, \u03c60]\n\n\nMagneticParticle\n(\nx0\n::\nReal\n,\n \ny0\n::\nReal\n,\n \n\u03c60\n::\nReal\n,\n \n\u03c9\n::\nReal\n)\n\n\nMagneticParticle\n()\n \n=\n \nMagneticParticle\n([\nrand\n(),\n \nrand\n(),\n \nrand\n()\n*\n2\n\u03c0\n],\n \n1.0\n)\n\n\nMagneticParticle\n(\nbt\n::\nVector\n{\n:\nObstacle\n},\n \n\u03c9\n)\n \n=\n \nrandominside\n(\nbt\n,\n \n\u03c9\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.cyclotron\n \n \nFunction\n.\n\n\ncyclotron(p::MagneticParticle, use_cell = false)\n\n\n\n\n\nReturn center and radius of circular motion performed by the particle based on \np.pos\n (or \np.pos + p.current_cell\n) and \np.vel\n.\n\n\nsource\n\n\n\n\nObstacles\n\n\n#\n\n\nDynamicalBilliards.Obstacle\n \n \nType\n.\n\n\nObstacle{\n:AbstractFloat}\n\n\n\n\n\nObstacle supertype.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.Circular\n \n \nType\n.\n\n\nCircular{T\n:AbstractFloat} \n: Obstacle{T}\n\n\n\n\n\nCircular obstacle supertype.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.Disk\n \n \nType\n.\n\n\nDisk{T\n:AbstractFloat}  \n: Circular{T}\n\n\n\n\n\nDisk-like obstacle with propagation allowed outside of the circle (immutable type).\n\n\nFields:\n\n\n\n\nc::SVector{2,T}\n : Center.\n\n\nr::T\n : Radius.\n\n\nname::String\n : Some name given for user convenience. Defaults to \"Disk\".\n\n\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.RandomDisk\n \n \nType\n.\n\n\nRandomDisk{T\n:AbstractFloat} \n: Circular{T}\n\n\n\n\n\nDisk-like obstacle that randomly (and uniformly) reflects colliding particles. The propagation is allowed outside of the circle.\n\n\nFields:\n\n\n\n\nc::SVector{2,T}\n : Center.\n\n\nr::T\n : Radius.\n\n\nname::String\n : Some name given for user convenience. Defaults to \"Random disk\".\n\n\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.Antidot\n \n \nType\n.\n\n\nAntidot{T\n:AbstractFloat} \n: Circular{T}\n\n\n\n\n\nDisk-like obstacle that allows propagation both inside and outside of the disk (immutable type). Used in ray-splitting billiards.\n\n\nFields:\n\n\n\n\nc::SVector{2,T}\n : Center.\n\n\nr::T\n : Radius.\n\n\npflag::Bool\n : Flag that keeps track of where the particle is currently propagating (\npflag\n = propagation-flag). \ntrue\n stands for \noutside\n the disk, \nfalse\n for \ninside\n the disk. Defaults to \ntrue\n.\n\n\nname::String\n : Name of the obstacle given for user convenience. Defaults to \"Antidot\".\n\n\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.Wall\n \n \nType\n.\n\n\nWall{T\n:AbstractFloat} \n: Obstacle{T}\n\n\n\n\n\nWall obstacle supertype.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.FiniteWall\n \n \nType\n.\n\n\nFiniteWall{T\n:AbstractFloat} \n: Wall{T}\n\n\n\n\n\nWall obstacle imposing specular reflection during collision (immutable type).\n\n\nFields:\n\n\n\n\nsp::SVector{2,T}\n : Starting point of the Wall.\n\n\nep::SVector{2,T}\n : Ending point of the Wall.\n\n\nnormal::SVector{2,T}\n : Normal vector to the wall, pointing to where the particle \nwill come from before a collision\n (pointing towards the inside of the billiard table). The size of the vector is irrelevant since it is internally normalized.\n\n\nname::String\n : Name of the obstacle, given for user convenience. Defaults to \"Wall\".\n\n\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.RandomWall\n \n \nType\n.\n\n\nRandomWall{T\n:AbstractFloat} \n: Wall{T}\n\n\n\n\n\nWall obstacle imposing (uniformly) random reflection during collision (immutable type).\n\n\nFields:\n\n\n\n\nsp::SVector{2,T}\n : Starting point of the Wall.\n\n\nep::SVector{2,T}\n : Ending point of the Wall.\n\n\nnormal::SVector{2,T}\n : Normal vector to the wall, pointing to where the particle \nis expected to come from\n (pointing towards the inside of the billiard table).\n\n\nname::String\n : Name of the obstacle, given for user convenience. Defaults to \"Random wall\".\n\n\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.PeriodicWall\n \n \nType\n.\n\n\nPeriodicWall{T\n:AbstractFloat} \n: Wall{T}\n\n\n\n\n\nWall obstacle that imposes periodic boundary conditions upon collision (immutable type).\n\n\nFields:\n\n\n\n\nsp::SVector{2,T}\n : Starting point of the Wall.\n\n\nep::SVector{2,T}\n : Ending point of the Wall.\n\n\nnormal::SVector{2,T}\n : Normal vector to the wall, pointing to where the particle \nwill come from\n (to the inside the billiard table). The size of the vector is \nimportant\n! This vector is added to a particle's \npos\n during collision. Therefore the size of the normal vector must be correctly associated with the size of the periodic cell.\n\n\nname::String\n : Name of the obstacle, given for user convenience. Defaults to \"Periodic wall\".\n\n\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.SplitterWall\n \n \nType\n.\n\n\nSplitterWall{T\n:AbstractFloat} \n: Wall{T}\n\n\n\n\n\nWall obstacle imposing allowing for ray-splitting (immutable type).\n\n\nFields:\n\n\n\n\nsp::SVector{2,T}\n : Starting point of the Wall.\n\n\nep::SVector{2,T}\n : Ending point of the Wall.\n\n\nnormal::SVector{2,T}\n : Normal vector to the wall, pointing to where the particle \nwill come from before a collision\n. The size of the vector is irrelevant.\n\n\npflag::Bool\n : Flag that keeps track of where the particle is currently propagating (\npflag\n = propagation flag). \ntrue\n is associated with the \nnormal\n vector the wall is instantiated with. Defaults to \ntrue\n.\n\n\nname::String\n : Name of the obstacle, given for user convenience. Defaults to \"Splitter wall\".\n\n\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.normalvec\n \n \nFunction\n.\n\n\nnormalvec\n(\nobst\n::\nObstacle\n,\n \nposition\n)\n\n\n\n\n\n\nReturn the vector normal to the obstacle's boundary at the given position (which is assumed to be very close to the obstacle's boundary).\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.distance\n \n \nFunction\n.\n\n\ndistance(p::AbstractParticle, o::Obstacle)\n\n\n\n\n\nReturn the \nsigned\n distance between particle \np\n and obstacle \no\n, based on \np.pos\n. Positive distance corresponds to the particle being on the \nallowed\n region of the \nObstacle\n. E.g. for a \nDisk\n, the distance is positive when the particle is outside of the disk, negative otherwise.\n\n\ndistance(p::AbstractParticle, bt::Vector{\n:Obstacle})\n\n\n\n\n\nReturn minimum \ndistance(p, obst)\n for all \nobst\n in \nbt\n. If the \ndistance(p, bt)\n is negative this means that the particle is outside the billiard table.\n\n\nAll \ndistance\n functions can also be given a position (Vector) instead of a particle.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.randominside\n \n \nFunction\n.\n\n\nrandominside(bt::Vector{\n:Obstacle{T}}[, \u03c9])\n\n\n\n\n\nReturn a particle with correct (allowed) initial conditions inside the given billiard table defined by the vector \nbt\n. If supplied with a second argument the type of the returned particle is \nMagneticParticle\n, with angular velocity \n\u03c9\n (unless \n\u03c9\n is 0). Else, it is \nParticle\n.\n\n\nsource\n\n\n\n\nStandard Billiards\n\n\n#\n\n\nDynamicalBilliards.billiard_rectangle\n \n \nFunction\n.\n\n\nbilliard_rectangle\n(\nx\n=\n1.0\n,\n \ny\n=\n1.0\n;\n \nsetting\n \n=\n \nstandard\n)\n\n\n\n\n\n\nReturn a vector of obstacles that defines a rectangle billiard of size (\nx\n, \ny\n).\n\n\nSettings\n\n\n\n\n\"standard\" : Specular reflection occurs during collision.\n\n\n\"periodic\" : The walls are \nPeriodicWall\n type, enforcing periodicity at the boundaries\n\n\n\"random\" : The velocity is randomized upon collision.\n\n\n\"ray-splitting\" : All obstacles in the billiard table allow for ray-splitting.\n\n\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.billiard_sinai\n \n \nFunction\n.\n\n\nbilliard_sinai\n(\nr\n=\n0.25\n,\n \nx\n=\n1.0\n,\n \ny\n=\n1.0\n;\n \nsetting\n \n=\n \nstandard\n)\n\n\n\n\n\n\nReturn a vector of obstacles that defines a Sinai billiard of size (\nx\n, \ny\n) with a disk in its center, of radius \nr\n.\n\n\nIn the periodic case, the system is also known as \"Lorentz Gas\".\n\n\nSettings\n\n\n\n\n\"standard\" : Specular reflection occurs during collision.\n\n\n\"periodic\" : The walls are \nPeriodicWall\n type, enforcing periodicity at the boundaries\n\n\n\"random\" : The velocity is randomized upon collision.\n\n\n\"ray-splitting\" : All obstacles in the billiard table allow for ray-splitting.\n\n\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.billiard_lorentz\n \n \nFunction\n.\n\n\nbilliard_lorentz(r=0.25, x=1.0, y=1.0)\n\n\n\n\n\nAlias for \nbilliard_sinai(r,x,y; setting = \nperiodic\n)\n.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.billiard_polygon\n \n \nFunction\n.\n\n\nbilliard_polygon\n(\nn\n::\nInt\n,\n \nR\n,\n \ncenter\n \n=\n \n[\n0\n,\n0\n]\n;\n \nsetting\n \n=\n \nstandard\n)\n\n\n\n\n\n\nReturn a vector of obstacles that defines a regular-polygonal billiard table with \nn\n sides, radius \nr\n and given \ncenter\n.\n\n\nNote: \nR\n denotes the so-called outer radius, not the inner one.\n\n\nSettings\n\n\n\n\n\"standard\" : Specular reflection occurs during collision.\n\n\n\"periodic\" : The walls are \nPeriodicWall\n type, enforcing periodicity at the boundaries. Only available for \nn=4\n or \nn=6\n.\n\n\n\"random\" : The velocity is randomized upon collision.\n\n\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.billiard_raysplitting_showcase\n \n \nFunction\n.\n\n\nbilliard_raysplitting_showcase(x=2.0, y=1.0, r1=0.3, r2=0.2) -\n bt, rayspl\n\n\n\n\n\nShowcase example billiard for ray-splitting processes. A rectangle \n(x,y)\n with a SplitterWall at \nx/2\n and two disks at each side, with respective radii \nr1\n, \nr2\n.\n\n\nNotice\n: This function returns a billiard table \nbt\n as well as a \nrayspl\n dictionary!\n\n\nsource\n\n\n\n\nPropagation\n\n\n#\n\n\nDynamicalBilliards.resolvecollision!\n \n \nFunction\n.\n\n\nresolvecollision!(p::AbstractParticle, o::Obstacle)\n\n\n\n\n\nResolve the collision between particle \np\n and obstacle \no\n, depending on the type of \no\n (do \nspecular!\n or \nperiodicity!\n).\n\n\nresolvecollision!(p, o, T::Function, \u03b8::Function, new_\u03c9::Function)\n\n\n\n\n\nThis is the ray-splitting implementation. The three functions given are drawn from the ray-splitting dictionary that is passed directly to \nevolve!()\n. For a calculated incidence angle \u03c6, if T(\u03c6) \n rand(), ray-splitting occurs.\n\n\nsource\n\n\nresolvecollision!(p::AbstractParticle, o::Circular, offset::Matrix)\n\n\n\n\n\nResolve the collision between particle \np\n and obstacle \no\n of type \nCircular\n, updating the components of the offset vectors stored in the matrix \noffset\n as columns.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.specular!\n \n \nFunction\n.\n\n\nspecular!(p::AbstractParticle, o::Obstacle)\n\n\n\n\n\nPerform specular reflection based on the normal vector of the Obstacle.\n\n\nIn the case where the given obstacle is a \nRandomObstacle\n, the specular reflection randomizes the velocity instead (within -\u03c0/2+\u03b5 to \u03c0/2-\u03b5 of the normal vector).\n\n\nsource\n\n\nspecular!(p::AbstractParticle, o::Obstacle, offset::Matrix)\n\n\n\n\n\nPerform specular reflection based on the normal vector of the Obstacle. The function updates the position and velocity of the particle together with the components of 4 offset vectors stored in the matrix \noffset\n as columns.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.periodicity!\n \n \nFunction\n.\n\n\nperiodicity!(p::AbstractParticle, w::PeriodicWall)\n\n\n\n\n\nPerform periodicity conditions of \nw\n on \np\n.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.collisiontime\n \n \nFunction\n.\n\n\ncollisiontime(p::AbstractParticle, o::Obstacle)\n\n\n\n\n\nCalculate the collision time (time-until-collision) between given particle and obstacle. Returns \nInf\n if the collision is not possible \nor\n if the collision happens backwards in time.\n\n\nIn the case of magnetic propagation, there are always two possible collisions. The function internally decides which of the two will occur first, based on the sign of the angular velocity of the magnetic particle.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.next_collision\n \n \nFunction\n.\n\n\nnext_collision(p, bt) -\n (tmin, index)\n\n\n\n\n\nReturn the minimum collision time out of all \ncollisiontime(p, obst)\n for \nobst \u2208 bt\n, as well as the \nindex\n of the corresponding obstacle.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.propagate_pos\n \n \nFunction\n.\n\n\npropagate_pos(pos, p::Particle{T}, t::Real) where {T}\n\n\n\n\n\nPerform a \"fake\" propagation, i.e. propagate a position as if it was the particle's position.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.propagate!\n \n \nFunction\n.\n\n\npropagate!(p::AbstractParticle, t)\n\n\n\n\n\nPropagate the particle \np\n for given time \nt\n, changing appropriately the the \np.pos\n and \np.vel\n fields.\n\n\nFor a \nParticle\n the propagation is a straight line (i.e. velocity vector is constant). For a \nMagneticParticle\n the propagation is circular motion with cyclic frequency \np.omega\n and radius \n1/p.omega\n.\n\n\npropagate!(p, position, t)\n\n\n\n\n\nDo the same, but take advantage of the already calculated \nposition\n that the particle should end up at.\n\n\nsource\n\n\npropagate!\n(\np\n::\nAbstractParticle\n,\n \nt\n,\n \noffset\n::\nMatrix\n)\n\n\n\n\n\n\nPropagate the particle \np\n for given time \nt\n, changing appropriately the the \np.pos\n and \np.vel\n fields together with the components of the offset vectors stored in the \noffset\n matrix.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.evolve!\n \n \nFunction\n.\n\n\nevolve!(p::AbstractParticle, bt, t [, ray_splitter])\n\n\n\n\n\nEvolve the given particle \np\n inside the billiard table \nbt\n. If \nt\n is of type \nAbstractFloat\n, evolve for as much time as \nt\n. If however \nt\n is of type \nInt\n, evolve for as many collisions as \nt\n. Return the states of the particle between collisions.\n\n\nThe evolution takes into account the particle's Type. E.g. if \ntypeof(p) \n: MagneticParticle\n then magnetic evolution will take place.\n\n\nReturn\n\n\nAs noted by the \"!\" at the end of the function, the call changes \np\n (particle). Most importantly however, this function also returns the main output expected by a billiard system. This output is a tuple of 3 (or 4) vectors:\n\n\n\n\nct::Vector{T}\n : Collision times.\n\n\nposs::Vector{SVector{2,T}}\n : Positions during collisions.\n\n\nvels::Vector{SVector{2,T}})\n : Velocities \nexactly after\n the collisions.\n\n\n\u03c9\n, either \nT\n or \nVector{T}\n : Angular velocity/ies.\n\n\n\n\nIn the case of straight propagation, only the first 3 are returned. In the case of magnetic propagation, the 4th value is returned as well. This is either the angular velocity of the particle, or in the case of ray-splitting it is a vector of the angular velocities at each time step.\n\n\nThe time \nct[i]\n is the time necessary to reach state \nposs[i+1], vels[i+1]\n starting from the state \nposs[i], vels[i]\n. That is why \nct[1]\n is always 0 since \nposs[1], vels[1]\n are the initial conditions. The angular velocity \n\u03c9[i]\n is the one the particle has while propagating from state \nposs[i], vels[i]\n to \ni+1\n.\n\n\nNotice that at any point, the velocity vector \nvels[i]\n is the one obtained \nafter\n the specular reflection of the (i-1)th collision. The function \nconstruct\n takes that into account.\n\n\nRay-splitting billiards\n\n\nTo implement ray-splitting, the \nevolve!()\n function is supplemented with a fourth argument, \nray_splitter::Dict{Int, Any}\n, which maps integers to some kind of Function container (Tuple or Vector). The functions in this container are: (\u03c6 is the angle of incidence)\n\n\n\n\nT(\u03c6, pflag, \u03c9) : Transmission probability.\n\n\n\u03b8(\u03c6, pflag, \u03c9) : Transmission (aka refraction) angle.\n\n\n\u03c9_new(\u03c9, pflag) : Angular velocity after transmission.\n\n\n\n\nFor more information and instructions on defining these functions please visit the official documentation.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.construct\n \n \nFunction\n.\n\n\nconstruct(ct, poss, vels[, \u03c9][, dt=0.01])\n\n\n\n\n\nGiven the main output of this package (see \nevolve!()\n function) construct the timeseries of the position and velocity, as well as the time vector.\n\n\nIn case of not given \u03c9 (or \u03c9 == 0), straight construction takes place. In case of \u03c9 != 0 or \u03c9::Vector magnetic construction takes place.\n\n\nThe additional optional argument of \ndt\n (only valid for Magnetic construction) is the timestep with which the timeseries are constructed.\n\n\nReturn\n\n\nA tuple of the following:\n\n\n\n\nxt::Vector{T} : x position time-series\n\n\nyt::Vector{T} : y position time-series\n\n\nvxt::Vector{T} : x velocity time-series\n\n\nvyt::Vector{T} : y velocity time-series\n\n\nts::Vector{T} : time vector\n\n\n\n\nsource\n\n\n\n\nRay-splitting\n\n\n#\n\n\nDynamicalBilliards.isphysical\n \n \nFunction\n.\n\n\nisphysical\n(\nraysplitter\n::\nDict\n;\n \nonly_mandatory\n \n=\n \nfalse\n)\n\n\n\n\n\n\nReturn \ntrue\n if the given ray-splitting dictionary has physically plausible properties.\n\n\nSpecifically, check if (\u03c6 is the incidence angle, \u03b8 the refraction angle):\n\n\n\n\nCritical angle means total reflection: If \u03b8(\u03c6) \u2265 \u03c0/2 then Tr(\u03c6) = 0\n\n\nTransmission probability is even function: Tr(\u03c6) \u2248 Tr(-\u03c6) at \u03c9 = 0\n\n\nRefraction angle is odd function: \u03b8(\u03c6) \u2248 -\u03b8(-\u03c6) at \u03c9 = 0\n\n\nRay reversal is true: \u03b8(\u03b8(\u03c6, pflag, \u03c9), !pflag, \u03c9) \u2248 \u03c6\n\n\nMagnetic conservation is true: (\u03c9_new(\u03c9_new(\u03c9, pflag), !pflag) \u2248 \u03c9\n\n\n\n\nThe first property is mandatory to hold for any setting and is always checked. The rest are checked if \nonly_mandatory = false\n.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.acceptable_raysplitter\n \n \nFunction\n.\n\n\nacceptable_raysplitter(raysplitter, bt)\n\n\n\n\n\nReturn \ntrue\n if the given ray-splitting dictionary \nraysplitter\n can be used in conjuction with given billiard table \nbt\n.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.reset_billiard!\n \n \nFunction\n.\n\n\nreset_billiard!(bt)\n\n\n\n\n\nSets the \npflag\n field of all ray-splitting obstacles of a billiard table to \ntrue\n.\n\n\nsource\n\n\n\n\nVisualization\n\n\nplot_obstacle\n(\nobst\n::\nObstacle\n;\n \nkwargs\n...\n)\n\n\n\n\n\n\nPlot given obstacle on the current \nPyPlot\n figure. The default arguments for each type of obstacle have been chosen for maximum clarity and consistency. The \nkwargs...\n given by the user are keywords passed directly into PyPlot's constructors. For \nWall\n obstacles, kwargs are passed into \nPyPlot.plot()\n. For \nDisk\n obstacles, kwargs are passed into \nPyPlot.plt[:Circle]()\n.\n\n\nplot_particle\n(\np\n::\nAbstractParticle\n;\n \nuse_cell\n=\ntrue\n,\n \nkwargs\n...\n)\n\n\n\n\n\n\nPlot given particle on the current \nPyPlot\n figure. Optionally use \np.current_cell\n for the particle's position. Given \nkwargs...\n are passed onto \nPyPlot.scatter()\n. The particle is represented as a small ball (\nPyPlot.scatter()\n) and a small arrow (\nPyPlot.quiver()\n). All \nkwargs...\n are given to \nscatter()\n but if a keyword argument \ncolor\n is given, it is also passed to \nquiver()\n.\n\n\nplot_cyclotron\n(\np\n::\nMagneticParticle\n;\n \nuse_cell\n=\ntrue\n,\n \nkwargs\n...\n)\n\n\n\n\n\n\nPlot the circle traced by the free particle motion. Optionally use \np.current_cell\n for the particle's position. The user provided \nkwargs...\n are passed onto \nPyPlot.plt[:Circle]()\n.\n\n\nplot_billiard\n(\nbt\n::\nVector\n{\nObstacle\n})\n\n\n\n\n\n\nPlot all obstacles in \nbt\n using the default arguments, set \nxlim\n and \nylim\n to be 10% larger than \ncellsize\n and set the axis aspect ratio to equal.\n\n\nplot_billiard\n(\nbt\n,\n \nxmin\n,\n \nymin\n,\n \nxmax\n,\n \nymax\n)\n\n\n\n\n\n\nPlot the given (periodic) billiard \nbt\n on the current PyPlot figure, repeatedly plotting from \n(xmin, ymin)\n to \n(xmax, ymax)\n. Only works for rectangular billiards.\n\n\nplot_billiard\n(\nbt\n,\n \nxt\n::\nVector\n{\nFloat64\n},\n \nyt\n::\nVector\n{\nFloat64\n};\n \nplot_orbit\n \n=\n \ntrue\n)\n\n\n\n\n\n\nPlot the given (periodic) billiard \nbt\n along with a particle trajectory defined by \nxt\n and \nyt\n, on the current PyPlot figure. Only works for rectangular billiards. Sets limits automatically. Set the keyword argument \nplot_orbit = false\n to not plot the orbit defined by \n(xt, yt)\n.\n\n\nbilliard_julia\n(;\n \nplotit\n \n=\n \ntrue\n)\n\n\n\n\n\n\nReturn the awesome \"Julia-logo\" billiard shown in the introduction of DynamicalBilliards.jl. By default it also plots the billiard in a new \nPyPlot.figure()\n using the correct colors.\n\n\n\n\nAnimations\n\n\nanimate_evolution\n(\np\n,\n \nbt\n,\n \ncolnumber\n[,\n \nray\n-\nsplitter\n];\n \nkwargs\n)\n\n\n\n\n\n\nAnimate the evolution of the particle, plotting the orbit from collision to collision.\n\n\nNotice the difference with \nevolve!()\n: No time is given here; instead a number of collisions is passed.\n\n\n\n\nArguments\n\n\n\n\np::AbstractParticle\n : Either standard or magnetic.\n\n\nbt::Vector{Obstacle}\n : The billiard table.\n\n\ncolnumber::Int\n : Number of collisions to evolve the particle for.\n\n\nray-splitter::Dict{Int, Any}\n : (Optional) Ray-splitting dictionary that enables ray-splitting processes during evolution.\n\n\n\n\n\n\nKeyword Arguments\n\n\n\n\nsleeptime\n : Time passed to \nsleep()\n between each collision.\n\n\ncol_to_plot\n : How many previous collisions are shown during the animation.\n\n\nsavefigs::Bool\n : If \ntrue\n save .png figures to enable the creation of animation afterwards. (currently the .gif production has to be made by the user!)\n\n\nsavename\n : Name (\nincluding path!\n) of the figures to be produced. The ending \"_i.png\" will be attached to all figures.\n\n\nparticle_kwargs\n : Either a Dict{Symbol, Any} or a vector of Tuple{Symbol, Any}. Keywords passed into \nplot_particle()\n.\n\n\norbit_kwargs\n : Either a Dict{Symbol, Any} or a Vector of Tuple{Symbol, Any}. Keywords passed into \nPyPlot.plot()\n which plots the orbit of the particle (\nline\n object).", 
            "title": "Library"
        }, 
        {
            "location": "/basic/library/#particles", 
            "text": "#  DynamicalBilliards.Particle     Type .  Particle{T :AbstractFloat}  : AbstractParticle{T}  Two-dimensional particle in a billiard table (mutable type).  Fields:   pos::SVector{2,T}  : Current position vector.  vel::SVector{2,T}  : Current velocity vector (always of measure 1).  current_cell::SVector{2,T}  : Current \"cell\" the particle is located at. (Used only in periodic billiards)   Additional constructors:  Particle ( ic :: Vector { T })   #where ic = [x0, y0, \u03c60]  Particle ( x ,   y ,   \u03c6 )  Particle ()   =   Particle ( rand (),   rand (),   rand () * 2 \u03c0 )  Particle ( bt :: Vector { : Obstacle })   =   randominside ( bt )   source  #  DynamicalBilliards.MagneticParticle     Type .  MagneticParticle{T :AbstractFloat}  : AbstractParticle{T}  Two-dimensional particle in a billiard table with perpendicular magnetic field (mutable type).  Fields:   pos::SVector{2,T}  : Current position vector.  vel::SVector{2,T}  : Current velocity vector (always of measure 1).  current_cell::SVector{2,T}  : Current \"cell\" the particle is located at (Used only in periodic billiards).  omega::T  : Angular velocity (cyclic frequency) of rotational motion. Radius of rotation is  r=1/omega .   Additional constructors:  MagneticParticle ( ic :: AbstractVector { T },   \u03c9 :: Real )   #where ic = [x0, y0, \u03c60]  MagneticParticle ( x0 :: Real ,   y0 :: Real ,   \u03c60 :: Real ,   \u03c9 :: Real )  MagneticParticle ()   =   MagneticParticle ([ rand (),   rand (),   rand () * 2 \u03c0 ],   1.0 )  MagneticParticle ( bt :: Vector { : Obstacle },   \u03c9 )   =   randominside ( bt ,   \u03c9 )   source  #  DynamicalBilliards.cyclotron     Function .  cyclotron(p::MagneticParticle, use_cell = false)  Return center and radius of circular motion performed by the particle based on  p.pos  (or  p.pos + p.current_cell ) and  p.vel .  source", 
            "title": "Particles"
        }, 
        {
            "location": "/basic/library/#obstacles", 
            "text": "#  DynamicalBilliards.Obstacle     Type .  Obstacle{ :AbstractFloat}  Obstacle supertype.  source  #  DynamicalBilliards.Circular     Type .  Circular{T :AbstractFloat}  : Obstacle{T}  Circular obstacle supertype.  source  #  DynamicalBilliards.Disk     Type .  Disk{T :AbstractFloat}   : Circular{T}  Disk-like obstacle with propagation allowed outside of the circle (immutable type).  Fields:   c::SVector{2,T}  : Center.  r::T  : Radius.  name::String  : Some name given for user convenience. Defaults to \"Disk\".   source  #  DynamicalBilliards.RandomDisk     Type .  RandomDisk{T :AbstractFloat}  : Circular{T}  Disk-like obstacle that randomly (and uniformly) reflects colliding particles. The propagation is allowed outside of the circle.  Fields:   c::SVector{2,T}  : Center.  r::T  : Radius.  name::String  : Some name given for user convenience. Defaults to \"Random disk\".   source  #  DynamicalBilliards.Antidot     Type .  Antidot{T :AbstractFloat}  : Circular{T}  Disk-like obstacle that allows propagation both inside and outside of the disk (immutable type). Used in ray-splitting billiards.  Fields:   c::SVector{2,T}  : Center.  r::T  : Radius.  pflag::Bool  : Flag that keeps track of where the particle is currently propagating ( pflag  = propagation-flag).  true  stands for  outside  the disk,  false  for  inside  the disk. Defaults to  true .  name::String  : Name of the obstacle given for user convenience. Defaults to \"Antidot\".   source  #  DynamicalBilliards.Wall     Type .  Wall{T :AbstractFloat}  : Obstacle{T}  Wall obstacle supertype.  source  #  DynamicalBilliards.FiniteWall     Type .  FiniteWall{T :AbstractFloat}  : Wall{T}  Wall obstacle imposing specular reflection during collision (immutable type).  Fields:   sp::SVector{2,T}  : Starting point of the Wall.  ep::SVector{2,T}  : Ending point of the Wall.  normal::SVector{2,T}  : Normal vector to the wall, pointing to where the particle  will come from before a collision  (pointing towards the inside of the billiard table). The size of the vector is irrelevant since it is internally normalized.  name::String  : Name of the obstacle, given for user convenience. Defaults to \"Wall\".   source  #  DynamicalBilliards.RandomWall     Type .  RandomWall{T :AbstractFloat}  : Wall{T}  Wall obstacle imposing (uniformly) random reflection during collision (immutable type).  Fields:   sp::SVector{2,T}  : Starting point of the Wall.  ep::SVector{2,T}  : Ending point of the Wall.  normal::SVector{2,T}  : Normal vector to the wall, pointing to where the particle  is expected to come from  (pointing towards the inside of the billiard table).  name::String  : Name of the obstacle, given for user convenience. Defaults to \"Random wall\".   source  #  DynamicalBilliards.PeriodicWall     Type .  PeriodicWall{T :AbstractFloat}  : Wall{T}  Wall obstacle that imposes periodic boundary conditions upon collision (immutable type).  Fields:   sp::SVector{2,T}  : Starting point of the Wall.  ep::SVector{2,T}  : Ending point of the Wall.  normal::SVector{2,T}  : Normal vector to the wall, pointing to where the particle  will come from  (to the inside the billiard table). The size of the vector is  important ! This vector is added to a particle's  pos  during collision. Therefore the size of the normal vector must be correctly associated with the size of the periodic cell.  name::String  : Name of the obstacle, given for user convenience. Defaults to \"Periodic wall\".   source  #  DynamicalBilliards.SplitterWall     Type .  SplitterWall{T :AbstractFloat}  : Wall{T}  Wall obstacle imposing allowing for ray-splitting (immutable type).  Fields:   sp::SVector{2,T}  : Starting point of the Wall.  ep::SVector{2,T}  : Ending point of the Wall.  normal::SVector{2,T}  : Normal vector to the wall, pointing to where the particle  will come from before a collision . The size of the vector is irrelevant.  pflag::Bool  : Flag that keeps track of where the particle is currently propagating ( pflag  = propagation flag).  true  is associated with the  normal  vector the wall is instantiated with. Defaults to  true .  name::String  : Name of the obstacle, given for user convenience. Defaults to \"Splitter wall\".   source  #  DynamicalBilliards.normalvec     Function .  normalvec ( obst :: Obstacle ,   position )   Return the vector normal to the obstacle's boundary at the given position (which is assumed to be very close to the obstacle's boundary).  source  #  DynamicalBilliards.distance     Function .  distance(p::AbstractParticle, o::Obstacle)  Return the  signed  distance between particle  p  and obstacle  o , based on  p.pos . Positive distance corresponds to the particle being on the  allowed  region of the  Obstacle . E.g. for a  Disk , the distance is positive when the particle is outside of the disk, negative otherwise.  distance(p::AbstractParticle, bt::Vector{ :Obstacle})  Return minimum  distance(p, obst)  for all  obst  in  bt . If the  distance(p, bt)  is negative this means that the particle is outside the billiard table.  All  distance  functions can also be given a position (Vector) instead of a particle.  source  #  DynamicalBilliards.randominside     Function .  randominside(bt::Vector{ :Obstacle{T}}[, \u03c9])  Return a particle with correct (allowed) initial conditions inside the given billiard table defined by the vector  bt . If supplied with a second argument the type of the returned particle is  MagneticParticle , with angular velocity  \u03c9  (unless  \u03c9  is 0). Else, it is  Particle .  source", 
            "title": "Obstacles"
        }, 
        {
            "location": "/basic/library/#standard-billiards", 
            "text": "#  DynamicalBilliards.billiard_rectangle     Function .  billiard_rectangle ( x = 1.0 ,   y = 1.0 ;   setting   =   standard )   Return a vector of obstacles that defines a rectangle billiard of size ( x ,  y ).  Settings   \"standard\" : Specular reflection occurs during collision.  \"periodic\" : The walls are  PeriodicWall  type, enforcing periodicity at the boundaries  \"random\" : The velocity is randomized upon collision.  \"ray-splitting\" : All obstacles in the billiard table allow for ray-splitting.   source  #  DynamicalBilliards.billiard_sinai     Function .  billiard_sinai ( r = 0.25 ,   x = 1.0 ,   y = 1.0 ;   setting   =   standard )   Return a vector of obstacles that defines a Sinai billiard of size ( x ,  y ) with a disk in its center, of radius  r .  In the periodic case, the system is also known as \"Lorentz Gas\".  Settings   \"standard\" : Specular reflection occurs during collision.  \"periodic\" : The walls are  PeriodicWall  type, enforcing periodicity at the boundaries  \"random\" : The velocity is randomized upon collision.  \"ray-splitting\" : All obstacles in the billiard table allow for ray-splitting.   source  #  DynamicalBilliards.billiard_lorentz     Function .  billiard_lorentz(r=0.25, x=1.0, y=1.0)  Alias for  billiard_sinai(r,x,y; setting =  periodic ) .  source  #  DynamicalBilliards.billiard_polygon     Function .  billiard_polygon ( n :: Int ,   R ,   center   =   [ 0 , 0 ] ;   setting   =   standard )   Return a vector of obstacles that defines a regular-polygonal billiard table with  n  sides, radius  r  and given  center .  Note:  R  denotes the so-called outer radius, not the inner one.  Settings   \"standard\" : Specular reflection occurs during collision.  \"periodic\" : The walls are  PeriodicWall  type, enforcing periodicity at the boundaries. Only available for  n=4  or  n=6 .  \"random\" : The velocity is randomized upon collision.   source  #  DynamicalBilliards.billiard_raysplitting_showcase     Function .  billiard_raysplitting_showcase(x=2.0, y=1.0, r1=0.3, r2=0.2) -  bt, rayspl  Showcase example billiard for ray-splitting processes. A rectangle  (x,y)  with a SplitterWall at  x/2  and two disks at each side, with respective radii  r1 ,  r2 .  Notice : This function returns a billiard table  bt  as well as a  rayspl  dictionary!  source", 
            "title": "Standard Billiards"
        }, 
        {
            "location": "/basic/library/#propagation", 
            "text": "#  DynamicalBilliards.resolvecollision!     Function .  resolvecollision!(p::AbstractParticle, o::Obstacle)  Resolve the collision between particle  p  and obstacle  o , depending on the type of  o  (do  specular!  or  periodicity! ).  resolvecollision!(p, o, T::Function, \u03b8::Function, new_\u03c9::Function)  This is the ray-splitting implementation. The three functions given are drawn from the ray-splitting dictionary that is passed directly to  evolve!() . For a calculated incidence angle \u03c6, if T(\u03c6)   rand(), ray-splitting occurs.  source  resolvecollision!(p::AbstractParticle, o::Circular, offset::Matrix)  Resolve the collision between particle  p  and obstacle  o  of type  Circular , updating the components of the offset vectors stored in the matrix  offset  as columns.  source  #  DynamicalBilliards.specular!     Function .  specular!(p::AbstractParticle, o::Obstacle)  Perform specular reflection based on the normal vector of the Obstacle.  In the case where the given obstacle is a  RandomObstacle , the specular reflection randomizes the velocity instead (within -\u03c0/2+\u03b5 to \u03c0/2-\u03b5 of the normal vector).  source  specular!(p::AbstractParticle, o::Obstacle, offset::Matrix)  Perform specular reflection based on the normal vector of the Obstacle. The function updates the position and velocity of the particle together with the components of 4 offset vectors stored in the matrix  offset  as columns.  source  #  DynamicalBilliards.periodicity!     Function .  periodicity!(p::AbstractParticle, w::PeriodicWall)  Perform periodicity conditions of  w  on  p .  source  #  DynamicalBilliards.collisiontime     Function .  collisiontime(p::AbstractParticle, o::Obstacle)  Calculate the collision time (time-until-collision) between given particle and obstacle. Returns  Inf  if the collision is not possible  or  if the collision happens backwards in time.  In the case of magnetic propagation, there are always two possible collisions. The function internally decides which of the two will occur first, based on the sign of the angular velocity of the magnetic particle.  source  #  DynamicalBilliards.next_collision     Function .  next_collision(p, bt) -  (tmin, index)  Return the minimum collision time out of all  collisiontime(p, obst)  for  obst \u2208 bt , as well as the  index  of the corresponding obstacle.  source  #  DynamicalBilliards.propagate_pos     Function .  propagate_pos(pos, p::Particle{T}, t::Real) where {T}  Perform a \"fake\" propagation, i.e. propagate a position as if it was the particle's position.  source  #  DynamicalBilliards.propagate!     Function .  propagate!(p::AbstractParticle, t)  Propagate the particle  p  for given time  t , changing appropriately the the  p.pos  and  p.vel  fields.  For a  Particle  the propagation is a straight line (i.e. velocity vector is constant). For a  MagneticParticle  the propagation is circular motion with cyclic frequency  p.omega  and radius  1/p.omega .  propagate!(p, position, t)  Do the same, but take advantage of the already calculated  position  that the particle should end up at.  source  propagate! ( p :: AbstractParticle ,   t ,   offset :: Matrix )   Propagate the particle  p  for given time  t , changing appropriately the the  p.pos  and  p.vel  fields together with the components of the offset vectors stored in the  offset  matrix.  source  #  DynamicalBilliards.evolve!     Function .  evolve!(p::AbstractParticle, bt, t [, ray_splitter])  Evolve the given particle  p  inside the billiard table  bt . If  t  is of type  AbstractFloat , evolve for as much time as  t . If however  t  is of type  Int , evolve for as many collisions as  t . Return the states of the particle between collisions.  The evolution takes into account the particle's Type. E.g. if  typeof(p)  : MagneticParticle  then magnetic evolution will take place.  Return  As noted by the \"!\" at the end of the function, the call changes  p  (particle). Most importantly however, this function also returns the main output expected by a billiard system. This output is a tuple of 3 (or 4) vectors:   ct::Vector{T}  : Collision times.  poss::Vector{SVector{2,T}}  : Positions during collisions.  vels::Vector{SVector{2,T}})  : Velocities  exactly after  the collisions.  \u03c9 , either  T  or  Vector{T}  : Angular velocity/ies.   In the case of straight propagation, only the first 3 are returned. In the case of magnetic propagation, the 4th value is returned as well. This is either the angular velocity of the particle, or in the case of ray-splitting it is a vector of the angular velocities at each time step.  The time  ct[i]  is the time necessary to reach state  poss[i+1], vels[i+1]  starting from the state  poss[i], vels[i] . That is why  ct[1]  is always 0 since  poss[1], vels[1]  are the initial conditions. The angular velocity  \u03c9[i]  is the one the particle has while propagating from state  poss[i], vels[i]  to  i+1 .  Notice that at any point, the velocity vector  vels[i]  is the one obtained  after  the specular reflection of the (i-1)th collision. The function  construct  takes that into account.  Ray-splitting billiards  To implement ray-splitting, the  evolve!()  function is supplemented with a fourth argument,  ray_splitter::Dict{Int, Any} , which maps integers to some kind of Function container (Tuple or Vector). The functions in this container are: (\u03c6 is the angle of incidence)   T(\u03c6, pflag, \u03c9) : Transmission probability.  \u03b8(\u03c6, pflag, \u03c9) : Transmission (aka refraction) angle.  \u03c9_new(\u03c9, pflag) : Angular velocity after transmission.   For more information and instructions on defining these functions please visit the official documentation.  source  #  DynamicalBilliards.construct     Function .  construct(ct, poss, vels[, \u03c9][, dt=0.01])  Given the main output of this package (see  evolve!()  function) construct the timeseries of the position and velocity, as well as the time vector.  In case of not given \u03c9 (or \u03c9 == 0), straight construction takes place. In case of \u03c9 != 0 or \u03c9::Vector magnetic construction takes place.  The additional optional argument of  dt  (only valid for Magnetic construction) is the timestep with which the timeseries are constructed.  Return  A tuple of the following:   xt::Vector{T} : x position time-series  yt::Vector{T} : y position time-series  vxt::Vector{T} : x velocity time-series  vyt::Vector{T} : y velocity time-series  ts::Vector{T} : time vector   source", 
            "title": "Propagation"
        }, 
        {
            "location": "/basic/library/#ray-splitting", 
            "text": "#  DynamicalBilliards.isphysical     Function .  isphysical ( raysplitter :: Dict ;   only_mandatory   =   false )   Return  true  if the given ray-splitting dictionary has physically plausible properties.  Specifically, check if (\u03c6 is the incidence angle, \u03b8 the refraction angle):   Critical angle means total reflection: If \u03b8(\u03c6) \u2265 \u03c0/2 then Tr(\u03c6) = 0  Transmission probability is even function: Tr(\u03c6) \u2248 Tr(-\u03c6) at \u03c9 = 0  Refraction angle is odd function: \u03b8(\u03c6) \u2248 -\u03b8(-\u03c6) at \u03c9 = 0  Ray reversal is true: \u03b8(\u03b8(\u03c6, pflag, \u03c9), !pflag, \u03c9) \u2248 \u03c6  Magnetic conservation is true: (\u03c9_new(\u03c9_new(\u03c9, pflag), !pflag) \u2248 \u03c9   The first property is mandatory to hold for any setting and is always checked. The rest are checked if  only_mandatory = false .  source  #  DynamicalBilliards.acceptable_raysplitter     Function .  acceptable_raysplitter(raysplitter, bt)  Return  true  if the given ray-splitting dictionary  raysplitter  can be used in conjuction with given billiard table  bt .  source  #  DynamicalBilliards.reset_billiard!     Function .  reset_billiard!(bt)  Sets the  pflag  field of all ray-splitting obstacles of a billiard table to  true .  source", 
            "title": "Ray-splitting"
        }, 
        {
            "location": "/basic/library/#visualization", 
            "text": "plot_obstacle ( obst :: Obstacle ;   kwargs ... )   Plot given obstacle on the current  PyPlot  figure. The default arguments for each type of obstacle have been chosen for maximum clarity and consistency. The  kwargs...  given by the user are keywords passed directly into PyPlot's constructors. For  Wall  obstacles, kwargs are passed into  PyPlot.plot() . For  Disk  obstacles, kwargs are passed into  PyPlot.plt[:Circle]() .  plot_particle ( p :: AbstractParticle ;   use_cell = true ,   kwargs ... )   Plot given particle on the current  PyPlot  figure. Optionally use  p.current_cell  for the particle's position. Given  kwargs...  are passed onto  PyPlot.scatter() . The particle is represented as a small ball ( PyPlot.scatter() ) and a small arrow ( PyPlot.quiver() ). All  kwargs...  are given to  scatter()  but if a keyword argument  color  is given, it is also passed to  quiver() .  plot_cyclotron ( p :: MagneticParticle ;   use_cell = true ,   kwargs ... )   Plot the circle traced by the free particle motion. Optionally use  p.current_cell  for the particle's position. The user provided  kwargs...  are passed onto  PyPlot.plt[:Circle]() .  plot_billiard ( bt :: Vector { Obstacle })   Plot all obstacles in  bt  using the default arguments, set  xlim  and  ylim  to be 10% larger than  cellsize  and set the axis aspect ratio to equal.  plot_billiard ( bt ,   xmin ,   ymin ,   xmax ,   ymax )   Plot the given (periodic) billiard  bt  on the current PyPlot figure, repeatedly plotting from  (xmin, ymin)  to  (xmax, ymax) . Only works for rectangular billiards.  plot_billiard ( bt ,   xt :: Vector { Float64 },   yt :: Vector { Float64 };   plot_orbit   =   true )   Plot the given (periodic) billiard  bt  along with a particle trajectory defined by  xt  and  yt , on the current PyPlot figure. Only works for rectangular billiards. Sets limits automatically. Set the keyword argument  plot_orbit = false  to not plot the orbit defined by  (xt, yt) .  billiard_julia (;   plotit   =   true )   Return the awesome \"Julia-logo\" billiard shown in the introduction of DynamicalBilliards.jl. By default it also plots the billiard in a new  PyPlot.figure()  using the correct colors.", 
            "title": "Visualization"
        }, 
        {
            "location": "/basic/library/#animations", 
            "text": "animate_evolution ( p ,   bt ,   colnumber [,   ray - splitter ];   kwargs )   Animate the evolution of the particle, plotting the orbit from collision to collision.  Notice the difference with  evolve!() : No time is given here; instead a number of collisions is passed.", 
            "title": "Animations"
        }, 
        {
            "location": "/basic/library/#arguments", 
            "text": "p::AbstractParticle  : Either standard or magnetic.  bt::Vector{Obstacle}  : The billiard table.  colnumber::Int  : Number of collisions to evolve the particle for.  ray-splitter::Dict{Int, Any}  : (Optional) Ray-splitting dictionary that enables ray-splitting processes during evolution.", 
            "title": "Arguments"
        }, 
        {
            "location": "/basic/library/#keyword-arguments", 
            "text": "sleeptime  : Time passed to  sleep()  between each collision.  col_to_plot  : How many previous collisions are shown during the animation.  savefigs::Bool  : If  true  save .png figures to enable the creation of animation afterwards. (currently the .gif production has to be made by the user!)  savename  : Name ( including path! ) of the figures to be produced. The ending \"_i.png\" will be attached to all figures.  particle_kwargs  : Either a Dict{Symbol, Any} or a vector of Tuple{Symbol, Any}. Keywords passed into  plot_particle() .  orbit_kwargs  : Either a Dict{Symbol, Any} or a Vector of Tuple{Symbol, Any}. Keywords passed into  PyPlot.plot()  which plots the orbit of the particle ( line  object).", 
            "title": "Keyword Arguments"
        }
    ]
}