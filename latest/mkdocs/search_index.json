{
    "docs": [
        {
            "location": "/", 
            "text": "Dynamical Billiards\n\n\nDynamicalBilliards.jl\n is an easy-to-use, modular and extendable Julia package for Dynamical Billiard systems in two dimensions.\n\n\n\n\nA dynamical billiard is a system where a particle is propagating as a straight line from obstacle-to-obstacle, performing specular reflection at the boundary of the obstacles. Billiard systems have been used extensively in chaos and nonlinear dynamics and played an important role in the development of nonlinear science. \n\n\nThe \"standard\" billiard described above can be extended in many ways. The \nwikipedia page\n has many examples of different types of billiards. The types that are currently offered by this package, besides the standard one, are magnetic and ray-splitting billiards. In a magnetic billiard the particle's orbit is a circle (like electrons in a perpendicular magnetic field). In ray-splitting (aka semiclassical) billiards the particle may propagate \nthrough\n an obstacle, given some arbitrary transmission and refraction law.\n\n\n\n\nInstallation\n\n\n\n\nThis package is currently under the registration process. When this process is over, you can install the package using \nPkg.add(\"DynamicalBilliards\")\n.\n\n\nAfter first installation, it is advised to run the short tests to be sure that everything works as expected. This will only take 2 minutes:\n\n\nusing DynamicalBilliards\ntest_options(print_info = false)\nPkg.test(\nDynamicalBilliards\n)\n\n\n\n\nIf you want to see what tests are done, use \nprint_info = true\n (\nfalse\n is actually the default value). If you use this package for research purposes, you should run the long tests at least one. To do this, pass the keyword argument \nlong_tests = true\n to the \ntest_options\n function. These tests take on average 20 minutes to complete.\n\n\n\n\nUsage\n\n\n\n\nFor a crash course on how to use \nDynamicalBilliards.jl\n, you should visit the \nBasic Usage\n section.\n\n\nIf however, you want to make the most out if, the following tutorials offer detailed descriptions:\n\n\n\n\nHow to define your custom Billiard Table\n\n\nUsing Ray-Splitting billiards\n\n\nCreating your own Obstacle Type\n\n\nExamples page\n\n\n\n\nThe \nLibrary\n section has the docstrings of all exported names in convenient groups.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#dynamical-billiards", 
            "text": "DynamicalBilliards.jl  is an easy-to-use, modular and extendable Julia package for Dynamical Billiard systems in two dimensions.   A dynamical billiard is a system where a particle is propagating as a straight line from obstacle-to-obstacle, performing specular reflection at the boundary of the obstacles. Billiard systems have been used extensively in chaos and nonlinear dynamics and played an important role in the development of nonlinear science.   The \"standard\" billiard described above can be extended in many ways. The  wikipedia page  has many examples of different types of billiards. The types that are currently offered by this package, besides the standard one, are magnetic and ray-splitting billiards. In a magnetic billiard the particle's orbit is a circle (like electrons in a perpendicular magnetic field). In ray-splitting (aka semiclassical) billiards the particle may propagate  through  an obstacle, given some arbitrary transmission and refraction law.", 
            "title": "Dynamical Billiards"
        }, 
        {
            "location": "/#installation", 
            "text": "This package is currently under the registration process. When this process is over, you can install the package using  Pkg.add(\"DynamicalBilliards\") .  After first installation, it is advised to run the short tests to be sure that everything works as expected. This will only take 2 minutes:  using DynamicalBilliards\ntest_options(print_info = false)\nPkg.test( DynamicalBilliards )  If you want to see what tests are done, use  print_info = true  ( false  is actually the default value). If you use this package for research purposes, you should run the long tests at least one. To do this, pass the keyword argument  long_tests = true  to the  test_options  function. These tests take on average 20 minutes to complete.", 
            "title": "Installation"
        }, 
        {
            "location": "/#usage", 
            "text": "For a crash course on how to use  DynamicalBilliards.jl , you should visit the  Basic Usage  section.  If however, you want to make the most out if, the following tutorials offer detailed descriptions:   How to define your custom Billiard Table  Using Ray-Splitting billiards  Creating your own Obstacle Type  Examples page   The  Library  section has the docstrings of all exported names in convenient groups.", 
            "title": "Usage"
        }, 
        {
            "location": "/basic/basic_usage/", 
            "text": "Basic Usage\n\n\nDynamicalBilliards.jl\n was created with easy-of-use as its main cornerstone.  With 3 simple steps, the user can fully initalize, evolve, and get the output of the propagation of a particle in a billiard system.\n\n\nIn general, the workflow of \nDynamicalBilliards.jl\n follows these simple steps:\n\n\n\n\nCreate a billiard table, a \nVector{Obstacle}\n.\n\n\nCreate a particle inside that billiard table.\n\n\nGet the output by evolving the particle.\n\n\n\n\nAdding more complexity in your billiard table does not add complexity in your code. For example, to implement a ray-splitting billiard you only need to define one additional variable, a dictionary \nDict{Int, Vector{Function}}\n. After reading through this basic usage page,  you will be able to use all aspects of \nDynamicalBilliards.jl\n with minimal effort.\n\n\n\n\nStraight Propagation\n\n\n\n\nThe usage of this package revolves around a single function: \n\n\nevolve!(p::AbstractParticle, bt::Vector{Obstacle}, total_time)\n\n\n\n\nwhich evolves a particle \np\n inside a billiard table \nbt\n for a given amount of time \ntotal_time\n,  while taking care of all the details internally. \n\n\nThe first step is to define the billiard table \nbt\n, which is the system the particle \np\n will propagate in.  A billiard table is simply a collection (\nVector\n) of \nObstacle\ns. The most convenient way is to use  one of the pre-defined billiard tables offered by the package. For example, let's create a periodic Sinai  billiard with disk radius of 0.3 and with one side of length 2 and one of length 1:\n\n\nusing DynamicalBilliards\nbt = billiard_sinai(0.3, 2.0, 1.0; periodic=true)\n\n\n\n\n(for more information about defining billiard tables visit the \ntutorial on defining your own billiard table\n)\n\n\nAfterwards, you want to create a particle inside that billiard system.  For that, the function \nrandominside(bt::Vector{Obstacle})\n is provided.  This function returns a particle with random initial conditions inside the billiard table,  while making sure that it is always in the allowed region of the billiard table.\n\n\np = randominside(bt)\n\n\n\n\nIf you want to specify the initial conditions yourself, simply pass them to the \nParticle\n constructor, like \np = Particle(x0, y0, \u03c60)\n. Now you are ready to evolve this particle:\n\n\nct, poss, vels = evolve!(p, bt, 1000.0)\n\n\n\n\nThe return values of the \nevolve!()\n function need some brief explaining: As noted by the \"!\" at the end of the function,  it changes its argument \np\n. Most importantly however, this function also returns the main output expected by a billiard system. This output is a tuple of three vectors:\n\n\n\n\nct::Vector\n : Collision times.\n\n\nposs::Vector{SVector{2}}\n : Positions during collisions.\n\n\nvels:: Vector{SVector{2}})\n : Velocities \nexactly after\n the collisions (i.e. reflections).\n\n\n\n\nThe time \nt[i]\n is the time necessary to reach state \nposs[i], vels[i]\n starting from the state \nposs[i-1], vels[i-1]\n. That is why \nt[1]\n is always 0 since \nposs[1], vels[1]\n are the initial conditions.\n\n\nIf this output is not convenient for you, the function \nconstruct(ct, poss, vels)\n is provided,  which constructs the (continuous) timeseries of the position and velocity, as well as the time-vector, when given the main output of \nevolve!()\n:\n\n\nxt, yt, vxt, vyt, ts = construct(ct, poss, vels)\n\n\n\n\nor, by taking advantage of the awesome ellipsis operator, you can do:\n\n\nxt, yt, vxt, vyt, ts = construct(evolve!(p, bt, 1000.0)...)\n\n\n\n\n\n\nMagnetic Propagation\n\n\n\n\nThe are only two differences between magnetic and straight propagation.  Firstly, the particle type is not \nParticle\n anymore, but \nMagneticParticle\n.  The latter has an extra field called \nomega\n which is the cyclic frequency of rotation  (equivalently, the angular velocity). In order to create a \nMagneticParticle\n (without using the constructors),  you simply provide this extra information to the \nrandominside()\n function:\n\n\n\u03c9 = 0.5\np = randominside(bt, \u03c9)\ntypeof(p) # MagneticParticle\np.omega   # 0.5\n\n\n\n\nTo propagate the particle you use the same functions:\n\n\nct, poss, vels, \u03c9 = evolve!(p, bt, 1000.0)  #evolve for magnetic also returns \u03c9\nxt, yt, vxt, vyt, ts = construct(ct, poss, vels, \u03c9, dt)\n# or equivalently: \nxt, yt, vxt, vyt, ts = construct(evolve!(p, bt, 1000.0)..., dt)\n\n\n\n\nAs you can see, the second difference is that the additional argument of the angular velocity must also be provided  to the \nconstruct()\n function, in order for it to construct circular motion instead of straight motion between collisions.  (Note: \nevolve!()\n returns 4 arguments for magnetic propagation, making the ellipsis syntax extremely useful!).\n\n\nThe final optional argument \ndt\n is the time-step at which the timeseries are constructed  (since they are made up of sines and cosines).\n\n\n\n\nRay-Splitting\n\n\n\n\nNo matter how complex ray-splitting processes you want, and irrespectively of how many obstacles in the billiard table can perform ray-splitting, there is only a single difference on the main function call: The \nevolve!()\n function is supplemented with a fourth argument, called \"ray_splitter\":\n\n\nray_splitter::Dict{Int, Vector{Function}}\n\n\n\n\nThis argument is simply a dictionary which handles all ray-splitting processes in the billiard system. It is a map of the Obstacle index within the billiard table to the ray-splitting functions: (\u03c6 is the angle of incidence)\n\n\n\n\nT(\u03c6, where, \u03c9) : Transmission probability.\n\n\n\u03b8(\u03c6, where, \u03c9) : Transmission (aka diffraction) angle.\n\n\nnew_\u03c9(\u03c9, where) : Angular velocity after transmission.\n\n\n\n\nAssuming you have defined a billiard table and a ray-splitter dictionary, the implementation is exactly the same as in the two previous cases: the ray-splitting dictionary is passed to \nevolve!()\n as a fourth argument.\n\n\nray_splitter = Dict(5 =\n [foo, bar, baz])\np = randominside(bt, 4.0)\nxt, yt, vxt, vyt, ts = construct(evolve!(p, bt, 100.0, ray_splitter)..., dt = 0.01)\n\n\n\n\nFor more information and instructions on defining the \"ray_splitter\" dictionary visit the \nRay-Splitting tutorial here\n.\n\n\n\n\nVisualizing\n\n\n\n\n\n\nNote\n\n\nPlotting in \nDynamicalBilliards\n is currently done through the \nPyPlot\n package. However the development has now  switched to using \nPlots\n in conjuction with \nRecipesBase\n. Until those changes are final, the plotting features  of this package are summarized in the following paragraphs.\n\n\n\n\nThe functions \nplot_obstacle(o::Obstacle; kwargs...)\n, \nplot_billiard(bt::Vector{Obstacle}; kwargs...)\n and \nplot_particle(p::AbstractParticle; kwargs...)\n are provided in order to plot the respective elements \non the current PyPlot figure\n. In order to animate the evolution of a particle in a billiard table, use the function:\n\n\nplot_evolution(p::AbstractParticle, bt::Vector{Obstacle}, colnumber = 50;\n               sleeptime = 0.5, col_to_plot = 5, color = (0,0,1), savefigs = false, savename = \n)\n\n\n\n\nwhich propagates the particle from collision to collision up to a total of \ncolnumber\n collisions. Then, it draws the collisions, drawing always only the last \ncol_to_plot\n collisions with orbit color \ncolor\n.  \nsleeptime\n signals the waiting time between each plot update.\n\n\nDirect animation saving is not supported yet. However, optionally, you could save each figure of the animation using \nsavefigs = true\n and \nsavename = \"path/to/your/folder/figurename\"\n. A total of \ncolnumber\n figures will be created, ending with \n_#.png\n.\n\n\nBe sure to first call \nplot_billiard\n before calling \nplot_evolution\n.\n\n\nThe example .gif shown in the introduction, was generated simply with the code:\n\n\nusing DynamicalBilliards\nusing PyPlot\n\nbt = billiard_rectangle(1.5, 1.0)\nd1 = Disk([0.45, 0.6], 0.3, \nUpper-left Disk\n)\nd2 = Disk([1.1, 0.3], 0.15, \nLower-right Disk\n)\nd3 = Disk([1.2, 0.8], 0.1, \nSmall Disk\n)\nw1 = FiniteWall([0.0, 0.4], [0.6,0.0], [0.4,0.6], \nDiagonal\n)\npush!(bt, d1, d2, d3, w1)\n\u03c9 = 2.0\np = randominside(bt, \u03c9)\n\nplot_billiard(bt)\naxis(\noff\n)\ntight_layout()\nxlim(0,1.5)\nylim(0,1.0)\n\nsname = \nC:\\\\***\\\\example\n\nplot_evolution(p, bt, 200;\nsleeptime = 0.1, col_to_plot = 4, savefigs = true, savename = sname)\n\n\n\n\nAfterwards the outputed .png files where merged into a single .gif externally.\n\n\nA full overview of all plotting procedures offered by this package is coming soon.", 
            "title": "Basic Usage"
        }, 
        {
            "location": "/basic/basic_usage/#basic-usage", 
            "text": "DynamicalBilliards.jl  was created with easy-of-use as its main cornerstone.  With 3 simple steps, the user can fully initalize, evolve, and get the output of the propagation of a particle in a billiard system.  In general, the workflow of  DynamicalBilliards.jl  follows these simple steps:   Create a billiard table, a  Vector{Obstacle} .  Create a particle inside that billiard table.  Get the output by evolving the particle.   Adding more complexity in your billiard table does not add complexity in your code. For example, to implement a ray-splitting billiard you only need to define one additional variable, a dictionary  Dict{Int, Vector{Function}} . After reading through this basic usage page,  you will be able to use all aspects of  DynamicalBilliards.jl  with minimal effort.", 
            "title": "Basic Usage"
        }, 
        {
            "location": "/basic/basic_usage/#straight-propagation", 
            "text": "The usage of this package revolves around a single function:   evolve!(p::AbstractParticle, bt::Vector{Obstacle}, total_time)  which evolves a particle  p  inside a billiard table  bt  for a given amount of time  total_time ,  while taking care of all the details internally.   The first step is to define the billiard table  bt , which is the system the particle  p  will propagate in.  A billiard table is simply a collection ( Vector ) of  Obstacle s. The most convenient way is to use  one of the pre-defined billiard tables offered by the package. For example, let's create a periodic Sinai  billiard with disk radius of 0.3 and with one side of length 2 and one of length 1:  using DynamicalBilliards\nbt = billiard_sinai(0.3, 2.0, 1.0; periodic=true)  (for more information about defining billiard tables visit the  tutorial on defining your own billiard table )  Afterwards, you want to create a particle inside that billiard system.  For that, the function  randominside(bt::Vector{Obstacle})  is provided.  This function returns a particle with random initial conditions inside the billiard table,  while making sure that it is always in the allowed region of the billiard table.  p = randominside(bt)  If you want to specify the initial conditions yourself, simply pass them to the  Particle  constructor, like  p = Particle(x0, y0, \u03c60) . Now you are ready to evolve this particle:  ct, poss, vels = evolve!(p, bt, 1000.0)  The return values of the  evolve!()  function need some brief explaining: As noted by the \"!\" at the end of the function,  it changes its argument  p . Most importantly however, this function also returns the main output expected by a billiard system. This output is a tuple of three vectors:   ct::Vector  : Collision times.  poss::Vector{SVector{2}}  : Positions during collisions.  vels:: Vector{SVector{2}})  : Velocities  exactly after  the collisions (i.e. reflections).   The time  t[i]  is the time necessary to reach state  poss[i], vels[i]  starting from the state  poss[i-1], vels[i-1] . That is why  t[1]  is always 0 since  poss[1], vels[1]  are the initial conditions.  If this output is not convenient for you, the function  construct(ct, poss, vels)  is provided,  which constructs the (continuous) timeseries of the position and velocity, as well as the time-vector, when given the main output of  evolve!() :  xt, yt, vxt, vyt, ts = construct(ct, poss, vels)  or, by taking advantage of the awesome ellipsis operator, you can do:  xt, yt, vxt, vyt, ts = construct(evolve!(p, bt, 1000.0)...)", 
            "title": "Straight Propagation"
        }, 
        {
            "location": "/basic/basic_usage/#magnetic-propagation", 
            "text": "The are only two differences between magnetic and straight propagation.  Firstly, the particle type is not  Particle  anymore, but  MagneticParticle .  The latter has an extra field called  omega  which is the cyclic frequency of rotation  (equivalently, the angular velocity). In order to create a  MagneticParticle  (without using the constructors),  you simply provide this extra information to the  randominside()  function:  \u03c9 = 0.5\np = randominside(bt, \u03c9)\ntypeof(p) # MagneticParticle\np.omega   # 0.5  To propagate the particle you use the same functions:  ct, poss, vels, \u03c9 = evolve!(p, bt, 1000.0)  #evolve for magnetic also returns \u03c9\nxt, yt, vxt, vyt, ts = construct(ct, poss, vels, \u03c9, dt)\n# or equivalently: \nxt, yt, vxt, vyt, ts = construct(evolve!(p, bt, 1000.0)..., dt)  As you can see, the second difference is that the additional argument of the angular velocity must also be provided  to the  construct()  function, in order for it to construct circular motion instead of straight motion between collisions.  (Note:  evolve!()  returns 4 arguments for magnetic propagation, making the ellipsis syntax extremely useful!).  The final optional argument  dt  is the time-step at which the timeseries are constructed  (since they are made up of sines and cosines).", 
            "title": "Magnetic Propagation"
        }, 
        {
            "location": "/basic/basic_usage/#ray-splitting", 
            "text": "No matter how complex ray-splitting processes you want, and irrespectively of how many obstacles in the billiard table can perform ray-splitting, there is only a single difference on the main function call: The  evolve!()  function is supplemented with a fourth argument, called \"ray_splitter\":  ray_splitter::Dict{Int, Vector{Function}}  This argument is simply a dictionary which handles all ray-splitting processes in the billiard system. It is a map of the Obstacle index within the billiard table to the ray-splitting functions: (\u03c6 is the angle of incidence)   T(\u03c6, where, \u03c9) : Transmission probability.  \u03b8(\u03c6, where, \u03c9) : Transmission (aka diffraction) angle.  new_\u03c9(\u03c9, where) : Angular velocity after transmission.   Assuming you have defined a billiard table and a ray-splitter dictionary, the implementation is exactly the same as in the two previous cases: the ray-splitting dictionary is passed to  evolve!()  as a fourth argument.  ray_splitter = Dict(5 =  [foo, bar, baz])\np = randominside(bt, 4.0)\nxt, yt, vxt, vyt, ts = construct(evolve!(p, bt, 100.0, ray_splitter)..., dt = 0.01)  For more information and instructions on defining the \"ray_splitter\" dictionary visit the  Ray-Splitting tutorial here .", 
            "title": "Ray-Splitting"
        }, 
        {
            "location": "/basic/basic_usage/#visualizing", 
            "text": "Note  Plotting in  DynamicalBilliards  is currently done through the  PyPlot  package. However the development has now  switched to using  Plots  in conjuction with  RecipesBase . Until those changes are final, the plotting features  of this package are summarized in the following paragraphs.   The functions  plot_obstacle(o::Obstacle; kwargs...) ,  plot_billiard(bt::Vector{Obstacle}; kwargs...)  and  plot_particle(p::AbstractParticle; kwargs...)  are provided in order to plot the respective elements  on the current PyPlot figure . In order to animate the evolution of a particle in a billiard table, use the function:  plot_evolution(p::AbstractParticle, bt::Vector{Obstacle}, colnumber = 50;\n               sleeptime = 0.5, col_to_plot = 5, color = (0,0,1), savefigs = false, savename =  )  which propagates the particle from collision to collision up to a total of  colnumber  collisions. Then, it draws the collisions, drawing always only the last  col_to_plot  collisions with orbit color  color .   sleeptime  signals the waiting time between each plot update.  Direct animation saving is not supported yet. However, optionally, you could save each figure of the animation using  savefigs = true  and  savename = \"path/to/your/folder/figurename\" . A total of  colnumber  figures will be created, ending with  _#.png .  Be sure to first call  plot_billiard  before calling  plot_evolution .  The example .gif shown in the introduction, was generated simply with the code:  using DynamicalBilliards\nusing PyPlot\n\nbt = billiard_rectangle(1.5, 1.0)\nd1 = Disk([0.45, 0.6], 0.3,  Upper-left Disk )\nd2 = Disk([1.1, 0.3], 0.15,  Lower-right Disk )\nd3 = Disk([1.2, 0.8], 0.1,  Small Disk )\nw1 = FiniteWall([0.0, 0.4], [0.6,0.0], [0.4,0.6],  Diagonal )\npush!(bt, d1, d2, d3, w1)\n\u03c9 = 2.0\np = randominside(bt, \u03c9)\n\nplot_billiard(bt)\naxis( off )\ntight_layout()\nxlim(0,1.5)\nylim(0,1.0)\n\nsname =  C:\\\\***\\\\example \nplot_evolution(p, bt, 200;\nsleeptime = 0.1, col_to_plot = 4, savefigs = true, savename = sname)  Afterwards the outputed .png files where merged into a single .gif externally.  A full overview of all plotting procedures offered by this package is coming soon.", 
            "title": "Visualizing"
        }, 
        {
            "location": "/tutorials/billiard_table/", 
            "text": "A billiard table \nbt\n is a vector of Obstacles: \nbt::Vector{Obstacle}\n.  The abstract Type \nObstacle\n is the supertype of all objects that a particle may collide with.\n\n\nThere are many premade functions that construct well-known billiards, like the periodic Sinai billiard. You can find all of them at the \nStandard Billiards page\n.\n\n\nTo create a custom billiard, you start with an empty Vector:\n\n\nbt = Obstacle[]\n\n\n\n\nand then you create your obstacles one by one and add them to it. All obstacles that are already defined in the package can be found at the \nObstacles page\n of the library. The function \nbilliard_polygon\n creates a polygonal billiard table.  However, for the example of this page, we will create a hexagonal billiard with a disk in the middle step-by-step.\n\n\nThe first step is to define the six walls of the billiard table. A \nFiniteWall\n object needs to be supplemented with a start point, an end point, a normal vector and, optionally, a name. The vertex points of a regular hexagon of radius \nr\n are given by the formula:\n\n\n$$\n(x,y) = \\left( r\\cos\\left(\\frac{2\\pi i}{6}\\right), r\\cos\\left(\\frac{2\\pi i}{6}\\right) \\right)\\,, \\quad \\text{for i $\\in$ {1,...,6}}\n$$\n\n\nTo create each wall object, we will implement the following loop, choosing a size of 2.0:\n\n\nusing DynamicalBilliards\nhexagon_vertex = (r) -\n [ [r*cos(2\u03c0*i/6), r*sin(2\u03c0*i/6)] for i in 1:6]\nhexver = hexagon_vertex(2.0)\n\nfor i in eachindex(hexver)\n  starting = hexver[i]\n  ending = hexver[mod1(i+1, length(hexver))]\n  w = ending - starting\n  normal = [-w[2], w[1]]\n  wall = FiniteWall(starting, ending, normal, \nwall $i\n)\n  push!(bt, wall)\nend\n\n\n\n\nThe \nnormal\n vector of a \nWall\n obstacle is necessary to be supplemented by the user because it must point towards where the particle is expected to come from. If \nw\n is the vector (wall) pointing from start- to end-point then the vector \n[-w[2], w[1]]\n is pointing to the left of \nw\n and the vector \n[w[2], -[w1]]\n is pointing to the right. Both are normal to \nw\n, but you have to know which one to pick. In this case this is very easy, since the normal has to simply point towards the origin.\n\n\nWe add a disk by specifying a center and radius (and optionally a name): \n\n\nd = Disk([0,0], 0.8)\npush!(bt, d)\n\n\n\n\nTo make sure the billiard looks as you would expect, use the function \nplot_billiard(bt)\n. Create a particle inside that billiard and evolve it:\n\n\nplot_billiard(bt)\n\u03c9 = 0.5\np = randominside(p, \u03c9)\nxt, yt, vxt, vyt, t = construct(evolve!(p, bt, 100)...)\n\n\n\n\nThe billiard table now works for straight or magnetic propagation.  To expand this to ray-splitting you have to use ray-splitting Obstacles (\nsee the tutorial on Ray-Splitting\n).  Additional information on how to define your own \nObstacle\n sub-type is given in the tutorial on \nCefining your own Obstacles\n.\n\n\nIf you make any billiard system that you think is common and missing from this package, you are more than welcome to submit a PR extending the \nStandardBilliards.jl\n library with your contribution!", 
            "title": "Defining a Billiard Table"
        }, 
        {
            "location": "/tutorials/ray-splitting/", 
            "text": "Ray-Splitting\n\n\nRay-splitting is a semiclassical approach to the billiard system, giving a wave attribute to the ray traced by the particle. Upon collision a particle may propagate through an obstacle (transmission \n refraction) or be reflected. Following the mindset of this package, implementing a ray-splitting billiard requires only three very simple steps.\n\n\n\n\nRay-Splitting Obstacles\n\n\nFirst, an obstacle that supports ray-splitting is required to be present in your billiard table. The only new feature these obstacles have is an additional Boolean field called \nwhere\n. This field notes on which side of the obstacle the particle is currently propagating \n(if you are wondering how a distance can change sign, see the tutorial on Defining your own Obstacles)\n. The normal vector as well as the distance from boundary change sign depending on the value of \nwhere\n. The obstacles \nAntidot\n and \nSplitterWall\n are the equivalents of disk and wall for ray-splitting. To make your own defined obstacle support ray-splitting, visit this tutorial.\n\n\n\n\nThere is a simple reason for having extra Types to support ray-splitting: non ray-splitting Types  always perform 2 less operations in their innermost loops, saving a bit of time. Also, ray-splitting obstacles are defined as \ntype\n instead of as \nimmutable\n.\n\n\n\n\nLet's add an \nAntidot\n to a billiard table:\n\n\nusing DynamicalBilliards\nbt = billiard_rectangle()\na = Antidot([0.5,0.5], 0.3)\npush!(bt, a)\n\n\n\n\n\n\nRay-Splitting Functions\n\n\nSecondly, for each obstacle in your billiard table that will perform ray-splitting, you have to define 3 functions. Notice that not every obstacle that supports ray-splitting actually has to perform it; it is up to the user. Those 3 functions are the following:\n\n\n\n\nT(\u03c6, \nwhere\n, \u03c9) : Takes as input the angle of incidence \u03c6 and returns the transmission probability \u03a4 depending on  whether the particle is inside or outside the obstacle (\nwhere\n) and optionally depending on \u03c9.  This function should be an even function with respect to \u03c6.\n\n\n\u03b8(\u03c6, \nwhere\n, \u03c9) : Takes as input the angle of incidence     \u03c6 and returns the the transmission (aka refraction)  angle \u03b8  depending on whether the particle is inside or outside the obstacle (\nwhere\n) and optionally depending on \u03c9.  This function should be an odd function with respect to \u03c6.\n\n\n\u03c9_new(\u03c9, \nwhere\n) : Angular velocity after transmission.\n\n\n\n\nThe above three functions use the \nsame convention\n: the argument \nwhere\n is the one the Obstacle has \nbefore transmission\n. For example, if a particle is outside a disk (let \nwhere = true\n here) and is transmitted inside the disk (\nwhere\n becomes \nfalse\n here), then all three functions will be given their second argument (the boolean one) as \ntrue\n!\n\n\n\n\nRay-Splitter Dictionary\n\n\nTo pass the information of the aforementioned functions into the main API (\nevolve!()\n) a dictionary is required, which we will call \"raysplitter\": \nraysplitter::Dict{Int, Vector{Function}}\n. The keys are integers and the values are vectors of functions.  This dictionary is a map of the obstacle index within the billiard table to the ray-splitting functions. For example, if we wanted to allocate ray-splitting functions for the 5th obstacle in our billiard table, which could be e.g. an \nAntidot\n, we would write something like:\n\n\nsa = (\u03b8, where, \u03c9) -\n where ? 2\u03b8 : 0.5\u03b8\nT = (\u03b8, where, \u03c9) -\n begin\n  if where\n    abs(\u03b8) \n \u03c0/4 ? 0.5exp(-(\u03b8)^2/2(\u03c0/8)^2) : 0.0\n  else\n    0.75*exp(-(\u03b8)^2/2(\u03c0/4)^2)\n  end\nend\nnewo = (\u03c9, bool) -\n bool ? -0.5\u03c9 : -2\u03c9\nraysplitter = Dict(5 =\n [T, sa, newo])\n\n\n\n\nNotice the following two very important points: The functions \nmust accept the specific number of arguments shown in the previous section\n even if some are not used. Also, the functions must be given \nin the specific order: 1. transmission probability, 2. refraction angle, 3. new \u03c9\n in the vector passed to the dictionary.\n\n\nThe next step is very simple: the \nraysplitter\n dictionary is directly passed into \nevolve!()\n as a fourth argument.  Using the billiard table we defined previously, where its 5th element is a ray-splitting \nAntidot\n, we now do:\n\n\n\u03c9 = 4.0\np = randominside(bt, \u03c9)\nxt, yt, vxt, vyt, ts = construct(evolve!(p, bt, 100.0, raysplitter)..., dt = 0.05)\nplot_billiard(bt)\nplot(xt, yt)\n\n\n\n\nand everything works like a charm! A final difference to be noted is that in the case of ray-splitting with magnetic fields, the fourth value returned by \nevolve!()\n is not a number, but a vector of angular velocities \nomegas\n. The value \nomegas[i]\n is the angular velocity the particle has while propagating from state \npos[i], vel[i]\n to state \npos[i+1], vel[i+1]\n. The \nconstruct()\n function takes this into account.\n\n\n\n\nPhysics\n\n\nThe condition for transmission is simply: \nT(\u03c6, where, \u03c9) \n rand()\n. If it returns \ntrue\n, transmission (i.e. ray-splitting) will happen. Otherwise just specular reflection will take place.\n\n\nThe three key functions given to the \nraysplitter\n dictionary must have some properties in order to have physical meaning, like for example that the scattering probability function is even towards \u03c6. One of these properties is absolutely \nmandatory\n for this package to work properly. This is the property of total internal reflection, i.e. if the refraction angle is calculated to be greater/equal than \u03c0/2, no transmission can happen. \nThis condition is not assured internally\n and thefore you must be sure that your transmission probability function satisfies it. In the above example, the function \nT\n makes sure to return 0 in that case.\n\n\nIn order to test if the \nraysplitter\n dictionary you have defined has physical meaning, the function \nisphysical()\n is provided. Its documentation string has all the details one should know:\n\n\n\n\njulia\nisphysical(raysplitter::Dict{Int, Vector{Function}}; only_mandatory = false)\n\n\nReturn \ntrue\n if the given ray-splitting dictionary has properties of the physical world.\n\n\nSpecifically, check if (\u03c6 is the incidence angle):\n\n\n\n\nCritical angle means total reflection: If \u03b8(\u03c6) \u2265 \u03c0/2 then T(\u03c6) = 0\n\n\nTransmission probability is even function: T(\u03c6) \u2248 T(-\u03c6)\n\n\nRefraction angle is odd function: \u03b8(\u03c6) \u2248 -\u03b8(-\u03c6)\n\n\nRay reversal is true: \u03b8(\u03b8(\u03c6, where, \u03c9), !where, \u03c9) \u2248 \u03c6\n\n\nMagnetic conservation is true: (\u03c9_new(\u03c9_new(\u03c9, where), !where) \u2248 \u03c9\n\n\n\n\nThe first property is mandatory and must hold for correct propagation. They keyword \nonly_mandatory\n notes whether the rest of the properties should be tested or not.\n\n\n\n\n\n\nVelocity measure\n\n\nThe \nMagneticParticle\n is assumed to always have a velocity vector of measure 1. This simplyfies the formulas used internally to a significant amount. During ray-splitting, the particle may be in areas with different fields, resulting in different angular velocities (result of the \"\u03c9_new\" function).\n\n\nPhysically, in such a situation, the velocity measure of the particle will also change. This is not implemented internally by \nDynamicalBilliards\n  during the evolution of the particle. However it is very easy to change this after the particle has evolved.", 
            "title": "Ray-Splitting"
        }, 
        {
            "location": "/tutorials/ray-splitting/#ray-splitting", 
            "text": "Ray-splitting is a semiclassical approach to the billiard system, giving a wave attribute to the ray traced by the particle. Upon collision a particle may propagate through an obstacle (transmission   refraction) or be reflected. Following the mindset of this package, implementing a ray-splitting billiard requires only three very simple steps.", 
            "title": "Ray-Splitting"
        }, 
        {
            "location": "/tutorials/ray-splitting/#ray-splitting-obstacles", 
            "text": "First, an obstacle that supports ray-splitting is required to be present in your billiard table. The only new feature these obstacles have is an additional Boolean field called  where . This field notes on which side of the obstacle the particle is currently propagating  (if you are wondering how a distance can change sign, see the tutorial on Defining your own Obstacles) . The normal vector as well as the distance from boundary change sign depending on the value of  where . The obstacles  Antidot  and  SplitterWall  are the equivalents of disk and wall for ray-splitting. To make your own defined obstacle support ray-splitting, visit this tutorial.   There is a simple reason for having extra Types to support ray-splitting: non ray-splitting Types  always perform 2 less operations in their innermost loops, saving a bit of time. Also, ray-splitting obstacles are defined as  type  instead of as  immutable .   Let's add an  Antidot  to a billiard table:  using DynamicalBilliards\nbt = billiard_rectangle()\na = Antidot([0.5,0.5], 0.3)\npush!(bt, a)", 
            "title": "Ray-Splitting Obstacles"
        }, 
        {
            "location": "/tutorials/ray-splitting/#ray-splitting-functions", 
            "text": "Secondly, for each obstacle in your billiard table that will perform ray-splitting, you have to define 3 functions. Notice that not every obstacle that supports ray-splitting actually has to perform it; it is up to the user. Those 3 functions are the following:   T(\u03c6,  where , \u03c9) : Takes as input the angle of incidence \u03c6 and returns the transmission probability \u03a4 depending on  whether the particle is inside or outside the obstacle ( where ) and optionally depending on \u03c9.  This function should be an even function with respect to \u03c6.  \u03b8(\u03c6,  where , \u03c9) : Takes as input the angle of incidence     \u03c6 and returns the the transmission (aka refraction)  angle \u03b8  depending on whether the particle is inside or outside the obstacle ( where ) and optionally depending on \u03c9.  This function should be an odd function with respect to \u03c6.  \u03c9_new(\u03c9,  where ) : Angular velocity after transmission.   The above three functions use the  same convention : the argument  where  is the one the Obstacle has  before transmission . For example, if a particle is outside a disk (let  where = true  here) and is transmitted inside the disk ( where  becomes  false  here), then all three functions will be given their second argument (the boolean one) as  true !", 
            "title": "Ray-Splitting Functions"
        }, 
        {
            "location": "/tutorials/ray-splitting/#ray-splitter-dictionary", 
            "text": "To pass the information of the aforementioned functions into the main API ( evolve!() ) a dictionary is required, which we will call \"raysplitter\":  raysplitter::Dict{Int, Vector{Function}} . The keys are integers and the values are vectors of functions.  This dictionary is a map of the obstacle index within the billiard table to the ray-splitting functions. For example, if we wanted to allocate ray-splitting functions for the 5th obstacle in our billiard table, which could be e.g. an  Antidot , we would write something like:  sa = (\u03b8, where, \u03c9) -  where ? 2\u03b8 : 0.5\u03b8\nT = (\u03b8, where, \u03c9) -  begin\n  if where\n    abs(\u03b8)   \u03c0/4 ? 0.5exp(-(\u03b8)^2/2(\u03c0/8)^2) : 0.0\n  else\n    0.75*exp(-(\u03b8)^2/2(\u03c0/4)^2)\n  end\nend\nnewo = (\u03c9, bool) -  bool ? -0.5\u03c9 : -2\u03c9\nraysplitter = Dict(5 =  [T, sa, newo])  Notice the following two very important points: The functions  must accept the specific number of arguments shown in the previous section  even if some are not used. Also, the functions must be given  in the specific order: 1. transmission probability, 2. refraction angle, 3. new \u03c9  in the vector passed to the dictionary.  The next step is very simple: the  raysplitter  dictionary is directly passed into  evolve!()  as a fourth argument.  Using the billiard table we defined previously, where its 5th element is a ray-splitting  Antidot , we now do:  \u03c9 = 4.0\np = randominside(bt, \u03c9)\nxt, yt, vxt, vyt, ts = construct(evolve!(p, bt, 100.0, raysplitter)..., dt = 0.05)\nplot_billiard(bt)\nplot(xt, yt)  and everything works like a charm! A final difference to be noted is that in the case of ray-splitting with magnetic fields, the fourth value returned by  evolve!()  is not a number, but a vector of angular velocities  omegas . The value  omegas[i]  is the angular velocity the particle has while propagating from state  pos[i], vel[i]  to state  pos[i+1], vel[i+1] . The  construct()  function takes this into account.", 
            "title": "Ray-Splitter Dictionary"
        }, 
        {
            "location": "/tutorials/ray-splitting/#physics", 
            "text": "The condition for transmission is simply:  T(\u03c6, where, \u03c9)   rand() . If it returns  true , transmission (i.e. ray-splitting) will happen. Otherwise just specular reflection will take place.  The three key functions given to the  raysplitter  dictionary must have some properties in order to have physical meaning, like for example that the scattering probability function is even towards \u03c6. One of these properties is absolutely  mandatory  for this package to work properly. This is the property of total internal reflection, i.e. if the refraction angle is calculated to be greater/equal than \u03c0/2, no transmission can happen.  This condition is not assured internally  and thefore you must be sure that your transmission probability function satisfies it. In the above example, the function  T  makes sure to return 0 in that case.  In order to test if the  raysplitter  dictionary you have defined has physical meaning, the function  isphysical()  is provided. Its documentation string has all the details one should know:   julia\nisphysical(raysplitter::Dict{Int, Vector{Function}}; only_mandatory = false)  Return  true  if the given ray-splitting dictionary has properties of the physical world.  Specifically, check if (\u03c6 is the incidence angle):   Critical angle means total reflection: If \u03b8(\u03c6) \u2265 \u03c0/2 then T(\u03c6) = 0  Transmission probability is even function: T(\u03c6) \u2248 T(-\u03c6)  Refraction angle is odd function: \u03b8(\u03c6) \u2248 -\u03b8(-\u03c6)  Ray reversal is true: \u03b8(\u03b8(\u03c6, where, \u03c9), !where, \u03c9) \u2248 \u03c6  Magnetic conservation is true: (\u03c9_new(\u03c9_new(\u03c9, where), !where) \u2248 \u03c9   The first property is mandatory and must hold for correct propagation. They keyword  only_mandatory  notes whether the rest of the properties should be tested or not.", 
            "title": "Physics"
        }, 
        {
            "location": "/tutorials/ray-splitting/#velocity-measure", 
            "text": "The  MagneticParticle  is assumed to always have a velocity vector of measure 1. This simplyfies the formulas used internally to a significant amount. During ray-splitting, the particle may be in areas with different fields, resulting in different angular velocities (result of the \"\u03c9_new\" function).  Physically, in such a situation, the velocity measure of the particle will also change. This is not implemented internally by  DynamicalBilliards   during the evolution of the particle. However it is very easy to change this after the particle has evolved.", 
            "title": "Velocity measure"
        }, 
        {
            "location": "/tutorials/own_obstacle/", 
            "text": "Creating your own \nObstacle\n Type\n\n\nThis tutorial will be about how to create your own obstacle type.", 
            "title": "Creating your own Obstacle"
        }, 
        {
            "location": "/tutorials/own_obstacle/#creating-your-own-obstacle-type", 
            "text": "This tutorial will be about how to create your own obstacle type.", 
            "title": "Creating your own Obstacle Type"
        }, 
        {
            "location": "/tutorials/examples/", 
            "text": "Here there will be examples in the format: Code followed by some animated gif.", 
            "title": "Examples"
        }, 
        {
            "location": "/basic/library/", 
            "text": "Below you find all the docstrings of all exported names of \nDynamicalBilliards.jl\n in convenient groups.\n\n\n\n\nParticles\n\n\n#\n\n\nDynamicalBilliards.Particle\n \n \nType\n.\n\n\nParticle \n: AbstractParticle\n\n\n\n\nTwo-dimensional particle in a billiard table.\n\n\nFields:\n\n\n\n\npos::SVector{2,Float64}\n : Current position vector.\n\n\nvel::SVector{2,Float64}\n : Current velocity vector (always of measure 1).\n\n\ncurrent_cell::SVector{2,Float64}\n : Current \"cell\" the particle is located at. (Used only in periodic billiards)\n\n\n\n\nAdditional constructors:\n\n\nParticle{T\n:Real}(ic::Vector{T}) #where ic = [x0, y0, \u03c60]\nParticle(x::Real, y::Real, \u03c6::Real)\nParticle() = Particle(rand(), rand(), rand()*2\u03c0)\n\n\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.MagneticParticle\n \n \nType\n.\n\n\nMagneticParticle \n: AbstractParticle\n\n\n\n\nTwo-dimensional particle in a billiard table with perpendicular magnetic field.\n\n\nFields:\n\n\n\n\npos::SVector{2,Float64}\n : Current position vector.\n\n\nvel::SVector{2,Float64}\n : Current velocity vector (always of measure 1).\n\n\ncurrent_cell::SVector{2,Float64}\n : Current \"cell\" the particle is located at. (Used only in periodic billiards)\n\n\nomega::Float64\n : Angular velocity (cyclic frequency) of rotational motion. Radius of rotation is \nr=1/omega\n.\n\n\n\n\nAdditional constructors:\n\n\nMagneticParticle{T\n:Real}(ic::Vector{T}, \u03c9::Real) #where ic = [x0, y0, \u03c60]\nMagneticParticle(x0::Real, y0::Real, \u03c60::Real, \u03c9::Real)\nMagneticParticle() = MagneticParticle([rand(), rand(), rand()*2\u03c0], 1.0)\n\n\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.magnetic2standard\n \n \nFunction\n.\n\n\nmagnetic2standard(p::MagneticParticle, use_cell = true)\n\n\n\n\nCreate a standard \nParticle\n from a \nMagneticParticle\n.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.standard2magnetic\n \n \nFunction\n.\n\n\nstandard2magnetic(omega, p::Particle, use_cell = true)\n\n\n\n\nCreate a \nMagneticParticle\n from a \nParticle\n.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.cyclotron\n \n \nFunction\n.\n\n\ncyclotron(p::MagneticParticle, use_cell = false)\n\n\n\n\nReturn center and radius of circular motion performed by the particle based on \np.pos\n (or \np.pos + p.current_cell\n) and \np.vel\n.\n\n\nsource\n\n\n\n\nObstacles\n\n\n#\n\n\nDynamicalBilliards.Obstacle\n \n \nType\n.\n\n\nObstacle\n\n\n\n\nObstacle supertype.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.Disk\n \n \nType\n.\n\n\nDisk \n: Circular\n\n\n\n\nDisk-like obstacle with propagation allowed outside of the circle.\n\n\nFields:\n\n\n\n\nc::SVector{2,Float64}\n : Center.\n\n\nr::Float64\n : Radius.\n\n\nname::String\n : Some name given for user convenience.\n\n\n\n\nConstructors accept any vectors convertible to SVector{2,Float64}.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.Antidot\n \n \nType\n.\n\n\nAntidot \n: Circular\n\n\n\n\nDisk-like obstacle that allows propagation both inside and outside of the disk. Used in ray-splitting billiards.\n\n\nFields:\n\n\n\n\nc::SVector{2,Float64}\n : Center.\n\n\nr::Float64\n : Radius.\n\n\nwhere::Bool\n : Flag that keeps track of where the particle is currently propagating. \ntrue\n stands for \noutside\n the disk, \nfalse\n for \ninside\n the disk.\n\n\nname::String\n : Name of the obstacle given for user convenience.\n\n\n\n\nConstructors accept any vectors convertible to SVector{2,Float64}.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.FiniteWall\n \n \nType\n.\n\n\nFiniteWall \n: Wall\n\n\n\n\nWall obstacle imposing specular reflection during collision.\n\n\nFields:\n\n\n\n\nsp::SVector{2,Float64}\n : Starting point of the Wall.\n\n\nep::SVector{2,Float64}\n : Ending point of the Wall.\n\n\nnormal::SVector{2,Float64}\n : Normal vector to the wall, pointing to where the particle \nwill come from before a collision\n (pointing towards the inside the billiard table). The size of the vector is irrelevant.\n\n\nname::String\n : Name of the obstacle, e.g. \"left wall\", given for user convenience.\n\n\n\n\nConstructors accept any vectors convertible to SVector{2,Float64}.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.PeriodicWall\n \n \nType\n.\n\n\nPeriodicWall \n: Wall\n\n\n\n\nWall obstacle that imposes periodic boundary conditions upon collision.\n\n\nFields:\n\n\n\n\nsp::SVector{2,Float64}\n : Starting point of the Wall.\n\n\nep::SVector{2,Float64}\n : Ending point of the Wall.\n\n\nnormal::SVector{2,Float64}\n : Normal vector to the wall, pointing to where the particle \nwill come from\n (to the inside the billiard table). The size of the vector is \nimportant\n. This vector is added to a particle's \npos\n during collision. Therefore the size of the normal vector must be correctly associated with the size of the periodic cell.\n\n\nname::String\n : Name of the obstacle, e.g. \"left boundary\", given for user convenience.\n\n\n\n\nConstructors accept any vectors convertible to SVector{2,Float64}.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.SplitterWall\n \n \nType\n.\n\n\nSplitterWall \n: Wall\n\n\n\n\nWall obstacle imposing specular reflection during collision.\n\n\nFields:\n\n\n\n\nsp::SVector{2,Float64}\n : Starting point of the Wall.\n\n\nep::SVector{2,Float64}\n : Ending point of the Wall.\n\n\nnormal::SVector{2,Float64}\n : Normal vector to the wall, pointing to where the particle \nwill come from before a collision\n. The size of the vector is irrelevant.\n\n\nwhere::Bool\n : Flag that keeps track of where the particle is currently propagating. \ntrue\n is associated with the \nnormal\n vector the wall is instantiated with.\n\n\nname::String\n : Name of the obstacle, e.g. \"ray-splitting wall 1\", given for user convenience.\n\n\n\n\nConstructors accept any vectors convertible to SVector{2,Float64}.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.normalvec\n \n \nFunction\n.\n\n\nnormalvec(obst::Obstacle, position)\n\n\n\n\nReturn the vector normal to the obstacle at the given position (which is assumed to be very close to the obstacle's boundary).\n\n\nThe normal vector of any Obstacle must be looking towards the direction a particle is expected to come from.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.distance\n \n \nFunction\n.\n\n\ndistance(p::AbstractParticle, o::Obstacle)\n\n\n\n\nReturn the \nsigned\n distance between particle \np\n and obstacle \no\n, based on \np.pos\n. Positive distance corresponds to the particle being on the \nallowed\n region of the Obstacle. E.g. for a \nDisk\n, the distance is positive when the particle is outside of the disk, negative otherwise.\n\n\ndistance(p::AbstractParticle, bt::Vector{Obstacle})\n\n\n\n\nReturn minimum \ndistance(p, obst)\n for all \nobst\n in \nbt\n, which can be negative.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.randominside\n \n \nFunction\n.\n\n\nrandominside(bt::Vector{Obstacle}[, omega])\n\n\n\n\nReturn a particle with correct (allowed) initial conditions inside the given billiard table defined by the vector \nbt\n. If supplied with a second argument the type of the returned particle is \nMagneticParticle\n, with angular velocity \nomega\n. Else, it is \nParticle\n.\n\n\nsource\n\n\n\n\nPropagation\n\n\n#\n\n\nDynamicalBilliards.resolvecollision!\n \n \nFunction\n.\n\n\nresolvecollision!(p::AbstractParticle, o::Obstacle)\n\n\n\n\nResolve the collision between particle \np\n and obstacle \no\n. If the obstacle is not a periodic wall, the function performs specular reflection. If it is a periodic wall, it performs the periodicity condition.\n\n\nresolvecollision!()\n takes special care so that the particle is always inside the correct side of the billiard table, in order to avoid particle leakage. Specifically, it calculates the distance from particle and obstacle and, depending on the obstacle type, makes necessary adjustments by propagating the particle forwards or backwards in time using \nlinear\n motion.\n\n\nresolvecollision!(p, o, T::Function, \u03b8::Function, new_\u03c9::Function)\n\n\n\n\nThis is the ray-splitting implementation. The three functions given are drawn from the ray-splitting dictionary that is passed directly to \nevolve!()\n. For a calculated incidence angle \u03c6, if T(\u03c6) \n rand(), ray-splitting occurs. (See the section \"Ray-Splitting\" of the official documentation for more info.)\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.collisiontime\n \n \nFunction\n.\n\n\ncollisiontime(p::AbstractParticle, o::Obstacle)\n\n\n\n\nCalculate the collision time between given particle and obstacle.\n\n\nThe funtion chooses the appropriate method depending on the type of particle (magnetic or not) as well as the type of the obstacle. Returns the time that the particle, given its current position and Type, must be propagated to reach the collision point. This time can be given directly to \npropagate!(p, time)\n which brings the particle to the collision point.\n\n\nIn the case of magnetic propagation, there are always two possible collisions. The function internally decides which of the two will occur first, based on the sign of the angular velocity of the magnetic particle.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.propagate!\n \n \nFunction\n.\n\n\npropagate!(p::AbstractParticle, t)\n\n\n\n\nPropagate the particle \np\n for given time \nt\n, changing appropriately the the \np.pos\n and \np.vel\n fields.\n\n\nFor a \nParticle\n the propagation is a straight line (i.e. velocity vector is constant).\n\n\nFor a \nMagneticParticle\n the propagation is circular motion with cyclic frequency \np.omega\n and radius \n1/p.omega\n.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.evolve!\n \n \nFunction\n.\n\n\nevolve!(p::AbstractParticle, bt::Vector{Obstacle}, ttotal)\n\n\n\n\nEvolve the given particle \np\n inside the billiard table \nbt\n for a total amount of time \nttotal\n. Return the states of the particle between collisions.\n\n\nThe evolution takes into account the particle's Type. E.g. if \ntypeof(p) == MagneticParticle\n then magnetic evolution will take place.\n\n\nCalling\n\n\nCall the function like:\n\n\nt, poss, vels, (\u03c9)* = evolve!(p, bt, ttotal)\n\n\n\n\n(see \"Returns\" section for more)\n\n\nTo get the position, velocity and time timeseries from the above output, use the function \nconstruct\n: \nxt, yt, vxt, vyt, ts = construct(evolve!(p, bt, ttotal)...)\n\n\nReturns\n\n\nAs noted by the \"!\" at the end of the function, it changes its argument \np\n (particle). Most importantly however, this function also returns the main output expected by a billiard system. This output is a tuple of 3 (or 4) vectors:\n\n\n\n\nct::Vector{Float64}\n : Collision times.\n\n\nposs::Vector{SVector{2}}\n : Positions during collisions.\n\n\nvels:: Vector{SVector{2}})\n : Velocities \nexactly after\n the collisions.\n\n\n\u03c9\n, either \nFloat64\n or \nVector{Float64}\n : Angular velocity(/ies).\n\n\n\n\nIn the case of straight propagation, only the first 3 are returned.\n\n\nIn the case of magnetic propagation, the 4th value is returned as well. This is either the angular velocity of the particle (\nFloat64\n), or in the case of ray-splitting it is a vector of the angular velocities at each time step (\nVector\n).\n\n\nThe time \nct[i]\n is the time necessary to reach state \nposs[i+1], vels[i+1]\n starting from the state \nposs[i], vels[i]\n. That is why \nct[1]\n is always 0 since \nposs[1], vels[1]\n are the initial conditions. The angular velocity \n\u03c9[i]\n is the one the particle has while propagating from state \nposs[i], vels[i]\n to \ni+1\n.\n\n\nNotice that at any point, the velocity vector \nvels[i]\n is the one obtained \nafter\n the specular reflection of the (i-1)th collision. The function \nconstruct\n takes that into account.\n\n\nRay-splitting billiards\n\n\nNo matter how complex ray-splitting processes you want, and irrespectively of how many obstacles in the billiard table can perform ray-splitting, there is only a single difference on the main function call: The \nevolve!()\n function is supplemented with a fourth argument, \nray_splitter::Dict{Int, Vector{Function}}\n. This dictionary object handles all ray-splitting processes in the billiard system. It is a map of the Obstacle index within the billiard table to the ray-splitting functions: (\u03c6 is the angle of incidence)\n\n\n\n\nT(\u03c6, where, \u03c9) : Transmission probability.\n\n\n\u03b8(\u03c6, where, \u03c9) : Transmission (aka refraction) angle.\n\n\n\u03c9_new(\u03c9, where) : Angular velocity after transmission.\n\n\n\n\nFor more information and instructions on defining these functions please visit the official documentation.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.construct\n \n \nFunction\n.\n\n\nconstruct(ct, poss, vels[, \u03c9][, dt=0.01])\n\n\n\n\nGiven the main output of this package (see \nevolve!()\n function) construct the timeseries of the position and velocity, as well as the time vector.\n\n\nIn case of not given \u03c9 (or \u03c9 == 0), straight construction takes place. In case of \u03c9 != 0 or in case of \u03c9::Vector{Real} magnetic construction takes place.\n\n\nThe additional optional argument of \ndt\n (only valid for Magnetic construction) is the timestep with which the timeseries are constructed.\n\n\nCalling\n\n\nCall this function like:\n\n\n# Straight propagation:\nxt, yt, vxt, vyt, ts = construct(ct, poss, vels)\n# Magnetic propagation:\nxt, yt, vxt, vyt, ts = construct(ct, poss, vels, \u03c9, dt)\n# Any-kind-of propagation (skip dt for straight):\nxt, yt, vxt, vyt, ts = construct(evolve!(p, bt, ttotal[, ray_splitter])..., dt)\n\n\n\n\nThere is no difference in the \nconstruct\n call for Ray-Splitting billiards if one uses the awesome ellipsis operator of Julia. The reason for that is that \nevolve!()\n also returns the vector of angular velocities when necessary.\n\n\nReturns\n\n\nA tuple of the following:\n\n\n\n\nxt::Vector{Float64} : x position time-series\n\n\nyt::Vector{Float64} : y position time-series\n\n\nvxt::Vector{Float64} : x velocity time-series\n\n\nvyt::Vector{Float64} : y velocity time-series\n\n\nts::Vector{Float64} : Continuous time vector\n\n\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.isphysical\n \n \nFunction\n.\n\n\nisphysical(raysplitter::Dict{Int, Vector{Function}}; only_mandatory = false)\n\n\n\n\nReturn \ntrue\n if the given ray-splitting dictionary represends the physical world.\n\n\nSpecifically, check if (\u03c6 is the incidence angle):\n\n\n\n\nCritical angle means total reflection: If \u03b8(\u03c6) \u2265 \u03c0/2 then T(\u03c6) = 0\n\n\nTransmission probability is even function: T(\u03c6) \u2248 T(-\u03c6)\n\n\nRefraction angle is odd function: \u03b8(\u03c6) \u2248 -\u03b8(-\u03c6)\n\n\nRay reversal is true: \u03b8(\u03b8(\u03c6, where, \u03c9), !where, \u03c9) \u2248 \u03c6\n\n\nMagnetic conservation is true: (\u03c9_new(\u03c9_new(\u03c9, where), !where) \u2248 \u03c9\n\n\n\n\nThe first property is mandatory and must hold for correct propagation. They keyword \nonly_mandatory\n notes whether the rest of the properties should be tested or not.\n\n\nsource\n\n\n\n\nStandard Billiards\n\n\n#\n\n\nDynamicalBilliards.billiard_rectangle\n \n \nFunction\n.\n\n\nbilliard_rectangle(x=1.0, y=1.0; periodic = false)\n\n\n\n\nReturn a vector of obstacles that defines a rectangle billiard of size (\nx\n, \ny\n).\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.billiard_sinai\n \n \nFunction\n.\n\n\nbilliard_sinai(r, x=1.0, y=1.0; periodic = false)\n\n\n\n\nReturn a vector of obstacles that defines a Sinai billiard of size (\nx\n, \ny\n) with a disk in its center, of radius \nr\n.\n\n\nIn the periodic case, the system is also known as \"Lorentz Gas\".\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.billiard_polygon\n \n \nFunction\n.\n\n\nbilliard_polygon(n::Int, R, center = [0,0]; periodic = true)\n\n\n\n\nReturn a vector of obstacles that defines a regular-polygonal billiard table with \nn\n sides, radius \nr\n and given \ncenter\n. If \nn\n is even, you may choose a periodic version of the billiard.\n\n\nNote: \nR\n denotes the so-called outer radius, not the inner one.\n\n\nsource", 
            "title": "Library"
        }, 
        {
            "location": "/basic/library/#particles", 
            "text": "#  DynamicalBilliards.Particle     Type .  Particle  : AbstractParticle  Two-dimensional particle in a billiard table.  Fields:   pos::SVector{2,Float64}  : Current position vector.  vel::SVector{2,Float64}  : Current velocity vector (always of measure 1).  current_cell::SVector{2,Float64}  : Current \"cell\" the particle is located at. (Used only in periodic billiards)   Additional constructors:  Particle{T :Real}(ic::Vector{T}) #where ic = [x0, y0, \u03c60]\nParticle(x::Real, y::Real, \u03c6::Real)\nParticle() = Particle(rand(), rand(), rand()*2\u03c0)  source  #  DynamicalBilliards.MagneticParticle     Type .  MagneticParticle  : AbstractParticle  Two-dimensional particle in a billiard table with perpendicular magnetic field.  Fields:   pos::SVector{2,Float64}  : Current position vector.  vel::SVector{2,Float64}  : Current velocity vector (always of measure 1).  current_cell::SVector{2,Float64}  : Current \"cell\" the particle is located at. (Used only in periodic billiards)  omega::Float64  : Angular velocity (cyclic frequency) of rotational motion. Radius of rotation is  r=1/omega .   Additional constructors:  MagneticParticle{T :Real}(ic::Vector{T}, \u03c9::Real) #where ic = [x0, y0, \u03c60]\nMagneticParticle(x0::Real, y0::Real, \u03c60::Real, \u03c9::Real)\nMagneticParticle() = MagneticParticle([rand(), rand(), rand()*2\u03c0], 1.0)  source  #  DynamicalBilliards.magnetic2standard     Function .  magnetic2standard(p::MagneticParticle, use_cell = true)  Create a standard  Particle  from a  MagneticParticle .  source  #  DynamicalBilliards.standard2magnetic     Function .  standard2magnetic(omega, p::Particle, use_cell = true)  Create a  MagneticParticle  from a  Particle .  source  #  DynamicalBilliards.cyclotron     Function .  cyclotron(p::MagneticParticle, use_cell = false)  Return center and radius of circular motion performed by the particle based on  p.pos  (or  p.pos + p.current_cell ) and  p.vel .  source", 
            "title": "Particles"
        }, 
        {
            "location": "/basic/library/#obstacles", 
            "text": "#  DynamicalBilliards.Obstacle     Type .  Obstacle  Obstacle supertype.  source  #  DynamicalBilliards.Disk     Type .  Disk  : Circular  Disk-like obstacle with propagation allowed outside of the circle.  Fields:   c::SVector{2,Float64}  : Center.  r::Float64  : Radius.  name::String  : Some name given for user convenience.   Constructors accept any vectors convertible to SVector{2,Float64}.  source  #  DynamicalBilliards.Antidot     Type .  Antidot  : Circular  Disk-like obstacle that allows propagation both inside and outside of the disk. Used in ray-splitting billiards.  Fields:   c::SVector{2,Float64}  : Center.  r::Float64  : Radius.  where::Bool  : Flag that keeps track of where the particle is currently propagating.  true  stands for  outside  the disk,  false  for  inside  the disk.  name::String  : Name of the obstacle given for user convenience.   Constructors accept any vectors convertible to SVector{2,Float64}.  source  #  DynamicalBilliards.FiniteWall     Type .  FiniteWall  : Wall  Wall obstacle imposing specular reflection during collision.  Fields:   sp::SVector{2,Float64}  : Starting point of the Wall.  ep::SVector{2,Float64}  : Ending point of the Wall.  normal::SVector{2,Float64}  : Normal vector to the wall, pointing to where the particle  will come from before a collision  (pointing towards the inside the billiard table). The size of the vector is irrelevant.  name::String  : Name of the obstacle, e.g. \"left wall\", given for user convenience.   Constructors accept any vectors convertible to SVector{2,Float64}.  source  #  DynamicalBilliards.PeriodicWall     Type .  PeriodicWall  : Wall  Wall obstacle that imposes periodic boundary conditions upon collision.  Fields:   sp::SVector{2,Float64}  : Starting point of the Wall.  ep::SVector{2,Float64}  : Ending point of the Wall.  normal::SVector{2,Float64}  : Normal vector to the wall, pointing to where the particle  will come from  (to the inside the billiard table). The size of the vector is  important . This vector is added to a particle's  pos  during collision. Therefore the size of the normal vector must be correctly associated with the size of the periodic cell.  name::String  : Name of the obstacle, e.g. \"left boundary\", given for user convenience.   Constructors accept any vectors convertible to SVector{2,Float64}.  source  #  DynamicalBilliards.SplitterWall     Type .  SplitterWall  : Wall  Wall obstacle imposing specular reflection during collision.  Fields:   sp::SVector{2,Float64}  : Starting point of the Wall.  ep::SVector{2,Float64}  : Ending point of the Wall.  normal::SVector{2,Float64}  : Normal vector to the wall, pointing to where the particle  will come from before a collision . The size of the vector is irrelevant.  where::Bool  : Flag that keeps track of where the particle is currently propagating.  true  is associated with the  normal  vector the wall is instantiated with.  name::String  : Name of the obstacle, e.g. \"ray-splitting wall 1\", given for user convenience.   Constructors accept any vectors convertible to SVector{2,Float64}.  source  #  DynamicalBilliards.normalvec     Function .  normalvec(obst::Obstacle, position)  Return the vector normal to the obstacle at the given position (which is assumed to be very close to the obstacle's boundary).  The normal vector of any Obstacle must be looking towards the direction a particle is expected to come from.  source  #  DynamicalBilliards.distance     Function .  distance(p::AbstractParticle, o::Obstacle)  Return the  signed  distance between particle  p  and obstacle  o , based on  p.pos . Positive distance corresponds to the particle being on the  allowed  region of the Obstacle. E.g. for a  Disk , the distance is positive when the particle is outside of the disk, negative otherwise.  distance(p::AbstractParticle, bt::Vector{Obstacle})  Return minimum  distance(p, obst)  for all  obst  in  bt , which can be negative.  source  #  DynamicalBilliards.randominside     Function .  randominside(bt::Vector{Obstacle}[, omega])  Return a particle with correct (allowed) initial conditions inside the given billiard table defined by the vector  bt . If supplied with a second argument the type of the returned particle is  MagneticParticle , with angular velocity  omega . Else, it is  Particle .  source", 
            "title": "Obstacles"
        }, 
        {
            "location": "/basic/library/#propagation", 
            "text": "#  DynamicalBilliards.resolvecollision!     Function .  resolvecollision!(p::AbstractParticle, o::Obstacle)  Resolve the collision between particle  p  and obstacle  o . If the obstacle is not a periodic wall, the function performs specular reflection. If it is a periodic wall, it performs the periodicity condition.  resolvecollision!()  takes special care so that the particle is always inside the correct side of the billiard table, in order to avoid particle leakage. Specifically, it calculates the distance from particle and obstacle and, depending on the obstacle type, makes necessary adjustments by propagating the particle forwards or backwards in time using  linear  motion.  resolvecollision!(p, o, T::Function, \u03b8::Function, new_\u03c9::Function)  This is the ray-splitting implementation. The three functions given are drawn from the ray-splitting dictionary that is passed directly to  evolve!() . For a calculated incidence angle \u03c6, if T(\u03c6)   rand(), ray-splitting occurs. (See the section \"Ray-Splitting\" of the official documentation for more info.)  source  #  DynamicalBilliards.collisiontime     Function .  collisiontime(p::AbstractParticle, o::Obstacle)  Calculate the collision time between given particle and obstacle.  The funtion chooses the appropriate method depending on the type of particle (magnetic or not) as well as the type of the obstacle. Returns the time that the particle, given its current position and Type, must be propagated to reach the collision point. This time can be given directly to  propagate!(p, time)  which brings the particle to the collision point.  In the case of magnetic propagation, there are always two possible collisions. The function internally decides which of the two will occur first, based on the sign of the angular velocity of the magnetic particle.  source  #  DynamicalBilliards.propagate!     Function .  propagate!(p::AbstractParticle, t)  Propagate the particle  p  for given time  t , changing appropriately the the  p.pos  and  p.vel  fields.  For a  Particle  the propagation is a straight line (i.e. velocity vector is constant).  For a  MagneticParticle  the propagation is circular motion with cyclic frequency  p.omega  and radius  1/p.omega .  source  #  DynamicalBilliards.evolve!     Function .  evolve!(p::AbstractParticle, bt::Vector{Obstacle}, ttotal)  Evolve the given particle  p  inside the billiard table  bt  for a total amount of time  ttotal . Return the states of the particle between collisions.  The evolution takes into account the particle's Type. E.g. if  typeof(p) == MagneticParticle  then magnetic evolution will take place.  Calling  Call the function like:  t, poss, vels, (\u03c9)* = evolve!(p, bt, ttotal)  (see \"Returns\" section for more)  To get the position, velocity and time timeseries from the above output, use the function  construct :  xt, yt, vxt, vyt, ts = construct(evolve!(p, bt, ttotal)...)  Returns  As noted by the \"!\" at the end of the function, it changes its argument  p  (particle). Most importantly however, this function also returns the main output expected by a billiard system. This output is a tuple of 3 (or 4) vectors:   ct::Vector{Float64}  : Collision times.  poss::Vector{SVector{2}}  : Positions during collisions.  vels:: Vector{SVector{2}})  : Velocities  exactly after  the collisions.  \u03c9 , either  Float64  or  Vector{Float64}  : Angular velocity(/ies).   In the case of straight propagation, only the first 3 are returned.  In the case of magnetic propagation, the 4th value is returned as well. This is either the angular velocity of the particle ( Float64 ), or in the case of ray-splitting it is a vector of the angular velocities at each time step ( Vector ).  The time  ct[i]  is the time necessary to reach state  poss[i+1], vels[i+1]  starting from the state  poss[i], vels[i] . That is why  ct[1]  is always 0 since  poss[1], vels[1]  are the initial conditions. The angular velocity  \u03c9[i]  is the one the particle has while propagating from state  poss[i], vels[i]  to  i+1 .  Notice that at any point, the velocity vector  vels[i]  is the one obtained  after  the specular reflection of the (i-1)th collision. The function  construct  takes that into account.  Ray-splitting billiards  No matter how complex ray-splitting processes you want, and irrespectively of how many obstacles in the billiard table can perform ray-splitting, there is only a single difference on the main function call: The  evolve!()  function is supplemented with a fourth argument,  ray_splitter::Dict{Int, Vector{Function}} . This dictionary object handles all ray-splitting processes in the billiard system. It is a map of the Obstacle index within the billiard table to the ray-splitting functions: (\u03c6 is the angle of incidence)   T(\u03c6, where, \u03c9) : Transmission probability.  \u03b8(\u03c6, where, \u03c9) : Transmission (aka refraction) angle.  \u03c9_new(\u03c9, where) : Angular velocity after transmission.   For more information and instructions on defining these functions please visit the official documentation.  source  #  DynamicalBilliards.construct     Function .  construct(ct, poss, vels[, \u03c9][, dt=0.01])  Given the main output of this package (see  evolve!()  function) construct the timeseries of the position and velocity, as well as the time vector.  In case of not given \u03c9 (or \u03c9 == 0), straight construction takes place. In case of \u03c9 != 0 or in case of \u03c9::Vector{Real} magnetic construction takes place.  The additional optional argument of  dt  (only valid for Magnetic construction) is the timestep with which the timeseries are constructed.  Calling  Call this function like:  # Straight propagation:\nxt, yt, vxt, vyt, ts = construct(ct, poss, vels)\n# Magnetic propagation:\nxt, yt, vxt, vyt, ts = construct(ct, poss, vels, \u03c9, dt)\n# Any-kind-of propagation (skip dt for straight):\nxt, yt, vxt, vyt, ts = construct(evolve!(p, bt, ttotal[, ray_splitter])..., dt)  There is no difference in the  construct  call for Ray-Splitting billiards if one uses the awesome ellipsis operator of Julia. The reason for that is that  evolve!()  also returns the vector of angular velocities when necessary.  Returns  A tuple of the following:   xt::Vector{Float64} : x position time-series  yt::Vector{Float64} : y position time-series  vxt::Vector{Float64} : x velocity time-series  vyt::Vector{Float64} : y velocity time-series  ts::Vector{Float64} : Continuous time vector   source  #  DynamicalBilliards.isphysical     Function .  isphysical(raysplitter::Dict{Int, Vector{Function}}; only_mandatory = false)  Return  true  if the given ray-splitting dictionary represends the physical world.  Specifically, check if (\u03c6 is the incidence angle):   Critical angle means total reflection: If \u03b8(\u03c6) \u2265 \u03c0/2 then T(\u03c6) = 0  Transmission probability is even function: T(\u03c6) \u2248 T(-\u03c6)  Refraction angle is odd function: \u03b8(\u03c6) \u2248 -\u03b8(-\u03c6)  Ray reversal is true: \u03b8(\u03b8(\u03c6, where, \u03c9), !where, \u03c9) \u2248 \u03c6  Magnetic conservation is true: (\u03c9_new(\u03c9_new(\u03c9, where), !where) \u2248 \u03c9   The first property is mandatory and must hold for correct propagation. They keyword  only_mandatory  notes whether the rest of the properties should be tested or not.  source", 
            "title": "Propagation"
        }, 
        {
            "location": "/basic/library/#standard-billiards", 
            "text": "#  DynamicalBilliards.billiard_rectangle     Function .  billiard_rectangle(x=1.0, y=1.0; periodic = false)  Return a vector of obstacles that defines a rectangle billiard of size ( x ,  y ).  source  #  DynamicalBilliards.billiard_sinai     Function .  billiard_sinai(r, x=1.0, y=1.0; periodic = false)  Return a vector of obstacles that defines a Sinai billiard of size ( x ,  y ) with a disk in its center, of radius  r .  In the periodic case, the system is also known as \"Lorentz Gas\".  source  #  DynamicalBilliards.billiard_polygon     Function .  billiard_polygon(n::Int, R, center = [0,0]; periodic = true)  Return a vector of obstacles that defines a regular-polygonal billiard table with  n  sides, radius  r  and given  center . If  n  is even, you may choose a periodic version of the billiard.  Note:  R  denotes the so-called outer radius, not the inner one.  source", 
            "title": "Standard Billiards"
        }
    ]
}